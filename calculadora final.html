<!DOCTYPE html>
<html lang="pt-BR" data-theme="light">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dashboard de Controle Financeiro Familiar</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.4/moment.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.4/locale/pt-br.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/uuid/8.3.2/uuid.min.js"></script>
  <!-- Firebase App -->
  <script type="module">
    // Importar módulos do Firebase
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { 
      getFirestore, 
      collection, 
      addDoc, 
      getDocs, 
      doc, 
      updateDoc, 
      deleteDoc, 
      query, 
      where, 
      orderBy
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

    // Configuração específica do seu projeto Firebase
    const firebaseConfig = {
      apiKey: "AIzaSyDvL_nYWhy_8rPouejiWbDZtDCKHYOQyEY",
      authDomain: "calculadora-da-familia.firebaseapp.com",
      projectId: "calculadora-da-familia",
      storageBucket: "calculadora-da-familia.appspot.com",
      messagingSenderId: "69721783786",
      appId: "1:69721783786:web:c4703b5c182e3681e8c693",
      measurementId: "G-YM5TR661S6"
    };

    // Inicializar Firebase e acessar Firestore
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // Tornar o db acessível globalmente
    window.db = db;
    window.firestore = {
      collection, 
      addDoc, 
      getDocs, 
      doc, 
      updateDoc, 
      deleteDoc, 
      query, 
      where, 
      orderBy
    };
  </script>
  <style>
    /* ===== Variáveis e Temas Apple ===== */
    :root {
      --font-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", "Inter", Roboto, Helvetica, Arial, sans-serif;
      --radius-sm: 0.75rem;
      --radius: 1.125rem;
      --radius-lg: 1.5rem;
      --shadow: 0 2px 14px rgba(0,0,0,0.06), 0 8px 24px rgba(0,0,0,0.04);
      --shadow-hover: 0 4px 18px rgba(0,0,0,0.08), 0 10px 28px rgba(0,0,0,0.06);
      --shadow-dropdown: 0 4px 20px rgba(0,0,0,0.1);
      --transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      
      /* Cores iOS/macOS Light */
      --bg: #F5F5F7;
      --card-bg: #FFFFFF;
      --input-bg: rgba(142, 142, 147, 0.12);
      --text: #1D1D1F;
      --text-secondary: #86868B;
      --primary: #0066CC;
      --primary-light: #147CE5;
      --success: #34C759;
      --warning: #FF9F0A;
      --danger: #FF3B30;
      --info: #5AC8FA;
      --purple: #AF52DE;
      --teal: #64D2FF;
      --border: rgba(0,0,0,0.08);
      --chart-grid: rgba(0,0,0,0.04);
      --menu-bg: rgba(255, 255, 255, 0.9);
      --receipt-bg: #FBFBFD;
    }
    
    [data-theme="dark"] {
      /* Cores iOS/macOS Dark */
      --bg: #1D1D1F;
      --card-bg: #2C2C2E;
      --input-bg: rgba(142, 142, 147, 0.18);
      --text: #F5F5F7;
      --text-secondary: #98989D;
      --primary: #0A84FF;
      --primary-light: #5AC8FA;
      --success: #30D158;
      --warning: #FF9F0A;
      --danger: #FF453A;
      --info: #64D2FF;
      --purple: #BF5AF2;
      --teal: #6AC4DC;
      --border: rgba(255,255,255,0.12);
      --chart-grid: rgba(255,255,255,0.06);
      --menu-bg: rgba(44, 44, 46, 0.9);
      --receipt-bg: #323234;
    }
    
    /* ===== Reset e Configurações Base ===== */
    *, *::before, *::after { 
      box-sizing: border-box; 
      margin: 0;
      padding: 0;
    }
    
    html, body { 
      font-family: var(--font-sans); 
      background: var(--bg); 
      color: var(--text); 
      transition: var(--transition);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      font-size: 16px;
      line-height: 1.5;
      width: 100%;
      overflow-x: hidden;
    }
    
    /* ===== Layout e Componentes ===== */
    .container { 
      max-width: 1280px; 
      margin: 0 auto; 
      padding: 2rem; 
    }
    
    .header { 
      display: flex; 
      justify-content: space-between; 
      align-items: center; 
      margin-bottom: 2rem; 
      flex-wrap: wrap;
      gap: 1rem;
    }
    
    .header-title {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }
    
    h1 { 
      font-size: 1.75rem; 
      font-weight: 700;
      margin: 0;
      letter-spacing: -0.025em;
    }
    
    .header-right {
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    
    .filters { 
      display: flex; 
      gap: 0.75rem;
      flex-wrap: wrap;
    }
    
    /* Select estilo Apple */
    select { 
      appearance: none;
      -webkit-appearance: none;
      padding: 0.625rem 2rem 0.625rem 1rem;
      border-radius: var(--radius-sm); 
      border: none;
      background: var(--input-bg) url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='6' fill='none'%3E%3Cpath fill='%2386868b' d='M6 6 0 0h12L6 6Z'/%3E%3C/svg%3E") no-repeat;
      background-position: right 0.75rem center;
      color: var(--text);
      font-family: var(--font-sans);
      font-size: 0.9375rem;
      font-weight: 500;
      cursor: pointer;
      transition: var(--transition);
    }
    
    select:hover {
      background-color: rgba(142, 142, 147, 0.18);
    }
    
    select option {
      background-color: var(--card-bg);
      color: var(--text);
    }
    
    /* Botões */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      padding: 0.625rem 1.25rem;
      border-radius: var(--radius-sm);
      font-weight: 500;
      font-size: 0.9375rem;
      cursor: pointer;
      transition: var(--transition);
      border: none;
      color: #fff;
      background-color: var(--primary);
    }
    
    .btn:hover {
      opacity: 0.9;
      transform: translateY(-1px);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    
    .btn-primary {
      background-color: var(--primary);
    }
    
    .btn-success {
      background-color: var(--success);
    }
    
    .btn-warning {
      background-color: var(--warning);
    }
    
    .btn-danger {
      background-color: var(--danger);
    }
    
    .btn-icon {
      width: 2.5rem;
      height: 2.5rem;
      padding: 0;
      border-radius: 50%;
      background: var(--input-bg);
      color: var(--text);
    }
    
    .btn-icon:hover {
      background-color: rgba(142, 142, 147, 0.2);
    }
    
    .btn-icon svg {
      width: 1.25rem;
      height: 1.25rem;
    }
    
    /* Botão toggle theme */
    .theme-toggle {
      background: var(--input-bg);
      border: none;
      border-radius: 50%;
      width: 2.5rem;
      height: 2.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: var(--text);
      transition: var(--transition);
    }
    
    .theme-toggle:hover {
      background-color: rgba(142, 142, 147, 0.2);
    }
    
    .theme-toggle svg {
      width: 1.25rem;
      height: 1.25rem;
      fill: none;
      stroke: currentColor;
      stroke-width: 2;
      stroke-linecap: round;
      stroke-linejoin: round;
    }
    
    /* Cards de KPIs */
    .kpis { 
      display: grid; 
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); 
      gap: 1rem; 
      margin-bottom: 2rem; 
    }
    
    .card {
      background: var(--card-bg);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 1.5rem;
      transition: var(--transition);
      overflow: hidden;
      position: relative;
    }
    
    .card:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-hover);
    }
    
    .kpi-card {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    
    .kpi-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .kpi-title {
      font-size: 0.9375rem;
      font-weight: 500;
      color: var(--text-secondary);
    }
    
    .kpi-value {
      font-size: 1.5rem;
      font-weight: 700;
      letter-spacing: -0.01em;
    }
    
    .kpi-footer {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.5rem;
      font-size: 0.875rem;
      color: var(--text-secondary);
    }
    
    .kpi-trend {
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }
    
    .kpi-trend.up {
      color: var(--success);
    }
    
    .kpi-trend.down {
      color: var(--danger);
    }
    
    .kpi-trend svg {
      width: 0.875rem;
      height: 0.875rem;
      stroke: currentColor;
      stroke-width: 2;
      stroke-linecap: round;
      stroke-linejoin: round;
    }
    
    .kpi-meta {
      color: var(--text-secondary);
      font-size: 0.75rem;
      margin-top: 0.5rem;
    }
    
    /* Tabs */
    .tabs {
      display: flex;
      border-bottom: 1px solid var(--border);
      margin-bottom: 1.5rem;
      overflow-x: auto;
      scrollbar-width: none;
      -ms-overflow-style: none;
    }
    
    .tabs::-webkit-scrollbar {
      display: none;
    }
    
    .tab {
      padding: 0.75rem 1.25rem;
      font-weight: 500;
      color: var(--text-secondary);
      cursor: pointer;
      white-space: nowrap;
      border-bottom: 2px solid transparent;
      transition: var(--transition);
    }
    
    .tab:hover {
      color: var(--text);
    }
    
    .tab.active {
      color: var(--primary);
      border-color: var(--primary);
    }
    
    /* Gráficos */
    .charts-grid { 
      display: grid; 
      grid-template-columns: repeat(auto-fit, minmax(500px, 1fr)); 
      gap: 1.5rem; 
      margin-bottom: 2rem;
    }
    
    .chart-container {
      position: relative;
      margin-top: 0.5rem;
      height: 260px;
    }
    
    .chart-title {
      font-size: 1.125rem;
      font-weight: 600;
      margin-bottom: 1rem;
      letter-spacing: -0.01em;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .chart-title-actions {
      display: flex;
      gap: 0.75rem;
    }
    
    .chart-legend {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      margin-top: 0.5rem;
      font-size: 0.875rem;
    }
    
    .chart-legend-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .chart-legend-color {
      width: 0.75rem;
      height: 0.75rem;
      border-radius: 50%;
    }
    
    .full-width { 
      grid-column: 1 / -1; 
    }
    
    .full-width .chart-container {
      height: 300px;
    }
    
    /* Tabelas */
    .table-container {
      overflow-x: auto;
      margin-bottom: 2rem;
      border-radius: var(--radius);
      background: var(--card-bg);
      box-shadow: var(--shadow);
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9375rem;
    }
    
    thead {
      background-color: var(--input-bg);
    }
    
    th {
      padding: 1rem;
      font-weight: 600;
      text-align: left;
      color: var(--text-secondary);
    }
    
    td {
      padding: 1rem;
      border-top: 1px solid var(--border);
    }
    
    tr:hover td {
      background-color: var(--input-bg);
    }
    
    .table-actions {
      display: flex;
      gap: 0.5rem;
      opacity: 0.5;
      transition: var(--transition);
    }
    
    tr:hover .table-actions {
      opacity: 1;
    }
    
    .table-action-btn {
      width: 1.75rem;
      height: 1.75rem;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--input-bg);
      border: none;
      cursor: pointer;
      color: var(--text);
      transition: var(--transition);
    }
    
    .table-action-btn:hover {
      background-color: rgba(142, 142, 147, 0.3);
    }
    
    .table-action-btn svg {
      width: 1rem;
      height: 1rem;
      stroke: currentColor;
      stroke-width: 2;
      stroke-linecap: round;
      stroke-linejoin: round;
    }
    
    /* Status e Tags */
    .status {
      display: inline-flex;
      align-items: center;
      gap: 0.375rem;
      padding: 0.25rem 0.75rem;
      border-radius: 1rem;
      font-size: 0.75rem;
      font-weight: 500;
    }
    
    .status.status-paid {
      background-color: rgba(52, 199, 89, 0.1);
      color: var(--success);
    }
    
    .status.status-pending {
      background-color: rgba(255, 159, 10, 0.1);
      color: var(--warning);
    }
    
    .status.status-overdue {
      background-color: rgba(255, 59, 48, 0.1);
      color: var(--danger);
    }
    
    .status.status-scheduled {
      background-color: rgba(90, 200, 250, 0.1);
      color: var(--info);
    }
    
    .tag {
      display: inline-flex;
      align-items: center;
      gap: 0.375rem;
      padding: 0.25rem 0.75rem;
      border-radius: 1rem;
      font-size: 0.75rem;
      font-weight: 500;
      background-color: var(--input-bg);
      color: var(--text-secondary);
    }
    
    /* Formulário Nova Transação */
    .form-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-bottom: 1.5rem;
    }
    
    .form-group {
      margin-bottom: 1rem;
    }
    
    .form-group label {
      display: block;
      margin-bottom: 0.5rem;
      font-size: 0.875rem;
      font-weight: 500;
      color: var(--text-secondary);
    }
    
    .form-control {
      width: 100%;
      padding: 0.75rem 1rem;
      font-size: 0.9375rem;
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
      background-color: var(--input-bg);
      color: var(--text);
      transition: var(--transition);
    }
    
    .form-control:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 2px rgba(10, 132, 255, 0.1);
    }
    
    /* Loading Estado */
    .loading-indicator {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(4px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    
    .loading-indicator.active {
      opacity: 1;
      pointer-events: all;
    }
    
    .spinner {
      width: 2.5rem;
      height: 2.5rem;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: #fff;
      animation: spin 1s ease-in-out infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Modais */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(4px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    
    .modal.active {
      opacity: 1;
      pointer-events: all;
    }
    
    .modal-content {
      background: var(--card-bg);
      border-radius: var(--radius);
      box-shadow: var(--shadow-hover);
      width: 90%;
      max-width: 600px;
      max-height: 90vh;
      overflow-y: auto;
      transform: translateY(20px);
      transition: transform 0.3s ease;
    }
    
    .modal.active .modal-content {
      transform: translateY(0);
    }
    
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1.25rem 1.5rem;
      border-bottom: 1px solid var(--border);
    }
    
    .modal-title {
      font-size: 1.25rem;
      font-weight: 600;
      margin: 0;
      letter-spacing: -0.01em;
    }
    
    .modal-close {
      background: var(--input-bg);
      border: none;
      width: 2rem;
      height: 2rem;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: var(--text);
      transition: var(--transition);
    }
    
    .modal-close:hover {
      background-color: rgba(142, 142, 147, 0.3);
    }
    
    .modal-body {
      padding: 1.5rem;
    }
    
    .modal-footer {
      padding: 1.25rem 1.5rem;
      display: flex;
      justify-content: flex-end;
      gap: 0.75rem;
      border-top: 1px solid var(--border);
    }
    
    /* Alertas */
    .alert {
      padding: 1rem 1.25rem;
      margin-bottom: 1.5rem;
      border-radius: var(--radius-sm);
      display: flex;
      align-items: flex-start;
      gap: 0.75rem;
    }
    
    .alert-info {
      background-color: rgba(10, 132, 255, 0.1);
      color: var(--primary);
    }
    
    .alert-success {
      background-color: rgba(52, 199, 89, 0.1);
      color: var(--success);
    }
    
    .alert-warning {
      background-color: rgba(255, 159, 10, 0.1);
      color: var(--warning);
    }
    
    .alert-danger {
      background-color: rgba(255, 59, 48, 0.1);
      color: var(--danger);
    }
    
    .alert-icon {
      flex-shrink: 0;
      width: 1.25rem;
      height: 1.25rem;
      stroke: currentColor;
      stroke-width: 2;
      stroke-linecap: round;
      stroke-linejoin: round;
    }
    
    .alert-content {
      flex: 1;
    }
    
    .alert-title {
      font-weight: 600;
      margin-bottom: 0.25rem;
    }
    
    /* Menu Contexto */
    .context-menu {
      position: absolute;
      min-width: 200px;
      background: var(--menu-bg);
      backdrop-filter: blur(8px);
      border-radius: var(--radius-sm);
      box-shadow: var(--shadow-dropdown);
      z-index: 100;
      opacity: 0;
      transform: translateY(10px);
      pointer-events: none;
      transition: all 0.2s ease;
    }
    
    .context-menu.active {
      opacity: 1;
      transform: translateY(0);
      pointer-events: all;
    }
    
    .context-menu-item {
      padding: 0.75rem 1rem;
      display: flex;
      align-items: center;
      gap: 0.75rem;
      cursor: pointer;
      transition: var(--transition);
    }
    
    .context-menu-item:hover {
      background-color: var(--input-bg);
    }
    
    .context-menu-item svg {
      width: 1rem;
      height: 1rem;
      stroke: currentColor;
      stroke-width: 2;
      stroke-linecap: round;
      stroke-linejoin: round;
    }
    
    .context-menu-divider {
      height: 1px;
      background-color: var(--border);
      margin: 0.25rem 0;
    }
    
    /* Fluxo de Caixa */
    .cash-flow-card {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    
    .cash-flow-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .cash-flow-title {
      font-size: 1.125rem;
      font-weight: 600;
    }
    
    .cash-flow-balance {
      font-size: 1.5rem;
      font-weight: 700;
    }
    
    .cash-flow-items {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }
    
    .flow-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      background-color: var(--input-bg);
      border-radius: var(--radius-sm);
      transition: var(--transition);
    }
    
    .flow-item:hover {
      background-color: rgba(142, 142, 147, 0.2);
    }
    
    .flow-item-left {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }
    
    .flow-item-icon {
      width: 2.5rem;
      height: 2.5rem;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
    }
    
    .flow-item-icon.income {
      background-color: var(--success);
    }
    
    .flow-item-icon.expense {
      background-color: var(--danger);
    }
    
    .flow-item-info {
      display: flex;
      flex-direction: column;
    }
    
    .flow-item-title {
      font-weight: 500;
    }
    
    .flow-item-meta {
      font-size: 0.75rem;
      color: var(--text-secondary);
    }
    
    .flow-item-amount {
      font-weight: 600;
    }
    
    .flow-item-amount.income {
      color: var(--success);
    }
    
    .flow-item-amount.expense {
      color: var(--danger);
    }

/* Recibo / Modal de Detalhes */
.receipt {
  background-color: var(--receipt-bg);
  border-radius: var(--radius);
  padding: 2rem;
  max-width: 400px;
  margin: 0 auto;
}

.receipt-header {
  text-align: center;
  margin-bottom: 2rem;
}

.receipt-title {
  font-size: 1.5rem;
  font-weight: 700;
  margin-bottom: 0.5rem;
}

.receipt-date {
  color: var(--text-secondary);
  font-size: 0.875rem;
}

.receipt-body {
  margin-bottom: 2rem;
}

.receipt-item {
  display: flex;
  justify-content: space-between;
  margin-bottom: 0.75rem;
}

.receipt-item-label {
  color: var(--text-secondary);
}

.receipt-item-value {
  font-weight: 500;
}

.receipt-divider {
  height: 1px;
  background: var(--border);
  margin: 1rem 0;
}

.receipt-total {
  display: flex;
  justify-content: space-between;
  font-weight: 700;
  font-size: 1.125rem;
  margin-top: 1rem;
}

.receipt-footer {
  text-align: center;
  color: var(--text-secondary);
  font-size: 0.875rem;
  margin-top: 2rem;
}

/* Menus e Navegação */
.nav {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.nav-item {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 0.75rem 1rem;
  border-radius: var(--radius-sm);
  cursor: pointer;
  transition: var(--transition);
}

.nav-item:hover, 
.nav-item.active {
  background-color: var(--input-bg);
}

.nav-item.active {
  color: var(--primary);
}

.nav-item svg {
  width: 1.25rem;
  height: 1.25rem;
  stroke: currentColor;
  stroke-width: 2;
  stroke-linecap: round;
  stroke-linejoin: round;
}

/* Progress & Metas */
.progress-container {
  width: 100%;
  height: 0.5rem;
  background-color: var(--input-bg);
  border-radius: 1rem;
  overflow: hidden;
  margin-top: 0.5rem;
}

.progress-bar {
  height: 100%;
  border-radius: 1rem;
  transition: width 0.5s ease;
}

.progress-bar.success {
  background-color: var(--success);
}

.progress-bar.warning {
  background-color: var(--warning);
}
 
.progress-bar.danger {
  background-color: var(--danger);
}

/* Gerenciamento de categorias */
.category-item {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 0.75rem 1rem;
  background: var(--input-bg);
  border-radius: var(--radius-sm);
  margin-bottom: 0.75rem;
}

.category-item-color {
  width: 2rem;
  height: 2rem;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.25rem;
  color: white;
  flex-shrink: 0;
}

.category-item-info {
  flex: 1;
}

.category-item-actions {
  display: flex;
  gap: 0.5rem;
}

.color-grid {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  gap: 0.5rem;
  margin-bottom: 1rem;
}

.color-item {
  width: 2rem;
  height: 2rem;
  border-radius: 50%;
  cursor: pointer;
  border: 2px solid transparent;
  transition: var(--transition);
}

.color-item:hover, 
.color-item.selected {
  transform: scale(1.1);
}

.color-item.selected {
  border-color: var(--text);
}

.icon-grid {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  gap: 0.5rem;
  margin-bottom: 1rem;
}

.icon-item {
  width: 2rem;
  height: 2rem;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--input-bg);
  cursor: pointer;
  border: 2px solid transparent;
  transition: var(--transition);
}

.icon-item:hover, 
.icon-item.selected {
  background-color: rgba(142, 142, 147, 0.3);
}

.icon-item.selected {
  border-color: var(--primary);
}

/* Análise mensal */
.month-nav {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1.5rem;
}

.month-selector {
  display: flex;
  align-items: center;
  gap: 1rem;
}

.month-nav-arrow {
  width: 2.5rem;
  height: 2.5rem;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--input-bg);
  border: none;
  cursor: pointer;
  color: var(--text);
  transition: var(--transition);
}

.month-nav-arrow:hover {
  background-color: rgba(142, 142, 147, 0.3);
}

.month-nav-arrow svg {
  width: 1.25rem;
  height: 1.25rem;
}

.month-title {
  font-size: 1.5rem;
  font-weight: 700;
}

.month-summary {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 1rem;
  margin-bottom: 2rem;
}

.month-summary-item {
  padding: 1.5rem;
  background: var(--card-bg);
  border-radius: var(--radius);
  box-shadow: var(--shadow);
}

.month-summary-title {
  font-size: 0.9375rem;
  font-weight: 500;
  color: var(--text-secondary);
  margin-bottom: 0.5rem;
}

.month-summary-value {
  font-size: 1.75rem;
  font-weight: 700;
}

.month-transactions {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.month-transaction {
  display: flex;
  justify-content: space-between;
  padding: 1rem;
  background-color: var(--input-bg);
  border-radius: var(--radius-sm);
  align-items: center;
}

.month-transaction-left {
  display: flex;
  align-items: center;
  gap: 1rem;
}

.month-transaction-icon {
  width: 2.5rem;
  height: 2.5rem;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
}

.month-transaction-info {
  display: flex;
  flex-direction: column;
}

.month-transaction-title {
  font-weight: 500;
}

.month-transaction-date {
  font-size: 0.75rem;
  color: var(--text-secondary);
}

.month-transaction-amount {
  font-weight: 600;
}

/* Responsividade */
@media (max-width: 1024px) {
  .container {
    padding: 1.5rem;
  }
  
  .header {
    flex-direction: column;
    align-items: flex-start;
  }
  
  .header-right {
    width: 100%;
    justify-content: space-between;
  }
  
  .charts-grid {
    grid-template-columns: 1fr;
  }
}

@media (max-width: 768px) {
  .kpis {
    grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
  }
  
  .form-grid {
    grid-template-columns: 1fr;
  }
  
  .month-summary {
    grid-template-columns: 1fr;
  }
}

@media (max-width: 576px) {
  .container {
    padding: 1rem;
  }
  
  .kpis {
    grid-template-columns: 1fr;
  }
  
  .flow-item {
    flex-direction: column;
    align-items: flex-start;
    gap: 0.5rem;
  }
  
  .flow-item-left {
    width: 100%;
    justify-content: space-between;
  }
  
  .month-transaction {
    flex-direction: column;
    align-items: flex-start;
    gap: 0.75rem;
  }
  
  .month-transaction-left {
    width: 100%;
  }
}
  </style>
</head>
<body>
  <div class="container">
    <!-- Header e Filtros -->
    <div class="header">
      <div class="header-title">
        <h1>Controle Financeiro Familiar</h1>
      </div>
      <div class="header-right">
        <div class="filters">
          <select id="filter-year">
            <!-- Anos serão inseridos via JavaScript -->
          </select>
          <select id="filter-month">
            <!-- Meses serão inseridos via JavaScript -->
          </select>
          <select id="filter-category">
            <option value="all">Todas Categorias</option>
          </select>
          <select id="filter-type">
            <option value="all">Todos Tipos</option>
            <option value="income">Receitas</option>
            <option value="expense">Despesas</option>
          </select>
        </div>
        <button class="btn btn-primary" id="btn-new-transaction">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="12" y1="5" x2="12" y2="19"></line>
            <line x1="5" y1="12" x2="19" y2="12"></line>
          </svg>
          Nova Transação
        </button>
        <button class="theme-toggle" id="theme-toggle" aria-label="Alternar Tema">
          <svg id="theme-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M12 3a9 9 0 1 0 9 9c0-.46-.04-.92-.1-1.36a5.389 5.389 0 0 1-4.4 2.26 5.403 5.403 0 0 1-3.14-9.8c-.44-.06-.9-.1-1.36-.1z" />
          </svg>
        </button>
      </div>
    </div>
<!-- KPIs -->
<div class="kpis">
  <div class="card kpi-card">
    <div class="kpi-header">
      <div class="kpi-title">Saldo Atual</div>
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="10"></circle>
        <line x1="12" y1="8" x2="12" y2="12"></line>
        <line x1="12" y1="16" x2="12.01" y2="16"></line>
      </svg>
    </div>
    <div class="kpi-value" id="kpi-balance">R$ 0,00</div>
    <div class="kpi-footer">
      <div class="kpi-trend">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="23 6 13.5 15.5 8.5 10.5 1 18"></polyline>
          <polyline points="17 6 23 6 23 12"></polyline>
        </svg>
        <span id="balance-trend">0%</span>
      </div>
      <span>vs. mês anterior</span>
    </div>
  </div>
  
  <div class="card kpi-card">
    <div class="kpi-header">
      <div class="kpi-title">Receitas</div>
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="var(--success)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="12" y1="19" x2="12" y2="5"></line>
        <polyline points="5 12 12 5 19 12"></polyline>
      </svg>
    </div>
    <div class="kpi-value" style="color: var(--success);" id="kpi-income">R$ 0,00</div>
    <div class="kpi-footer">
      <div class="kpi-trend">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="23 6 13.5 15.5 8.5 10.5 1 18"></polyline>
          <polyline points="17 6 23 6 23 12"></polyline>
        </svg>
        <span id="income-trend">0%</span>
      </div>
      <span>vs. mês anterior</span>
    </div>
  </div>
  
  <div class="card kpi-card">
    <div class="kpi-header">
      <div class="kpi-title">Despesas</div>
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="var(--danger)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="12" y1="5" x2="12" y2="19"></line>
        <polyline points="19 12 12 19 5 12"></polyline>
      </svg>
    </div>
    <div class="kpi-value" style="color: var(--danger);" id="kpi-expenses">R$ 0,00</div>
    <div class="kpi-footer">
      <div class="kpi-trend">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="23 18 13.5 8.5 8.5 13.5 1 6"></polyline>
          <polyline points="17 18 23 18 23 12"></polyline>
        </svg>
        <span id="expenses-trend">0%</span>
      </div>
      <span>vs. mês anterior</span>
    </div>
  </div>
  
  <div class="card kpi-card">
    <div class="kpi-header">
      <div class="kpi-title">Economia do Mês</div>
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="10"></circle>
        <polyline points="8 12 12 16 16 12"></polyline>
        <line x1="12" y1="8" x2="12" y2="16"></line>
      </svg>
    </div>
    <div class="kpi-value" id="kpi-savings">R$ 0,00</div>
    <div class="kpi-meta">
      <div>Meta: R$ <span id="savings-goal">1.000,00</span></div>
      <div class="progress-container">
        <div class="progress-bar success" id="savings-progress" style="width: 0%"></div>
      </div>
    </div>
  </div>
  
  <div class="card kpi-card">
    <div class="kpi-header">
      <div class="kpi-title">Projeção de Gastos</div>
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
        <line x1="16" y1="2" x2="16" y2="6"></line>
        <line x1="8" y1="2" x2="8" y2="6"></line>
        <line x1="3" y1="10" x2="21" y2="10"></line>
      </svg>
    </div>
    <div class="kpi-value" id="kpi-projection">R$ 0,00</div>
    <div class="kpi-footer">
      <div class="kpi-trend" id="projection-status">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
          <polyline points="22 4 12 14.01 9 11.01"></polyline>
        </svg>
        <span>No orçamento</span>
      </div>
    </div>
  </div>
</div>

<!-- Tabs de Navegação -->
<div class="tabs">
  <div class="tab active" data-tab="overview">Visão Geral</div>
  <div class="tab" data-tab="transactions">Transações</div>
  <div class="tab" data-tab="budget">Orçamento</div>
  <div class="tab" data-tab="goals">Metas</div>
  <div class="tab" data-tab="monthly">Análise Mensal</div>
  <div class="tab" data-tab="categories">Categorias</div>
  <div class="tab" data-tab="reports">Relatórios</div>
</div>

<!-- Conteúdo das Tabs -->
<div class="tab-content" id="tab-overview">
  <!-- Gráficos de Visão Geral -->
  <div class="charts-grid">
    <div class="card">
      <div class="chart-title">
        <span>Receitas vs Despesas</span>
        <div class="chart-title-actions">
          <select id="income-expense-chart-period">
            <option value="6">Últimos 6 meses</option>
            <option value="12" selected>Últimos 12 meses</option>
            <option value="24">Últimos 24 meses</option>
          </select>
        </div>
      </div>
      <div class="chart-container">
        <canvas id="income-expense-chart"></canvas>
      </div>
    </div>
    
    <div class="card">
      <div class="chart-title">
        <span>Despesas por Categoria</span>
        <div class="chart-title-actions">
          <select id="category-chart-period">
            <option value="current" selected>Mês Atual</option>
            <option value="last">Mês Anterior</option>
            <option value="average">Média Anual</option>
          </select>
        </div>
      </div>
      <div class="chart-container">
        <canvas id="category-chart"></canvas>
      </div>
    </div>
    
    <div class="card full-width">
      <div class="chart-title">
        <span>Fluxo de Caixa Mensal</span>
        <div class="chart-title-actions">
          <select id="cashflow-chart-year">
            <!-- Anos serão inseridos via JavaScript -->
          </select>
        </div>
      </div>
      <div class="chart-container">
        <canvas id="cashflow-chart"></canvas>
      </div>
    </div>
    
    <div class="card">
      <div class="chart-title">
        <span>Gastos Fixos vs Variáveis</span>
      </div>
      <div class="chart-container">
        <canvas id="fixed-variable-chart"></canvas>
      </div>
    </div>
    
    <div class="card">
      <div class="chart-title">
        <span>Tendência de Gastos</span>
        <div class="chart-title-actions">
          <select id="trend-chart-category">
            <option value="all" selected>Todas Categorias</option>
          </select>
        </div>
      </div>
      <div class="chart-container">
        <canvas id="trend-chart"></canvas>
      </div>
    </div>
  </div>

<!-- Atividade Recente -->
  <div class="card">
    <div class="chart-title">Transações Recentes</div>
    <div class="cash-flow-items" id="recent-transactions">
      <!-- Transações recentes serão inseridas via JavaScript -->
      <div style="text-align: center; padding: 2rem 0; color: var(--text-secondary);">
        Carregando transações recentes...
      </div>
    </div>
  </div>
</div>

<div class="tab-content" id="tab-transactions" style="display: none;">
  <!-- Filtros e Pesquisa -->
  <div style="display: flex; justify-content: space-between; margin-bottom: 1.5rem; gap: 1rem; flex-wrap: wrap;">
    <div style="display: flex; gap: 0.75rem; flex-wrap: wrap;">
      <select id="transactions-filter-year">
        <!-- Anos serão inseridos via JavaScript -->
      </select>
      
      <select id="transactions-filter-month">
        <!-- Meses serão inseridos via JavaScript -->
      </select>
      
      <select id="transactions-filter-type">
        <option value="all" selected>Todos Tipos</option>
        <option value="income">Receitas</option>
        <option value="expense">Despesas</option>
      </select>
      
      <select id="transactions-filter-category">
        <option value="all" selected>Todas Categorias</option>
      </select>
      
      <select id="transactions-filter-status">
        <option value="all" selected>Todos Status</option>
        <option value="paid">Pago</option>
        <option value="pending">Pendente</option>
        <option value="scheduled">Agendado</option>
      </select>
    </div>
    
    <div style="position: relative; min-width: 250px;">
      <input type="text" class="form-control" id="transactions-search" placeholder="Pesquisar transações...">
    </div>
  </div>
  
  <!-- Tabela de Transações -->
  <div class="table-container">
    <table id="transactions-table">
      <thead>
        <tr>
          <th>Data</th>
          <th>Descrição</th>
          <th>Categoria</th>
          <th>Valor</th>
          <th>Status</th>
          <th>Ações</th>
        </tr>
      </thead>
      <tbody id="transactions-table-body">
        <!-- Transações serão inseridas via JavaScript -->
        <tr>
          <td colspan="6" style="text-align: center; padding: 2rem 0; color: var(--text-secondary);">
            Carregando transações...
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  
<!-- Paginação -->  
  <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 1rem;">
    <div>
      <span id="transactions-showing">Mostrando 0 de 0 transações</span>
    </div>
    <div style="display: flex; gap: 0.5rem;">
      <button class="btn btn-icon" id="transactions-prev">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="15 18 9 12 15 6"></polyline>
        </svg>
      </button>
      <button class="btn btn-icon" id="transactions-next">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="9 18 15 12 9 6"></polyline>
        </svg>
      </button>
    </div>
  </div>
</div>

<div class="tab-content" id="tab-budget" style="display: none;">
  <!-- Gráficos de Orçamento -->
  <div class="charts-grid">
    <div class="card">
      <div class="chart-title">Orçamento vs Real (Mês Atual)</div>
      <div class="chart-container">
        <canvas id="budget-chart"></canvas>
      </div>
    </div>
    
    <div class="card">
      <div class="chart-title">Progresso do Orçamento</div>
      <div id="budget-progress-container">
        <!-- Progresso de orçamento será inserido via JavaScript -->
        <div style="text-align: center; padding: 2rem 0; color: var(--text-secondary);">
          Carregando dados de orçamento...
        </div>
      </div>
    </div>
  </div>
  
<!-- Tabela de Orçamento -->  
  <div class="card">
    <div class="chart-title">
      <span>Planejamento de Orçamento</span>
      <button class="btn btn-primary" id="btn-edit-budget">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
          <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
        </svg>
        Editar Orçamento
      </button>
    </div>
    <div class="table-container">
      <table id="budget-table">
        <thead>
          <tr>
            <th>Categoria</th>
            <th>Orçamento</th>
            <th>Gasto Atual</th>
            <th>Restante</th>
            <th>Progresso</th>
          </tr>
        </thead>
        <tbody id="budget-table-body">
          <!-- Orçamento será inserido via JavaScript -->
          <tr>
            <td colspan="5" style="text-align: center; padding: 2rem 0; color: var(--text-secondary);">
              Carregando dados de orçamento...
            </td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>
</div>

<div class="tab-content" id="tab-goals" style="display: none;">
  <!-- Metas Financeiras -->
  <div class="charts-grid">
    <div class="card" style="grid-column: span 2;">
      <div class="chart-title">
        <span>Progresso das Metas</span>
        <button class="btn btn-primary" id="btn-add-goal">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="12" y1="5" x2="12" y2="19"></line>
            <line x1="5" y1="12" x2="19" y2="12"></line>
          </svg>
          Nova Meta
        </button>
      </div>
      <div id="goals-container">
        <!-- Metas serão inseridas via JavaScript -->
        <div style="text-align: center; padding: 2rem 0; color: var(--text-secondary);">
          Carregando metas...
        </div>
      </div>
    </div>
    
    <div class="card">
      <div class="chart-title">Projeção de Economia</div>
      <div class="chart-container">
        <canvas id="savings-projection-chart"></canvas>
      </div>
    </div>
  </div>
</div>

<!-- Nova Tab: Análise Mensal -->
<div class="tab-content" id="tab-monthly" style="display: none;">
  <div class="month-nav">
    <button class="month-nav-arrow" id="prev-month">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polyline points="15 18 9 12 15 6"></polyline>
      </svg>
    </button>
    
    <div class="month-selector">
      <select id="monthly-analysis-year">
        <!-- Anos serão inseridos via JavaScript -->
      </select>
      <select id="monthly-analysis-month">
        <!-- Meses serão inseridos via JavaScript -->
      </select>
    </div>
    
    <button class="month-nav-arrow" id="next-month">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polyline points="9 18 15 12 9 6"></polyline>
      </svg>
    </button>
  </div>
  
  <div class="month-summary">
    <div class="card">
      <div class="month-summary-title">Receitas Totais</div>
      <div class="month-summary-value" id="monthly-income" style="color: var(--success);">R$ 0,00</div>
      <div class="kpi-footer">
        <span id="monthly-income-count">0 transações</span>
      </div>
    </div>
    
    <div class="card">
      <div class="month-summary-title">Despesas Totais</div>
      <div class="month-summary-value" id="monthly-expense" style="color: var(--danger);">R$ 0,00</div>
      <div class="kpi-footer">
        <span id="monthly-expense-count">0 transações</span>
      </div>
    </div>
    
    <div class="card">
      <div class="month-summary-title">Saldo do Mês</div>
      <div class="month-summary-value" id="monthly-balance">R$ 0,00</div>
      <div class="kpi-footer">
        <span id="monthly-balance-status">Equilibrado</span>
      </div>
    </div>
  </div>
  
  <div class="charts-grid">
    <div class="card">
      <div class="chart-title">Principais Despesas por Categoria</div>
      <div class="chart-container">
        <canvas id="monthly-category-chart"></canvas>
      </div>
    </div>
    
    <div class="card">
      <div class="chart-title">Distribuição Diária</div>
      <div class="chart-container">
        <canvas id="monthly-daily-chart"></canvas>
      </div>
    </div>
  </div>
  
  <div class="card" style="margin-bottom: 2rem;">
    <div class="chart-title">
      <span>Lista de Receitas</span>
      <button class="btn btn-success" id="btn-add-income">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <line x1="12" y1="5" x2="12" y2="19"></line>
          <line x1="5" y1="12" x2="19" y2="12"></line>
        </svg>
        Nova Receita
      </button>
    </div>
    <div id="monthly-income-list" class="month-transactions">
      <!-- Receitas serão inseridas via JavaScript -->
      <div style="text-align: center; padding: 2rem 0; color: var(--text-secondary);">
        Carregando receitas...
      </div>
    </div>
  </div>
  
  <div class="card">
    <div class="chart-title">
      <span>Lista de Despesas</span>
      <button class="btn btn-danger" id="btn-add-expense">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <line x1="12" y1="5" x2="12" y2="19"></line>
          <line x1="5" y1="12" x2="19" y2="12"></line>
        </svg>
        Nova Despesa
      </button>
    </div>
    <div id="monthly-expense-list" class="month-transactions">
      <!-- Despesas serão inseridas via JavaScript -->
      <div style="text-align: center; padding: 2rem 0; color: var(--text-secondary);">
        Carregando despesas...
      </div>
    </div>
  </div>
</div>

<!-- Nova Tab: Categorias -->
<div class="tab-content" id="tab-categories" style="display: none;">
  <div style="display: flex; justify-content: space-between; margin-bottom: 1.5rem;">
    <h2 style="font-size: 1.5rem; margin: 0;">Gerenciamento de Categorias</h2>
    <div>
      <button class="btn btn-primary" id="btn-add-category">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <line x1="12" y1="5" x2="12" y2="19"></line>
          <line x1="5" y1="12" x2="19" y2="12"></line>
        </svg>
        Nova Categoria
      </button>
    </div>
  </div>
  
  <div class="card" style="margin-bottom: 2rem;">
    <div class="chart-title">Categorias de Receita</div>
    <div id="income-categories-list">
      <!-- Categorias de receita serão inseridas via JavaScript -->
      <div style="text-align: center; padding: 2rem 0; color: var(--text-secondary);">
        Carregando categorias de receita...
      </div>
    </div>
  </div>
  
  <div class="card">
    <div class="chart-title">Categorias de Despesa</div>
    <div id="expense-categories-list">
      <!-- Categorias de despesa serão inseridas via JavaScript -->
      <div style="text-align: center; padding: 2rem 0; color: var(--text-secondary);">
        Carregando categorias de despesa...
      </div>
    </div>
  </div>
</div>

<div class="tab-content" id="tab-reports" style="display: none;">
  <!-- Relatórios -->
  <div class="charts-grid">
    <div class="card">
      <div class="chart-title">
        <span>Relatório Mensal</span>
        <div class="chart-title-actions">
          <select id="report-year">
            <!-- Anos serão inseridos via JavaScript -->
          </select>
          <select id="report-month">
            <!-- Meses serão inseridos via JavaScript -->
          </select>
          <button class="btn btn-primary" id="btn-export-report">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
              <polyline points="7 10 12 15 17 10"></polyline>
              <line x1="12" y1="15" x2="12" y2="3"></line>
            </svg>
            Exportar
          </button>
        </div>
      </div>
      <div id="monthly-report-container">
        <!-- Relatório mensal será inserido via JavaScript -->
        <div style="text-align: center; padding: 2rem 0; color: var(--text-secondary);">
          Selecione um mês para gerar o relatório.
        </div>
      </div>
    </div>
    
    <div class="card">
      <div class="chart-title">
        <span>Análise de Gastos</span>
        <div class="chart-title-actions">
          <select id="analysis-type">
            <option value="category">Por Categoria</option>
            <option value="monthly">Mensal</option>
            <option value="yearly">Anual</option>
          </select>
        </div>
      </div>
      <div class="chart-container">
        <canvas id="analysis-chart"></canvas>
      </div>
    </div>
  </div>
</div>
  </div>

<!-- Modal de Nova Transação -->
  <div class="modal" id="transaction-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3 class="modal-title" id="transaction-modal-title">Nova Transação</h3>
        <button class="modal-close" id="transaction-modal-close">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
      <div class="modal-body">
        <form id="transaction-form">
          <input type="hidden" id="transaction-id">
      <div class="form-grid">
        <div class="form-group">
          <label for="transaction-type">Tipo</label>
          <select class="form-control" id="transaction-type" required>
            <option value="income">Receita</option>
            <option value="expense">Despesa</option>
          </select>
        </div>
        
        <div class="form-group">
          <label for="transaction-date">Data</label>
          <input type="date" class="form-control" id="transaction-date" required>
        </div>
      </div>
      
      <div class="form-group">
        <label for="transaction-description">Descrição</label>
        <input type="text" class="form-control" id="transaction-description" placeholder="Ex: Salário, Mercado, Conta de Luz..." required>
      </div>
      
      <div class="form-grid">
        <div class="form-group">
          <label for="transaction-amount">Valor (R$)</label>
          <input type="number" step="0.01" min="0.01" class="form-control" id="transaction-amount" placeholder="0,00" required>
        </div>
        
        <div class="form-group">
          <label for="transaction-category">Categoria</label>
          <select class="form-control" id="transaction-category" required>
            <!-- Categorias serão inseridas via JavaScript -->
          </select>
        </div>
      </div>
      
      <div class="form-grid">
        <div class="form-group">
          <label for="transaction-status">Status</label>
          <select class="form-control" id="transaction-status" required>
            <option value="paid">Pago</option>
            <option value="pending">Pendente</option>
            <option value="scheduled">Agendado</option>
          </select>
        </div>
        
        <div class="form-group">
          <label for="transaction-payment-method">Forma de Pagamento</label>
          <select class="form-control" id="transaction-payment-method">
            <option value="">Selecione...</option>
            <option value="cash">Dinheiro</option>
            <option value="credit_card">Cartão de Crédito</option>
            <option value="debit_card">Cartão de Débito</option>
            <option value="bank_transfer">Transferência Bancária</option>
            <option value="pix">PIX</option>
            <option value="other">Outro</option>
          </select>
        </div>
      </div>
      
      <div class="form-group">
        <label for="transaction-notes">Observações</label>
        <textarea class="form-control" id="transaction-notes" rows="3" placeholder="Detalhes adicionais..."></textarea>
      </div>
      
      <div id="recurring-transaction-container">
        <div style="display: flex; align-items: center; gap: 1rem; margin-top: 1rem;">
          <input type="checkbox" id="transaction-recurring" style="width: auto;">
          <label for="transaction-recurring" style="margin-bottom: 0;">Transação Recorrente</label>
        </div>
        
        <div id="recurring-options" style="margin-top: 1rem; display: none;">
          <div class="form-grid">
            <div class="form-group">
              <label for="transaction-frequency">Frequência</label>
              <select class="form-control" id="transaction-frequency">
                <option value="weekly">Semanal</option>
                <option value="biweekly">Quinzenal</option>
                <option value="monthly" selected>Mensal</option>
                <option value="quarterly">Trimestral</option>
                <option value="semiannual">Semestral</option>
                <option value="annual">Anual</option>
              </select>
            </div>
            
            <div class="form-group">
              <label for="transaction-end-date">Data de Término (opcional)</label>
              <input type="date" class="form-control" id="transaction-end-date">
            </div>
          </div>
        </div>
      </div>
    </form>
  </div>
  <div class="modal-footer">
    <button class="btn" id="transaction-modal-cancel">Cancelar</button>
    <button class="btn btn-primary" id="transaction-modal-save">Salvar</button>
  </div>
</div>
  </div>

<!-- Modal de Edição de Orçamento -->
  <div class="modal" id="budget-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3 class="modal-title">Editar Orçamento</h3>
        <button class="modal-close" id="budget-modal-close">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
      <div class="modal-body">
        <form id="budget-form">
          <div class="form-group">
            <label for="budget-year">Ano</label>
            <select class="form-control" id="budget-year" required>
              <!-- Anos serão inseridos via JavaScript -->
            </select>
          </div>
      <div class="form-group">
        <label for="budget-month">Mês</label>
        <select class="form-control" id="budget-month" required>
          <!-- Meses serão inseridos via JavaScript -->
        </select>
      </div>
      
      <div id="budget-categories-container">
        <!-- Categorias de orçamento serão inseridas via JavaScript -->
        <div style="text-align: center; padding: 2rem 0; color: var(--text-secondary);">
          Carregando categorias...
        </div>
      </div>
    </form>
  </div>
  <div class="modal-footer">
    <button class="btn" id="budget-modal-cancel">Cancelar</button>
    <button class="btn btn-primary" id="budget-modal-save">Salvar</button>
  </div>
</div>
  </div>
  <!-- Modal de Nova Meta -->
  <div class="modal" id="goal-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3 class="modal-title" id="goal-modal-title">Nova Meta</h3>
        <button class="modal-close" id="goal-modal-close">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
      <div class="modal-body">
        <form id="goal-form">
          <input type="hidden" id="goal-id">
      <div class="form-group">
        <label for="goal-name">Nome da Meta</label>
        <input type="text" class="form-control" id="goal-name" placeholder="Ex: Férias, Novo Carro, Reforma..." required>
      </div>
      
      <div class="form-grid">
        <div class="form-group">
          <label for="goal-target">Valor Alvo (R$)</label>
          <input type="number" step="0.01" min="0.01" class="form-control" id="goal-target" placeholder="0,00" required>
        </div>
        
        <div class="form-group">
          <label for="goal-current">Valor Atual (R$)</label>
          <input type="number" step="0.01" min="0" class="form-control" id="goal-current" placeholder="0,00" required>
        </div>
      </div>
      
      <div class="form-grid">
        <div class="form-group">
          <label for="goal-date">Data Alvo</label>
          <input type="date" class="form-control" id="goal-date" required>
        </div>
        
        <div class="form-group">
          <label for="goal-category">Categoria</label>
          <select class="form-control" id="goal-category" required>
            <option value="savings">Economia</option>
            <option value="investment">Investimento</option>
            <option value="debt">Pagamento de Dívida</option>
            <option value="purchase">Compra</option>
            <option value="travel">Viagem</option>
            <option value="education">Educação</option>
            <option value="other">Outro</option>
          </select>
        </div>
      </div>
      
      <div class="form-group">
        <label for="goal-notes">Observações</label>
        <textarea class="form-control" id="goal-notes" rows="3" placeholder="Detalhes adicionais..."></textarea>
      </div>
    </form>
  </div>
  <div class="modal-footer">
    <button class="btn" id="goal-modal-cancel">Cancelar</button>
    <button class="btn btn-primary" id="goal-modal-save">Salvar</button>
  </div>
</div>
  </div>
  <!-- Modal de Nova Categoria -->
  <div class="modal" id="category-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3 class="modal-title" id="category-modal-title">Nova Categoria</h3>
        <button class="modal-close" id="category-modal-close">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
      <div class="modal-body">
        <form id="category-form">
          <input type="hidden" id="category-id">
      <div class="form-group">
        <label for="category-name">Nome da Categoria</label>
        <input type="text" class="form-control" id="category-name" placeholder="Ex: Alimentação, Transporte, Investimentos..." required>
      </div>
      
      <div class="form-group">
        <label for="category-type">Tipo</label>
        <select class="form-control" id="category-type" required>
          <option value="expense">Despesa</option>
          <option value="income">Receita</option>
        </select>
      </div>
      
      <div class="form-group">
        <label>Cor</label>
        <div class="color-grid" id="color-grid">
          <!-- Cores serão inseridas via JavaScript -->
        </div>
      </div>
      
      <div class="form-group">
        <label>Ícone</label>
        <div class="icon-grid" id="icon-grid">
          <!-- Ícones serão inseridos via JavaScript -->
        </div>
      </div>
    </form>
  </div>
  <div class="modal-footer">
    <button class="btn" id="category-modal-cancel">Cancelar</button>
    <button class="btn btn-primary" id="category-modal-save">Salvar</button>
  </div>
</div>
  </div>
  <!-- Modal de Detalhes da Transação -->
  <div class="modal" id="transaction-details-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3 class="modal-title">Detalhes da Transação</h3>
        <button class="modal-close" id="transaction-details-modal-close">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
      <div class="modal-body">
        <div class="receipt" id="transaction-receipt">
          <!-- Detalhes da transação serão inseridos via JavaScript -->
          <div style="text-align: center; padding: 2rem 0; color: var(--text-secondary);">
            Carregando detalhes da transação...
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-danger" id="transaction-details-delete">Excluir</button>
        <button class="btn btn-primary" id="transaction-details-edit">Editar</button>
      </div>
    </div>
  </div>
  <!-- Modal de Confirmação -->
  <div class="modal" id="confirm-modal">
    <div class="modal-content" style="max-width: 400px;">
      <div class="modal-header">
        <h3 class="modal-title" id="confirm-modal-title">Confirmação</h3>
        <button class="modal-close" id="confirm-modal-close">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
      <div class="modal-body">
        <p id="confirm-modal-message">Tem certeza que deseja realizar esta ação?</p>
      </div>
      <div class="modal-footer">
        <button class="btn" id="confirm-modal-cancel">Cancelar</button>
        <button class="btn btn-danger" id="confirm-modal-confirm">Confirmar</button>
      </div>
    </div>
  </div>

<!-- Loading Indicator -->
  <div class="loading-indicator" id="loading">
    <div class="spinner"></div>
  </div>
  <script>
    // ===== Configurações e Variáveis Globais =====
    const root = document.documentElement;
    const themeToggle = document.getElementById('theme-toggle');
    const themeIcon = document.getElementById('theme-icon');
    const loading = document.getElementById('loading');
    
    // Tabs
    const tabs = document.querySelectorAll('.tab');
    const tabContents = document.querySelectorAll('.tab-content');
    
    // Modais
    const transactionModal = document.getElementById('transaction-modal');
    const transactionForm = document.getElementById('transaction-form');
    const budgetModal = document.getElementById('budget-modal');
    const goalModal = document.getElementById('goal-modal');
    const categoryModal = document.getElementById('category-modal');
    const transactionDetailsModal = document.getElementById('transaction-details-modal');
    const confirmModal = document.getElementById('confirm-modal');
    
    // Botões
    const btnNewTransaction = document.getElementById('btn-new-transaction');
    const btnEditBudget = document.getElementById('btn-edit-budget');
    const btnAddGoal = document.getElementById('btn-add-goal');
    const btnAddCategory = document.getElementById('btn-add-category');
    const btnAddIncome = document.getElementById('btn-add-income');
    const btnAddExpense = document.getElementById('btn-add-expense');
    
    // Estados da Aplicação
    let transactions = [];
    let categories = [];
    let budgets = [];
    let goals = [];
    let currentTab = 'overview';
    
    // Configurações
    const TRANSACTION_TYPES = {
      income: {
        name: 'Receita',
        icon: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg>',
        color: 'var(--success)'
      },
      expense: {
        name: 'Despesa',
        icon: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><polyline points="19 12 12 19 5 12"></polyline></svg>',
        color: 'var(--danger)'
      }
    };
    
    // Categorias padrão (caso não haja nenhuma no banco de dados)
    const DEFAULT_EXPENSE_CATEGORIES = [
      { id: 'housing', name: 'Moradia', color: '#FF9F0A', icon: '🏠', type: 'expense' },
      { id: 'food', name: 'Alimentação', color: '#30D158', icon: '🍔', type: 'expense' },
      { id: 'transportation', name: 'Transporte', color: '#0A84FF', icon: '🚗', type: 'expense' },
      { id: 'health', name: 'Saúde', color: '#FF453A', icon: '🏥', type: 'expense' },
      { id: 'leisure', name: 'Lazer', color: '#BF5AF2', icon: '🎮', type: 'expense' },
      { id: 'education', name: 'Educação', color: '#5E5CE6', icon: '📚', type: 'expense' },
      { id: 'shopping', name: 'Compras', color: '#FF375F', icon: '🛍️', type: 'expense' },
      { id: 'bills', name: 'Contas', color: '#64D2FF', icon: '📝', type: 'expense' },
      { id: 'unexpected', name: 'Inesperadas', color: '#FF2D55', icon: '⚠️', type: 'expense' },
      { id: 'other_expenses', name: 'Outras Despesas', color: '#A0A0A0', icon: '💼', type: 'expense' }
    ];
      
    // Array de cores disponíveis para categorias
    const AVAILABLE_COLORS = [
      '#FF453A', // Vermelho
      '#FF9F0A', // Laranja
      '#FFD60A', // Amarelo
      '#30D158', // Verde
      '#64D2FF', // Azul claro
      '#0A84FF', // Azul
      '#5E5CE6', // Lilás
      '#BF5AF2', // Roxo
      '#FF375F', // Rosa
      '#AC8E68', // Marrom
      '#A0A0A0', // Cinza
      '#2C2C2E'  // Preto
    ];
    
    // Ícones disponíveis para categorias
    const AVAILABLE_ICONS = [
      '💰', '💳', '🏠', '🍔', '🚗', '🏥', '🎮', '📚', '🛍️', '📝',
      '⚠️', '✈️', '👪', '🎵', '💻', '📱', '🧾', '🎁', '💡', '🎓',
      '⛽', '🏦', '👕', '🍎', '🏋️', '🔧', '📊', '💼', '💲', '🎭',
      '🏢', '🚿', '📺', '☕', '🧹', '💊', '👶', '🐶', '💧', '🛒'
    ];
    
    // Status de pagamento
    const PAYMENT_METHODS = {
      'cash': 'Dinheiro',
      'credit_card': 'Cartão de Crédito',
      'debit_card': 'Cartão de Débito',
      'bank_transfer': 'Transferência Bancária',
      'pix': 'PIX',
      'other': 'Outro'
    };
    
    // Status de transação
    const TRANSACTION_STATUS = {
      'paid': { name: 'Pago', class: 'status-paid' },
      'pending': { name: 'Pendente', class: 'status-pending' },
      'scheduled': { name: 'Agendado', class: 'status-scheduled' },
      'overdue': { name: 'Atrasado', class: 'status-overdue' }
    };

    // ===== Firebase Integration =====

    // Referência para as coleções do Firestore
    let db; 
    let firestore;

    // Aguardar a inicialização do Firebase
    function waitForFirebase() {
      return new Promise((resolve) => {
        const checkFirebase = () => {
          if (window.db && window.firestore) {
            db = window.db;
            firestore = window.firestore;
            resolve();
          } else {
            setTimeout(checkFirebase, 100);
          }
        };
        checkFirebase();
      });
    }

    // Salvar transação no Firestore
    async function saveTransactionToFirestore(transaction) {
      try {
        showLoading();
        const transactionsRef = firestore.collection(db, 'transactions');
        
        // Se for uma atualização de transação existente
        if (transaction.id && transaction.firestoreId) {
          await firestore.updateDoc(firestore.doc(db, 'transactions', transaction.firestoreId), transaction);
          hideLoading();
          return transaction.firestoreId;
        } 
        // Se for uma nova transação
        else {
          const docRef = await firestore.addDoc(transactionsRef, transaction);
          hideLoading();
          return docRef.id;
        }
      } catch (error) {
        console.error('Erro ao salvar transação:', error);
        hideLoading();
        showAlert('Erro ao salvar transação. Tente novamente.', 'danger');
        throw error;
      }
    }

    // Carregar transações do Firestore
    async function loadTransactionsFromFirestore() {
      try {
        showLoading();
        const transactionsRef = firestore.collection(db, 'transactions');
        const snapshot = await firestore.getDocs(transactionsRef);
        
        let loadedTransactions = [];
        snapshot.forEach(doc => {
          const data = doc.data();
          loadedTransactions.push({
            ...data,
            firestoreId: doc.id
          });
        });
        
        hideLoading();
        return loadedTransactions;
      } catch (error) {
        console.error('Erro ao carregar transações:', error);
        hideLoading();
        showAlert('Erro ao carregar transações. Tente novamente.', 'danger');
        return [];
      }
    }

    // Excluir transação do Firestore
    async function deleteTransactionFromFirestore(firestoreId) {
      try {
        showLoading();
        await firestore.deleteDoc(firestore.doc(db, 'transactions', firestoreId));
        hideLoading();
        return true;
      } catch (error) {
        console.error('Erro ao excluir transação:', error);
        hideLoading();
        showAlert('Erro ao excluir transação. Tente novamente.', 'danger');
        return false;
      }
    }

    // Salvar categoria no Firestore
    async function saveCategoryToFirestore(category) {
      try {
        showLoading();
        const categoriesRef = firestore.collection(db, 'categories');
        
        // Se for uma atualização de categoria existente
        if (category.id && category.firestoreId) {
          await firestore.updateDoc(firestore.doc(db, 'categories', category.firestoreId), category);
          hideLoading();
          return category.firestoreId;
        } 
        // Se for uma nova categoria
        else {
          const docRef = await firestore.addDoc(categoriesRef, category);
          hideLoading();
          return docRef.id;
        }
      } catch (error) {
        console.error('Erro ao salvar categoria:', error);
        hideLoading();
        showAlert('Erro ao salvar categoria. Tente novamente.', 'danger');
        throw error;
      }
    }

    // Carregar categorias do Firestore
    async function loadCategoriesFromFirestore() {
      try {
        showLoading();
        const categoriesRef = firestore.collection(db, 'categories');
        const snapshot = await firestore.getDocs(categoriesRef);
        
        let loadedCategories = [];
        snapshot.forEach(doc => {
          const data = doc.data();
          loadedCategories.push({
            ...data,
            firestoreId: doc.id
          });
        });
        
        hideLoading();
        
        // Se não houver categorias, criar as padrões
        if (loadedCategories.length === 0) {
          loadedCategories = await createDefaultCategories();
        }
        
        return loadedCategories;
      } catch (error) {
        console.error('Erro ao carregar categorias:', error);
        hideLoading();
        showAlert('Erro ao carregar categorias. Tente novamente.', 'danger');
        return [];
      }
    }

// ===== Firebase Integration (Implementations - Continued from Part 1 Stubs) =====

// Excluir categoria do Firestore
async function deleteCategoryFromFirestore(firestoreId) {
  try {
    showLoading();
    await firestore.deleteDoc(firestore.doc(db, 'categories', firestoreId));
    hideLoading();
    return true;
  } catch (error) {
    console.error('Erro ao excluir categoria:', error);
    hideLoading();
    showAlert('Erro ao excluir categoria. Tente novamente.', 'danger');
    return false;
  }
}

// Salvar orçamento no Firestore
async function saveBudgetToFirestore(budget) {
  try {
    showLoading();
    const budgetsRef = firestore.collection(db, 'budgets');
    const budgetDataToSave = { ...budget }; // Clone para evitar modificar o original
    delete budgetDataToSave.firestoreId; // Não salvar o ID do Firestore dentro do documento

    // Verificar se já existe um orçamento para o mês/ano especificado
    const q = firestore.query(
      budgetsRef,
      firestore.where('year', '==', budget.year),
      firestore.where('month', '==', budget.month)
    );

    const querySnapshot = await firestore.getDocs(q);

    let docId;
    if (!querySnapshot.empty) {
      // Atualizar orçamento existente
      const existingBudgetDoc = querySnapshot.docs[0];
      await firestore.updateDoc(existingBudgetDoc.ref, budgetDataToSave);
      docId = existingBudgetDoc.id;
    } else {
      // Criar novo orçamento
      const docRef = await firestore.addDoc(budgetsRef, budgetDataToSave);
      docId = docRef.id;
    }
    hideLoading();
    return docId; // Retorna o ID do Firestore do documento salvo/atualizado
  } catch (error) {
    console.error('Erro ao salvar orçamento:', error);
    hideLoading();
    showAlert('Erro ao salvar orçamento. Tente novamente.', 'danger');
    throw error;
  }
}


// Carregar orçamentos do Firestore
async function loadBudgetsFromFirestore() {
  try {
    showLoading();
    const budgetsRef = firestore.collection(db, 'budgets');
    const snapshot = await firestore.getDocs(budgetsRef);

    let loadedBudgets = [];
    snapshot.forEach(doc => {
      const data = doc.data();
      loadedBudgets.push({
        ...data,
        firestoreId: doc.id // Adiciona o ID do Firestore ao objeto
      });
    });

    hideLoading();
    return loadedBudgets;
  } catch (error) {
    console.error('Erro ao carregar orçamentos:', error);
    hideLoading();
    showAlert('Erro ao carregar orçamentos. Tente novamente.', 'danger');
    return [];
  }
}


// Obter orçamento para um mês/ano específico
async function getBudgetForMonthAndYear(month, year) {
  // Tenta buscar no array local primeiro para otimizar
  const localBudget = budgets.find(b => b.month === month && b.year === year);
  if (localBudget) {
    return localBudget;
  }

  // Se não encontrar localmente, busca no Firestore
  try {
    const budgetsRef = firestore.collection(db, 'budgets');
    const q = firestore.query(
      budgetsRef,
      firestore.where('year', '==', year),
      firestore.where('month', '==', month)
    );

    const querySnapshot = await firestore.getDocs(q);

    if (!querySnapshot.empty) {
      const budgetDoc = querySnapshot.docs[0];
      const budgetData = {
        ...budgetDoc.data(),
        firestoreId: budgetDoc.id
      };
      // Adiciona ao array local para futuras buscas
      budgets.push(budgetData);
      return budgetData;
    }

    return null; // Nenhum orçamento encontrado para o período
  } catch (error) {
    console.error('Erro ao obter orçamento do Firestore:', error);
    // Não mostra alerta aqui, pois pode ser chamado frequentemente
    return null;
  }
}


// Salvar meta no Firestore
async function saveGoalToFirestore(goal) {
  try {
    showLoading();
    const goalsRef = firestore.collection(db, 'goals');
    const goalDataToSave = { ...goal };
    const firestoreId = goalDataToSave.firestoreId; // Guarda o ID antes de deletar
    delete goalDataToSave.firestoreId; // Não salvar o ID do Firestore dentro do documento

    let docId;
    if (firestoreId) {
      // Atualizar meta existente
      await firestore.updateDoc(firestore.doc(db, 'goals', firestoreId), goalDataToSave);
      docId = firestoreId;
    } else {
      // Criar nova meta
      const docRef = await firestore.addDoc(goalsRef, goalDataToSave);
      docId = docRef.id;
    }
    hideLoading();
    return docId; // Retorna o ID do Firestore
  } catch (error) {
    console.error('Erro ao salvar meta:', error);
    hideLoading();
    showAlert('Erro ao salvar meta. Tente novamente.', 'danger');
    throw error;
  }
}


// Carregar metas do Firestore
async function loadGoalsFromFirestore() {
  try {
    showLoading();
    const goalsRef = firestore.collection(db, 'goals');
    const snapshot = await firestore.getDocs(goalsRef);

    let loadedGoals = [];
    snapshot.forEach(doc => {
      const data = doc.data();
      loadedGoals.push({
        ...data,
        firestoreId: doc.id // Adiciona o ID do Firestore
      });
    });

    hideLoading();
    return loadedGoals;
  } catch (error) {
    console.error('Erro ao carregar metas:', error);
    hideLoading();
    showAlert('Erro ao carregar metas. Tente novamente.', 'danger');
    return [];
  }
}


// Excluir meta do Firestore
async function deleteGoalFromFirestore(firestoreId) {
  try {
    showLoading();
    await firestore.deleteDoc(firestore.doc(db, 'goals', firestoreId));
    hideLoading();
    return true;
  } catch (error) {
    console.error('Erro ao excluir meta:', error);
    hideLoading();
    showAlert('Erro ao excluir meta. Tente novamente.', 'danger');
    return false;
  }
}


// Criar categorias padrão se não existirem
async function createDefaultCategories() {
  // Usa a constante definida na Parte 1
  const defaultCategories = [
      { id: 'housing', name: 'Moradia', color: '#FF9F0A', icon: '🏠', type: 'expense' },
      { id: 'food', name: 'Alimentação', color: '#30D158', icon: '🍔', type: 'expense' },
      { id: 'transportation', name: 'Transporte', color: '#0A84FF', icon: '🚗', type: 'expense' },
      { id: 'health', name: 'Saúde', color: '#FF453A', icon: '🏥', type: 'expense' },
      { id: 'leisure', name: 'Lazer', color: '#BF5AF2', icon: '🎮', type: 'expense' },
      { id: 'education', name: 'Educação', color: '#5E5CE6', icon: '📚', type: 'expense' },
      { id: 'shopping', name: 'Compras', color: '#FF375F', icon: '🛍️', type: 'expense' },
      { id: 'bills', name: 'Contas', color: '#64D2FF', icon: '📝', type: 'expense' },
      { id: 'unexpected', name: 'Inesperadas', color: '#FF2D55', icon: '⚠️', type: 'expense' },
      { id: 'other_expenses', name: 'Outras Despesas', color: '#A0A0A0', icon: '💼', type: 'expense' },
      { id: 'salary', name: 'Salário', color: '#30D158', icon: '💰', type: 'income' },
      { id: 'bonus', name: 'Bônus', color: '#5E5CE6', icon: '🎁', type: 'income' },
      { id: 'investments', name: 'Investimentos', color: '#0A84FF', icon: '📊', type: 'income' },
      { id: 'other_income', name: 'Outras Receitas', color: '#FF9F0A', icon: '💸', type: 'income' }
    ];

  console.log("Tentando criar categorias padrão...");
  const savedCategories = [];
  showLoading(); // Mostra o loading antes do loop

  try {
      for (const category of defaultCategories) {
          // Adiciona o ID gerado pelo UUID se não existir (para consistência)
          if (!category.id) {
              category.id = uuid.v4();
          }
          const firestoreId = await saveCategoryToFirestore(category);
          savedCategories.push({
              ...category,
              firestoreId
          });
          console.log(`Categoria padrão "${category.name}" criada com ID: ${firestoreId}`);
      }
  } catch (error) {
      console.error('Erro durante a criação das categorias padrão:', error);
      showAlert('Erro ao criar categorias padrão. Verifique o console.', 'danger');
  } finally {
      hideLoading(); // Esconde o loading após o loop (ou erro)
  }

  console.log("Criação de categorias padrão concluída.");
  return savedCategories;
}

// ===== Utilitários e Helpers (Continued) =====

// Formatar moeda (Já definido na Parte 1, mas garantindo que esteja presente)
function formatCurrency(value) {
  if (typeof value !== 'number') {
      value = Number(value) || 0;
  }
  return new Intl.NumberFormat('pt-BR', {
    style: 'currency',
    currency: 'BRL'
  }).format(value);
}

// Formatar data (dd/MM/yyyy)
function formatDate(dateString) {
  if (!dateString) return '';
  try {
      // Tenta criar data a partir de YYYY-MM-DD ou timestamp
      const date = new Date(dateString);
      // Adiciona verificação para datas inválidas
      if (isNaN(date.getTime())) {
          console.warn("Data inválida encontrada:", dateString);
          return 'Data inválida';
      }
      // Adiciona o fuso horário para evitar problemas de 'off-by-one day'
      const adjustedDate = new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
      return new Intl.DateTimeFormat('pt-BR').format(adjustedDate);
  } catch (e) {
      console.error("Erro ao formatar data:", dateString, e);
      return 'Erro na data';
  }
}


// Formatar Datas para o atributo value do input (YYYY-MM-DD)
function formatDateForInput(dateString) {
    if (!dateString) return '';
    try {
        const date = new Date(dateString);
        if (isNaN(date.getTime())) {
             console.warn("Data inválida para input:", dateString);
             return '';
        }
        // Usa UTC para evitar problemas de fuso horário ao formatar para input type="date"
        const year = date.getUTCFullYear();
        const month = String(date.getUTCMonth() + 1).padStart(2, '0');
        const day = String(date.getUTCDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
    } catch (e) {
        console.error("Erro ao formatar data para input:", dateString, e);
        return '';
    }
}

// Mostrar indicador de carregamento
function showLoading() {
  const loadingElement = document.getElementById('loading');
  if (loadingElement) {
      loadingElement.classList.add('active');
  }
}

// Esconder indicador de carregamento
function hideLoading() {
  const loadingElement = document.getElementById('loading');
  if (loadingElement) {
      loadingElement.classList.remove('active');
  }
}

// Mostrar alerta dinâmico
function showAlert(message, type = 'info', duration = 4000) {
    const alertContainerId = 'alert-container';
    let alertContainer = document.getElementById(alertContainerId);

    // Cria o container se ele não existir
    if (!alertContainer) {
        alertContainer = document.createElement('div');
        alertContainer.id = alertContainerId;
        alertContainer.style.position = 'fixed';
        alertContainer.style.bottom = '20px';
        alertContainer.style.right = '20px';
        alertContainer.style.zIndex = '10000'; // Acima dos modais
        alertContainer.style.display = 'flex';
        alertContainer.style.flexDirection = 'column';
        alertContainer.style.gap = '10px';
        alertContainer.style.alignItems = 'flex-end'; // Alinha alertas à direita
        document.body.appendChild(alertContainer);
    }

    const alertElement = document.createElement('div');
    alertElement.className = `alert alert-${type}`; // Usa as classes CSS existentes
    alertElement.style.opacity = '0';
    alertElement.style.transform = 'translateX(100%)'; // Inicia fora da tela à direita
    alertElement.style.transition = 'transform 0.4s ease-out, opacity 0.4s ease-out';
    alertElement.style.cursor = 'pointer'; // Permite clicar para fechar
    alertElement.style.minWidth = '250px';
    alertElement.style.maxWidth = '400px';
    alertElement.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';

    let iconSvg = '';
    switch(type) {
        case 'success':
            iconSvg = '<path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline>';
            break;
        case 'warning':
        case 'danger':
            iconSvg = '<path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line>';
            break;
        case 'info':
        default:
            iconSvg = '<circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line>';
            break;
    }

    alertElement.innerHTML = `
      <svg class="alert-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        ${iconSvg}
      </svg>
      <div class="alert-content">${message}</div>
      <button class="alert-close-btn" style="background: none; border: none; color: inherit; cursor: pointer; margin-left: 15px; font-size: 1.2em; line-height: 1;">×</button>
    `;

    // Adiciona ao container
    alertContainer.appendChild(alertElement);

    // Animação de entrada
    requestAnimationFrame(() => {
        alertElement.style.opacity = '1';
        alertElement.style.transform = 'translateX(0)';
    });

    // Função para remover o alerta
    const removeAlert = () => {
        alertElement.style.opacity = '0';
        alertElement.style.transform = 'translateX(100%)';
        setTimeout(() => {
            if (alertElement.parentNode === alertContainer) { // Verifica se ainda está no DOM
                alertContainer.removeChild(alertElement);
                 // Remove o container se estiver vazio
                if (alertContainer.children.length === 0) {
                    document.body.removeChild(alertContainer);
                }
            }
        }, 400); // Tempo da animação de saída
    };

    // Remove após a duração
    const timeoutId = setTimeout(removeAlert, duration);

    // Permite fechar clicando no botão X ou no próprio alerta
    alertElement.querySelector('.alert-close-btn').addEventListener('click', (e) => {
        e.stopPropagation(); // Impede que o clique no botão propague para o alerta
        clearTimeout(timeoutId);
        removeAlert();
    });
    alertElement.addEventListener('click', () => {
        clearTimeout(timeoutId);
        removeAlert();
    });
}


// ===== Lógica de Tema (Continued) =====

// Atualizar ícone do toggle de tema
function updateThemeIcon(theme) {
  const themeIconElement = document.getElementById('theme-icon');
  if (!themeIconElement) return; // Proteção caso o elemento não exista

  if (theme === 'dark') {
    // Ícone de Sol (para tema escuro ativo)
    themeIconElement.innerHTML = '<circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>';
  } else {
    // Ícone de Lua (para tema claro ativo)
    themeIconElement.innerHTML = '<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>';
  }
}

// Setup do tema baseado em preferências do sistema e localStorage
function setupTheme() {
  const rootElement = document.documentElement;
  const prefersDarkScheme = window.matchMedia('(prefers-color-scheme: dark)');
  const savedTheme = localStorage.getItem('theme');
  let currentTheme;

  if (savedTheme) {
      currentTheme = savedTheme;
  } else {
      currentTheme = prefersDarkScheme.matches ? 'dark' : 'light';
  }

  rootElement.setAttribute('data-theme', currentTheme);
  updateThemeIcon(currentTheme);

  // Listener para mudanças de preferência do sistema (se não houver tema salvo)
   prefersDarkScheme.addEventListener('change', (e) => {
      if (!localStorage.getItem('theme')) { // Só muda se o usuário não tiver definido manualmente
          const newSystemTheme = e.matches ? 'dark' : 'light';
          rootElement.setAttribute('data-theme', newSystemTheme);
          updateThemeIcon(newSystemTheme);
          if (typeof updateCharts === 'function') { // Atualiza gráficos se a função existir
            updateCharts();
          }
      }
  });
}


// Event Listener para o Toggle de tema
const themeToggleButton = document.getElementById('theme-toggle');
if (themeToggleButton) {
    themeToggleButton.addEventListener('click', () => {
        const rootElement = document.documentElement;
        const currentTheme = rootElement.getAttribute('data-theme') || 'light';
        const newTheme = currentTheme === 'light' ? 'dark' : 'light';

        rootElement.setAttribute('data-theme', newTheme);
        localStorage.setItem('theme', newTheme); // Salva a preferência do usuário
        updateThemeIcon(newTheme);

        // Atualizar gráficos para o novo tema, se a função existir
        if (typeof updateCharts === 'function') {
            updateCharts();
        }
    });
} else {
    console.error("Elemento 'theme-toggle' não encontrado.");
}

// ===== Gerenciamento de Dados e Cálculos (Continued) =====

// Inicializar valores de anos para selects
function populateYearSelects() {
    const currentYear = new Date().getFullYear();
    // Seleciona todos os <select> que precisam de anos
    const yearSelects = document.querySelectorAll(
        '#filter-year, #transactions-filter-year, #cashflow-chart-year, #budget-year, #report-year, #monthly-analysis-year'
    );
    const startYear = currentYear - 5; // 5 anos passados
    const endYear = currentYear + 2;   // 2 anos futuros

    yearSelects.forEach(select => {
        if (select) {
            // Limpa opções existentes (importante para re-execuções)
            select.innerHTML = '';

            // Adiciona opção "Todos" ou "Selecione" se for um filtro
            if (select.id.includes('filter')) {
                 const allOption = document.createElement('option');
                 allOption.value = 'all';
                 allOption.textContent = 'Todos os Anos';
                 select.appendChild(allOption);
            } else if (!select.id.includes('chart')) { // Não adiciona em selects de gráfico
                 const selectOption = document.createElement('option');
                 selectOption.value = '';
                 selectOption.textContent = 'Selecione o Ano';
                 select.appendChild(selectOption);
            }


            // Adiciona anos do range
            for (let year = endYear; year >= startYear; year--) {
                const option = document.createElement('option');
                option.value = year;
                option.textContent = year;
                select.appendChild(option);
            }

            // Selecionar ano atual como padrão ou 'all' para filtros
            if (select.id.includes('filter')) {
                select.value = 'all';
            } else {
                select.value = currentYear;
            }
        } else {
            console.warn(`Select de ano não encontrado: ${select}`);
        }
    });
}

// Inicializar valores de meses para selects
function populateMonthSelects() {
    const months = [
        'Janeiro', 'Fevereiro', 'Março', 'Abril', 'Maio', 'Junho',
        'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'
    ];
    const currentMonth = new Date().getMonth(); // 0-11

    // Seleciona todos os <select> que precisam de meses
    const monthSelects = document.querySelectorAll(
        '#filter-month, #transactions-filter-month, #budget-month, #report-month, #monthly-analysis-month'
    );

    monthSelects.forEach(select => {
        if (select) {
            // Limpar opções existentes
            select.innerHTML = '';

            // Adicionar opção "Todos" ou "Selecione" se apropriado
            if (select.id.includes('filter')) {
                const allOption = document.createElement('option');
                allOption.value = 'all';
                allOption.textContent = 'Todos os Meses';
                select.appendChild(allOption);
            } else if (!select.id.includes('analysis')) { // Não adiciona "Selecione" no análise mensal
                const selectOption = document.createElement('option');
                selectOption.value = '';
                selectOption.textContent = 'Selecione o Mês';
                 select.appendChild(selectOption);
            }

            // Adicionar cada mês
            months.forEach((month, index) => {
                const option = document.createElement('option');
                option.value = index; // 0-11
                option.textContent = month;
                select.appendChild(option);
            });

            // Selecionar mês atual como padrão ou 'all' para filtros
            if (select.id.includes('filter')) {
                select.value = 'all';
            } else {
                 select.value = currentMonth;
            }

        } else {
            console.warn(`Select de mês não encontrado: ${select}`);
        }
    });
}

// Filtrar transações (Função central de filtragem)
function filterTransactions(filters = {}) {
    let filtered = [...transactions]; // Começa com todas as transações

    // Filtrar por tipo (income/expense)
    if (filters.type && filters.type !== 'all') {
        filtered = filtered.filter(t => t.type === filters.type);
    }

    // Filtrar por categoria ID
    if (filters.category && filters.category !== 'all') {
        filtered = filtered.filter(t => t.category === filters.category);
    }

    // Filtrar por status (paid/pending/scheduled)
    if (filters.status && filters.status !== 'all') {
        filtered = filtered.filter(t => t.status === filters.status);
    }

    // Filtrar por ano
    if (filters.year && filters.year !== 'all') {
        const year = parseInt(filters.year);
        filtered = filtered.filter(t => {
            if (!t.date) return false; // Ignora transações sem data
            try {
                // Usa UTC para evitar problemas de fuso
                return new Date(t.date).getUTCFullYear() === year;
            } catch (e) { return false; }
        });
    }

    // Filtrar por mês (0-11)
    if (filters.month !== undefined && filters.month !== 'all' && filters.month !== '') {
        const month = parseInt(filters.month);
        filtered = filtered.filter(t => {
             if (!t.date) return false;
            try {
                // Usa UTC para evitar problemas de fuso
                return new Date(t.date).getUTCMonth() === month;
            } catch (e) { return false; }
        });
    }

    // Pesquisar por texto na descrição ou notas
    if (filters.search) {
        const search = filters.search.toLowerCase().trim();
        if (search.length > 0) {
            filtered = filtered.filter(t =>
                (t.description && t.description.toLowerCase().includes(search)) ||
                (t.notes && t.notes.toLowerCase().includes(search))
            );
        }
    }

    // Ordenar por data (mais recente primeiro por padrão)
    filtered.sort((a, b) => {
        const dateA = a.date ? new Date(a.date).getTime() : 0;
        const dateB = b.date ? new Date(b.date).getTime() : 0;
        return dateB - dateA; // Mais recente primeiro
    });

    return filtered;
}


// Obter o resumo financeiro para um conjunto de transações
function getFinanceSummary(filteredTransactions) {
    const summary = {
        income: 0,
        expenses: 0,
        balance: 0,
        pendingIncome: 0,
        pendingExpenses: 0,
        projectedBalance: 0
    };

    filteredTransactions.forEach(t => {
        const amount = Number(t.amount) || 0;
        if (t.type === 'income') {
            if (t.status === 'paid' || t.status === 'pending') { // Considera pendente como já recebido para o balanço? Ou só pago? Decidi incluir pendente.
                summary.income += amount;
            }
            if (t.status === 'scheduled') {
                summary.pendingIncome += amount;
            }
        } else if (t.type === 'expense') {
            if (t.status === 'paid' || t.status === 'pending') { // Considera pendente como já gasto para o balanço? Decidi incluir pendente.
                summary.expenses += amount;
            }
             if (t.status === 'scheduled') {
                summary.pendingExpenses += amount;
            }
        }
    });

    summary.balance = summary.income - summary.expenses;
    summary.projectedBalance = summary.balance + summary.pendingIncome - summary.pendingExpenses;

    return summary;
}

// Obter despesas agrupadas por categoria para um conjunto de transações
function getExpensesByCategory(filteredTransactions) {
    const expensesByCategory = {};

    // Inicializa com 0 para todas as categorias de despesa conhecidas
    categories
        .filter(c => c.type === 'expense')
        .forEach(c => {
            expensesByCategory[c.id] = 0;
        });

    // Filtra apenas despesas (pagas ou pendentes) e soma
    filteredTransactions
        .filter(t => t.type === 'expense' && (t.status === 'paid' || t.status === 'pending'))
        .forEach(t => {
            const categoryId = t.category;
            const amount = Number(t.amount) || 0;
            if (expensesByCategory.hasOwnProperty(categoryId)) {
                expensesByCategory[categoryId] += amount;
            } else {
                // Caso raro: transação com categoria deletada. Pode agrupar em "Outros"?
                // expensesByCategory['other_expenses'] = (expensesByCategory['other_expenses'] || 0) + amount;
                console.warn(`Transação encontrada com categoria desconhecida ou deletada: ${categoryId}`);
            }
        });

    return expensesByCategory;
}


// Obter dados para o gráfico de Receitas vs Despesas por Mês
function getIncomeVsExpensesByMonth(numberOfMonths = 12) {
    const labels = [];
    const incomeData = [];
    const expenseData = [];
    const today = new Date();

    for (let i = numberOfMonths - 1; i >= 0; i--) {
        const date = new Date(today.getFullYear(), today.getMonth() - i, 1);
        const targetYear = date.getFullYear();
        const targetMonth = date.getMonth(); // 0-11

        const monthLabel = date.toLocaleDateString('pt-BR', { month: 'short', year: '2-digit' });
        labels.push(monthLabel);

        // Filtra transações para o mês/ano específico
        const monthTransactions = filterTransactions({ year: targetYear, month: targetMonth });
        const summary = getFinanceSummary(monthTransactions);

        incomeData.push(summary.income);
        expenseData.push(summary.expenses);
    }

    return { labels, incomeData, expenseData };
}


// Obter dados para o gráfico de Fluxo de Caixa Mensal para um ano específico
function getCashFlowData(year) {
    const labels = [];
    const balanceData = [];
    const months = moment.monthsShort(); // ['Jan', 'Fev', ...] usando moment.js

    for (let month = 0; month < 12; month++) {
        labels.push(months[month]); // Adiciona nome curto do mês

        // Filtra transações para o mês/ano específico
        const monthTransactions = filterTransactions({ year: year, month: month });
        const summary = getFinanceSummary(monthTransactions);

        balanceData.push(summary.balance);
    }

    return { labels, balanceData };
}


// Obter orçamento atual (para o mês e ano correntes)
async function getCurrentBudget() {
    const today = new Date();
    const currentMonth = today.getMonth(); // 0-11
    const currentYear = today.getFullYear();

    let budget = await getBudgetForMonthAndYear(currentMonth, currentYear);

    // Se não encontrar, tenta criar um novo orçamento vazio para o mês/ano atual
    if (!budget) {
        console.log(`Nenhum orçamento encontrado para ${currentMonth + 1}/${currentYear}. Criando um novo.`);
        const newBudgetData = {
            month: currentMonth,
            year: currentYear,
            categories: categories
                .filter(c => c.type === 'expense') // Apenas categorias de despesa
                .map(c => ({ id: c.id, amount: 0 })) // Cria entradas com orçamento 0
        };

        try {
            const firestoreId = await saveBudgetToFirestore(newBudgetData);
            budget = { ...newBudgetData, firestoreId };
            // Adiciona o novo orçamento ao array local
            budgets.push(budget);
            console.log(`Novo orçamento criado com ID: ${firestoreId}`);
        } catch (error) {
            console.error("Falha ao criar novo orçamento:", error);
            // Retorna um objeto mínimo para evitar erros subsequentes
            return { month: currentMonth, year: currentYear, categories: [] };
        }
    }

    // Garante que todas as categorias de despesa atuais estejam no orçamento (com valor 0 se não estiverem)
    if (budget && budget.categories) {
        categories.filter(c => c.type === 'expense').forEach(cat => {
            if (!budget.categories.some(bc => bc.id === cat.id)) {
                budget.categories.push({ id: cat.id, amount: 0 });
            }
        });
    }


    return budget;
}


// Obter despesas atuais (mês corrente) por categoria
function getCurrentExpensesByCategory() {
    const today = new Date();
    const currentMonth = today.getMonth();
    const currentYear = today.getFullYear();

    // Filtra transações do mês/ano atual
    const currentMonthTransactions = filterTransactions({
        year: currentYear,
        month: currentMonth,
        type: 'expense' // Apenas despesas
    });

    return getExpensesByCategory(currentMonthTransactions);
}


// Calcular progresso de uma meta financeira
function calculateGoalProgress(goal) {
    // Validação básica dos dados da meta
    if (!goal || typeof goal.currentAmount === 'undefined' || typeof goal.targetAmount === 'undefined' || !goal.targetDate) {
        console.error("Dados inválidos para calcular progresso da meta:", goal);
        return {
            progress: 0, daysRemaining: 0, remainingAmount: 0,
            dailySavingsNeeded: 0, monthlySavingsNeeded: 0
        };
    }

    const currentAmount = Number(goal.currentAmount) || 0;
    const targetAmount = Number(goal.targetAmount) || 1; // Evita divisão por zero
    const targetDate = new Date(goal.targetDate);
    const today = new Date();
    // Zera a hora para comparar apenas as datas
    today.setHours(0, 0, 0, 0);
    targetDate.setHours(0, 0, 0, 0);


    let progress = 0;
    if (targetAmount > 0) {
      progress = Math.max(0, Math.min(100, (currentAmount / targetAmount) * 100));
    }


    const remainingAmount = Math.max(0, targetAmount - currentAmount);
    const daysRemaining = Math.max(0, Math.ceil((targetDate - today) / (1000 * 60 * 60 * 24)));

    const dailySavingsNeeded = daysRemaining > 0 ? remainingAmount / daysRemaining : (remainingAmount > 0 ? Infinity : 0);
    const monthlySavingsNeeded = daysRemaining > 0 ? remainingAmount / (daysRemaining / 30.44) : (remainingAmount > 0 ? Infinity : 0); // Média de dias no mês

    return {
        progress: progress,
        daysRemaining: daysRemaining,
        remainingAmount: remainingAmount,
        dailySavingsNeeded: dailySavingsNeeded,
        monthlySavingsNeeded: monthlySavingsNeeded
    };
}


// Formatar número com casas decimais específicas (Ex: para porcentagens)
function formatNumber(num, digits = 1) {
    const number = Number(num);
    if (isNaN(number)) {
        return 'N/A';
    }
    return number.toFixed(digits);
}

// ===== Inicialização de Componentes (Continued) =====

// Inicializar e configurar todos os filtros da aplicação
function initFilters() {
    // Preencher categorias nos selects de filtro relevantes
    updateCategorySelects(); // Preenche #filter-category, #trend-chart-category, #transactions-filter-category

    // Configurar listener para o select de tipo no formulário de transação
    const transactionTypeSelect = document.getElementById('transaction-type');
    if (transactionTypeSelect) {
        transactionTypeSelect.addEventListener('change', updateCategorySelectForForm);
        updateCategorySelectForForm(); // Chama uma vez para popular inicialmente
    } else {
        console.error("Select 'transaction-type' não encontrado no formulário.");
    }

    // Adicionar listeners para os filtros PRINCIPAIS (Header) que atualizam TUDO
    document.getElementById('filter-year')?.addEventListener('change', updateDashboard);
    document.getElementById('filter-month')?.addEventListener('change', updateDashboard);
    document.getElementById('filter-category')?.addEventListener('change', updateDashboard);
    document.getElementById('filter-type')?.addEventListener('change', updateDashboard);

    // Adicionar listeners para os filtros da TAB DE TRANSAÇÕES
    document.getElementById('transactions-filter-year')?.addEventListener('change', updateTransactionsTable);
    document.getElementById('transactions-filter-month')?.addEventListener('change', updateTransactionsTable);
    document.getElementById('transactions-filter-type')?.addEventListener('change', updateTransactionsTable);
    document.getElementById('transactions-filter-category')?.addEventListener('change', updateTransactionsTable);
    document.getElementById('transactions-filter-status')?.addEventListener('change', updateTransactionsTable);
    document.getElementById('transactions-search')?.addEventListener('input', debounce(updateTransactionsTable, 300)); // Debounce para performance

    // Adicionar listeners para os filtros específicos dos GRÁFICOS
    document.getElementById('income-expense-chart-period')?.addEventListener('change', updateIncomeExpenseChart);
    document.getElementById('category-chart-period')?.addEventListener('change', updateCategoryChart);
    document.getElementById('cashflow-chart-year')?.addEventListener('change', updateCashFlowChart);
    document.getElementById('trend-chart-category')?.addEventListener('change', updateTrendChart);

    // Adicionar listeners para os filtros da ANÁLISE MENSAL
    document.getElementById('monthly-analysis-year')?.addEventListener('change', updateMonthlyAnalysis);
    document.getElementById('monthly-analysis-month')?.addEventListener('change', updateMonthlyAnalysis);
    document.getElementById('prev-month')?.addEventListener('click', navigateToPreviousMonth);
    document.getElementById('next-month')?.addEventListener('click', navigateToNextMonth);

    // Adicionar listeners para filtros de RELATÓRIOS
    document.getElementById('report-year')?.addEventListener('change', generateMonthlyReport);
    document.getElementById('report-month')?.addEventListener('change', generateMonthlyReport);
    document.getElementById('analysis-type')?.addEventListener('change', updateAnalysisChart);
    document.getElementById('btn-export-report')?.addEventListener('click', exportMonthlyReport);
}

// Atualizar TODOS os selects de categoria (filtros, gráficos)
function updateCategorySelects() {
    const selectsToUpdate = [
        document.getElementById('filter-category'),
        document.getElementById('transactions-filter-category'),
        document.getElementById('trend-chart-category')
        // Adicionar outros selects de categoria aqui se necessário
    ];

    // Ordena as categorias alfabeticamente por nome para melhor usabilidade
    const sortedCategories = [...categories].sort((a, b) => a.name.localeCompare(b.name));

    selectsToUpdate.forEach(select => {
        if (select) {
            const currentValue = select.value; // Salva o valor atual se houver
            // Limpa opções existentes, mantendo a primeira ("Todas Categorias")
            while (select.options.length > 1) {
                select.remove(1);
            }
            // Adiciona as categorias ordenadas
            sortedCategories.forEach(category => {
                const option = document.createElement('option');
                option.value = category.id; // Usa o ID único da categoria
                option.textContent = `${category.icon} ${category.name}`; // Inclui ícone para fácil identificação
                select.appendChild(option);
            });
             // Restaura o valor anterior se ainda for válido
            if (Array.from(select.options).some(opt => opt.value === currentValue)) {
                select.value = currentValue;
            }
        }
    });
     // Atualiza também o select do formulário, caso esteja aberto
    updateCategorySelectForForm();
}


// Atualizar o select de categorias APENAS no formulário de transação
function updateCategorySelectForForm() {
    const transactionTypeSelect = document.getElementById('transaction-type');
    const transactionCategorySelect = document.getElementById('transaction-category');

    if (!transactionTypeSelect || !transactionCategorySelect) return; // Sai se os elementos não existirem

    const selectedType = transactionTypeSelect.value;
    const currentValue = transactionCategorySelect.value; // Salva seleção atual

    // Limpa opções existentes
    transactionCategorySelect.innerHTML = '<option value="">Selecione...</option>'; // Adiciona opção padrão

    // Filtra e ordena categorias pelo tipo selecionado
    const relevantCategories = categories
        .filter(c => c.type === selectedType)
        .sort((a, b) => a.name.localeCompare(b.name));

    // Adiciona categorias filtradas ao select
    if (relevantCategories.length > 0) {
        relevantCategories.forEach(category => {
            const option = document.createElement('option');
            option.value = category.id;
            option.textContent = `${category.icon} ${category.name}`;
            transactionCategorySelect.appendChild(option);
        });
         // Restaura o valor anterior se ainda for válido
         if (relevantCategories.some(cat => cat.id === currentValue)) {
             transactionCategorySelect.value = currentValue;
         }
    } else {
        // Adiciona mensagem se não houver categorias para o tipo
        const option = document.createElement('option');
        option.value = "";
        option.textContent = "Nenhuma categoria disponível";
        option.disabled = true;
        transactionCategorySelect.appendChild(option);
    }
}


// Inicializar todos os modais e seus listeners
function initModals() {
    // ----- Modal de Transação -----
    document.getElementById('btn-new-transaction')?.addEventListener('click', () => openTransactionModal());
    document.getElementById('transaction-modal-close')?.addEventListener('click', () => closeModal(transactionModal));
    document.getElementById('transaction-modal-cancel')?.addEventListener('click', () => closeModal(transactionModal));
    document.getElementById('transaction-modal-save')?.addEventListener('click', saveTransaction);
    document.getElementById('transaction-recurring')?.addEventListener('change', (e) => {
        document.getElementById('recurring-options').style.display = e.target.checked ? 'block' : 'none';
    });
    // Botões Adicionar Receita/Despesa na Análise Mensal
    document.getElementById('btn-add-income')?.addEventListener('click', () => openTransactionModal(null, 'income'));
    document.getElementById('btn-add-expense')?.addEventListener('click', () => openTransactionModal(null, 'expense'));


    // ----- Modal de Orçamento -----
    document.getElementById('btn-edit-budget')?.addEventListener('click', openBudgetModal);
    document.getElementById('budget-modal-close')?.addEventListener('click', () => closeModal(budgetModal));
    document.getElementById('budget-modal-cancel')?.addEventListener('click', () => closeModal(budgetModal));
    document.getElementById('budget-modal-save')?.addEventListener('click', saveBudget);
    // Listener para mudança de mês/ano no modal de orçamento para recarregar os dados
    document.getElementById('budget-year')?.addEventListener('change', populateBudgetModalCategories);
    document.getElementById('budget-month')?.addEventListener('change', populateBudgetModalCategories);


    // ----- Modal de Metas -----
    document.getElementById('btn-add-goal')?.addEventListener('click', () => openGoalModal());
    document.getElementById('goal-modal-close')?.addEventListener('click', () => closeModal(goalModal));
    document.getElementById('goal-modal-cancel')?.addEventListener('click', () => closeModal(goalModal));
    document.getElementById('goal-modal-save')?.addEventListener('click', saveGoal);


    // ----- Modal de Categorias -----
    document.getElementById('btn-add-category')?.addEventListener('click', () => openCategoryModal());
    document.getElementById('category-modal-close')?.addEventListener('click', () => closeModal(categoryModal));
    document.getElementById('category-modal-cancel')?.addEventListener('click', () => closeModal(categoryModal));
    document.getElementById('category-modal-save')?.addEventListener('click', saveCategory);
    initColorGrid(); // Inicializa a grade de cores
    initIconGrid(); // Inicializa a grade de ícones


    // ----- Modal de Detalhes da Transação -----
    document.getElementById('transaction-details-modal-close')?.addEventListener('click', () => closeModal(transactionDetailsModal));
    // Os botões Edit e Delete são configurados dinamicamente em showTransactionDetails


    // ----- Modal de Confirmação -----
    document.getElementById('confirm-modal-close')?.addEventListener('click', () => closeModal(confirmModal));
    document.getElementById('confirm-modal-cancel')?.addEventListener('click', () => closeModal(confirmModal));
    // O botão Confirmar é configurado dinamicamente onde for necessário

    // Fechar modais clicando fora do conteúdo
    const allModals = document.querySelectorAll('.modal');
    allModals.forEach(modal => {
        modal.addEventListener('click', (event) => {
            // Verifica se o clique foi no fundo (próprio modal) e não no conteúdo
            if (event.target === modal) {
                closeModal(modal);
            }
        });
    });
}


// Inicializar a grade de cores para seleção de categoria
function initColorGrid() {
    const colorGrid = document.getElementById('color-grid');
    if (!colorGrid) return;
    colorGrid.innerHTML = ''; // Limpa antes de popular

    AVAILABLE_COLORS.forEach(color => {
        const colorItem = document.createElement('div');
        colorItem.className = 'color-item';
        colorItem.style.backgroundColor = color;
        colorItem.dataset.color = color;
        colorItem.setAttribute('role', 'button');
        colorItem.setAttribute('tabindex', '0'); // Torna focável
        colorItem.setAttribute('aria-label', `Selecionar cor ${color}`);

        colorItem.addEventListener('click', () => selectColorOrIcon(colorItem, '.color-item'));
        colorItem.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                selectColorOrIcon(colorItem, '.color-item');
            }
        });
        colorGrid.appendChild(colorItem);
    });
}

// Inicializar a grade de ícones para seleção de categoria
function initIconGrid() {
    const iconGrid = document.getElementById('icon-grid');
     if (!iconGrid) return;
    iconGrid.innerHTML = ''; // Limpa antes de popular

    AVAILABLE_ICONS.forEach(icon => {
        const iconItem = document.createElement('div');
        iconItem.className = 'icon-item';
        iconItem.textContent = icon; // Usa textContent para emojis
        iconItem.dataset.icon = icon;
        iconItem.setAttribute('role', 'button');
        iconItem.setAttribute('tabindex', '0'); // Torna focável
         iconItem.setAttribute('aria-label', `Selecionar ícone ${icon}`);

        iconItem.addEventListener('click', () => selectColorOrIcon(iconItem, '.icon-item'));
        iconItem.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                selectColorOrIcon(iconItem, '.icon-item');
            }
        });
        iconGrid.appendChild(iconItem);
    });
}

// Função auxiliar para selecionar cor ou ícone
function selectColorOrIcon(itemElement, itemSelector) {
     // Remove seleção de todos os itens do mesmo tipo
    document.querySelectorAll(`${itemSelector}.selected`).forEach(item => {
        item.classList.remove('selected');
        item.removeAttribute('aria-pressed');
    });
    // Adiciona seleção ao item clicado/selecionado
    itemElement.classList.add('selected');
    itemElement.setAttribute('aria-pressed', 'true');
}

// Abrir modal genérico
function openModal(modalElement) {
    if (modalElement) {
        modalElement.classList.add('active');
        // Foca no primeiro elemento interativo dentro do modal
        const focusable = modalElement.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
        if (focusable) {
            focusable.focus();
        }
    } else {
         console.error("Tentativa de abrir um modal nulo.");
    }
}

// Fechar modal genérico
function closeModal(modalElement) {
    if (modalElement) {
         modalElement.classList.remove('active');
          // Devolve o foco para o botão que abriu o modal, se possível (melhora a acessibilidade)
          // Esta parte pode ser mais complexa de implementar de forma genérica
    } else {
        console.error("Tentativa de fechar um modal nulo.");
    }
}

// Abrir modal de transação (com pré-preenchimento opcional)
function openTransactionModal(transaction = null, defaultType = null) {
    const modal = document.getElementById('transaction-modal');
    const form = document.getElementById('transaction-form');
    const modalTitle = document.getElementById('transaction-modal-title');
    if (!modal || !form || !modalTitle) return;

    form.reset(); // Limpa o formulário
    document.getElementById('transaction-id').value = ''; // Limpa ID oculto
    document.getElementById('recurring-options').style.display = 'none'; // Esconde opções recorrentes

    // Define data atual como padrão para novas transações
    const today = new Date();
    document.getElementById('transaction-date').value = formatDateForInput(today.toISOString());

    // Define tipo padrão se fornecido (ex: botão "+ Receita")
    if (defaultType) {
        document.getElementById('transaction-type').value = defaultType;
    }

    updateCategorySelectForForm(); // Atualiza categorias com base no tipo

    if (transaction) {
        // MODO EDIÇÃO
        modalTitle.textContent = 'Editar Transação';
        document.getElementById('transaction-id').value = transaction.id || ''; // Usa ID existente
         // Preenche todos os campos do formulário
        document.getElementById('transaction-type').value = transaction.type;
        document.getElementById('transaction-date').value = formatDateForInput(transaction.date);
        document.getElementById('transaction-description').value = transaction.description || '';
        document.getElementById('transaction-amount').value = transaction.amount || '';
        document.getElementById('transaction-status').value = transaction.status || 'paid';

        updateCategorySelectForForm(); // Atualiza categorias DEPOIS de definir o tipo
        setTimeout(() => { // Timeout para garantir que o select foi populado
             document.getElementById('transaction-category').value = transaction.category || '';
        }, 0);


        document.getElementById('transaction-payment-method').value = transaction.paymentMethod || '';
        document.getElementById('transaction-notes').value = transaction.notes || '';

        // Lida com recorrência
        const isRecurring = !!transaction.recurring; // Converte para booleano
        document.getElementById('transaction-recurring').checked = isRecurring;
        document.getElementById('recurring-options').style.display = isRecurring ? 'block' : 'none';
        if (isRecurring) {
            document.getElementById('transaction-frequency').value = transaction.frequency || 'monthly';
            document.getElementById('transaction-end-date').value = transaction.endDate ? formatDateForInput(transaction.endDate) : '';
        }

    } else {
        // MODO CRIAÇÃO
        modalTitle.textContent = 'Nova Transação';
        // O tipo já pode ter sido definido por defaultType
    }

    openModal(modal);
}

// Salvar transação (Criação ou Edição)
async function saveTransaction() {
    const form = document.getElementById('transaction-form');
    const idInput = document.getElementById('transaction-id');
    const isEditing = !!idInput.value; // Verifica se estamos editando (tem ID)
    const transactionId = isEditing ? idInput.value : uuid.v4(); // Gera novo ID se for criação

    try {
        const transactionData = {
            id: transactionId, // ID único (UUID)
            type: document.getElementById('transaction-type').value,
            date: document.getElementById('transaction-date').value,
            description: document.getElementById('transaction-description').value.trim(),
            amount: parseFloat(document.getElementById('transaction-amount').value),
            category: document.getElementById('transaction-category').value,
            status: document.getElementById('transaction-status').value,
            paymentMethod: document.getElementById('transaction-payment-method').value || null, // Usa null se vazio
            notes: document.getElementById('transaction-notes').value.trim() || null, // Usa null se vazio
            recurring: document.getElementById('transaction-recurring').checked
        };

        // Validação
        if (!transactionData.date || !transactionData.description || isNaN(transactionData.amount) || transactionData.amount <= 0 || !transactionData.category) {
            showAlert('Preencha todos os campos obrigatórios: Data, Descrição, Valor (>0) e Categoria.', 'warning');
            return;
        }

        // Adiciona campos de recorrência se marcado
        if (transactionData.recurring) {
            transactionData.frequency = document.getElementById('transaction-frequency').value;
            const endDateValue = document.getElementById('transaction-end-date').value;
            transactionData.endDate = endDateValue || null; // Usa null se vazio
        } else {
             // Garante que campos de recorrência sejam removidos se não for recorrente
             delete transactionData.frequency;
             delete transactionData.endDate;
        }

        // Prepara para salvar no Firestore
        let firestoreIdToSave = null;
         if (isEditing) {
            const existingTransaction = transactions.find(t => t.id === transactionId);
            if (existingTransaction) {
                 transactionData.firestoreId = existingTransaction.firestoreId; // Pega o ID do Firestore para atualização
            } else {
                 console.error(`Erro: Transação para editar (ID: ${transactionId}) não encontrada no array local.`);
                 showAlert('Erro ao encontrar transação para editar.', 'danger');
                 return;
            }
        }

        // Salva no Firestore (a função saveTransactionToFirestore lida com create/update)
        const savedFirestoreId = await saveTransactionToFirestore(transactionData);

        // Atualiza o array local
        transactionData.firestoreId = savedFirestoreId; // Garante que temos o ID do Firestore correto
        if (isEditing) {
            const index = transactions.findIndex(t => t.id === transactionId);
            if (index !== -1) {
                transactions[index] = transactionData;
            }
        } else {
            transactions.push(transactionData);
        }

        showAlert(`Transação ${isEditing ? 'atualizada' : 'adicionada'} com sucesso!`, 'success');
        closeModal(transactionModal);
        updateDashboard(); // Atualiza toda a interface

    } catch (error) {
        console.error('Erro ao salvar transação:', error);
        // A função saveTransactionToFirestore já mostra um alerta de erro
    }
}


// Abrir modal de edição de orçamento
async function openBudgetModal() {
    const modal = document.getElementById('budget-modal');
    if (!modal) return;

    // Garante que as categorias estejam carregadas
    if (categories.length === 0) {
        showAlert('Categorias ainda estão carregando. Tente novamente em breve.', 'info');
        return;
    }

    // Popula os selects de ano e mês do modal (se ainda não estiverem)
    // (Assumindo que populateYearSelects e populateMonthSelects já rodaram)
    const budgetYearSelect = document.getElementById('budget-year');
    const budgetMonthSelect = document.getElementById('budget-month');

    // Define o mês/ano atual como padrão inicial ou usa o filtro principal se definido
    const filterYear = document.getElementById('filter-year').value;
    const filterMonth = document.getElementById('filter-month').value;
    const currentYear = new Date().getFullYear();
    const currentMonth = new Date().getMonth();

    budgetYearSelect.value = (filterYear && filterYear !== 'all') ? filterYear : currentYear;
    budgetMonthSelect.value = (filterMonth && filterMonth !== 'all') ? filterMonth : currentMonth;

    // Popula as categorias no modal com base no mês/ano selecionado
    await populateBudgetModalCategories();

    openModal(modal);
}

// Popula os campos de categoria no modal de orçamento
async function populateBudgetModalCategories() {
    const budgetYear = parseInt(document.getElementById('budget-year').value);
    const budgetMonth = parseInt(document.getElementById('budget-month').value);
    const categoriesContainer = document.getElementById('budget-categories-container');
    if (!categoriesContainer || isNaN(budgetYear) || isNaN(budgetMonth)) return;

    categoriesContainer.innerHTML = '<div style="text-align: center; padding: 1rem; color: var(--text-secondary);">Carregando orçamento...</div>'; // Feedback

    try {
        const budget = await getBudgetForMonthAndYear(budgetMonth, budgetYear);
        const expenseCategories = categories.filter(c => c.type === 'expense').sort((a, b) => a.name.localeCompare(b.name)); // Apenas despesas, ordenadas

        categoriesContainer.innerHTML = ''; // Limpa o container

        if (expenseCategories.length === 0) {
             categoriesContainer.innerHTML = '<div style="text-align: center; padding: 1rem; color: var(--text-secondary);">Nenhuma categoria de despesa encontrada.</div>';
             return;
        }

        expenseCategories.forEach(category => {
            let categoryBudgetValue = 0;
            // Encontra o valor orçado para esta categoria, se existir
            if (budget && budget.categories) {
                const budgetEntry = budget.categories.find(bc => bc.id === category.id);
                if (budgetEntry) {
                    categoryBudgetValue = Number(budgetEntry.amount) || 0;
                }
            }

            // Cria o HTML para o input da categoria
            const categoryElement = document.createElement('div');
            categoryElement.className = 'form-group';
            categoryElement.innerHTML = `
                <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.5rem;">
                    <div style="width: 1.5rem; height: 1.5rem; border-radius: 50%; background-color: ${category.color}; flex-shrink: 0; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.9rem;">${category.icon}</div>
                    <label for="budget-category-${category.id}" style="font-weight: 500;">${category.name}</label>
                </div>
                <input type="number" min="0" step="0.01" class="form-control budget-category-input"
                       id="budget-category-${category.id}" name="budget_category_${category.id}"
                       value="${categoryBudgetValue.toFixed(2)}" data-category-id="${category.id}" placeholder="0,00">
            `;
            categoriesContainer.appendChild(categoryElement);
        });

    } catch (error) {
        console.error("Erro ao popular categorias do orçamento:", error);
        categoriesContainer.innerHTML = '<div style="text-align: center; padding: 1rem; color: var(--danger);">Erro ao carregar categorias.</div>';
    }
}


// Salvar orçamento mensal
async function saveBudget() {
    const year = parseInt(document.getElementById('budget-year').value);
    const month = parseInt(document.getElementById('budget-month').value);
    if (isNaN(year) || isNaN(month)) {
        showAlert('Selecione um ano e mês válidos.', 'warning');
        return;
    }

    const budgetCategoriesData = [];
    const inputs = document.querySelectorAll('.budget-category-input');
    inputs.forEach(input => {
        const categoryId = input.dataset.categoryId;
        const amount = parseFloat(input.value) || 0; // Converte para número, padrão 0
        budgetCategoriesData.push({ id: categoryId, amount: amount });
    });

    const budgetData = {
        year,
        month,
        categories: budgetCategoriesData
    };

     // Tenta encontrar o orçamento existente no array local para obter o firestoreId
    const existingBudget = budgets.find(b => b.year === year && b.month === month);
    if (existingBudget) {
        budgetData.firestoreId = existingBudget.firestoreId;
    }


    try {
        const savedFirestoreId = await saveBudgetToFirestore(budgetData);
        budgetData.firestoreId = savedFirestoreId; // Garante o ID correto

        // Atualiza o array local 'budgets'
        const index = budgets.findIndex(b => b.year === year && b.month === month);
        if (index !== -1) {
            budgets[index] = budgetData; // Atualiza existente
        } else {
            budgets.push(budgetData); // Adiciona novo
        }


        showAlert('Orçamento salvo com sucesso!', 'success');
        closeModal(budgetModal);
        // Atualiza a UI se a aba de orçamento estiver ativa
        if (document.getElementById('tab-budget')?.classList.contains('active')) {
            updateBudgetTab();
        }
    } catch (error) {
        console.error('Erro ao salvar orçamento:', error);
        // saveBudgetToFirestore já mostra alerta
    }
}


// Abrir modal de meta (criação ou edição)
function openGoalModal(goal = null) {
     const modal = document.getElementById('goal-modal');
     const form = document.getElementById('goal-form');
     const modalTitle = document.getElementById('goal-modal-title');
     if (!modal || !form || !modalTitle) return;

     form.reset(); // Limpa formulário
     document.getElementById('goal-id').value = ''; // Limpa ID oculto

     // Define data alvo padrão (fim do ano atual) para novas metas
     if (!goal) {
        const today = new Date();
        const endOfYear = new Date(today.getFullYear(), 11, 31); // 31 de Dezembro
        document.getElementById('goal-date').value = formatDateForInput(endOfYear.toISOString());
     }


    if (goal) {
        // MODO EDIÇÃO
        modalTitle.textContent = 'Editar Meta';
        document.getElementById('goal-id').value = goal.id || '';
        document.getElementById('goal-name').value = goal.name || '';
        document.getElementById('goal-target').value = goal.targetAmount || '';
        document.getElementById('goal-current').value = goal.currentAmount || 0; // Padrão 0
        document.getElementById('goal-date').value = goal.targetDate ? formatDateForInput(goal.targetDate) : '';
        document.getElementById('goal-category').value = goal.category || 'savings'; // Padrão 'savings'
        document.getElementById('goal-notes').value = goal.notes || '';
    } else {
        // MODO CRIAÇÃO
        modalTitle.textContent = 'Nova Meta';
         document.getElementById('goal-current').value = 0; // Garante 0 para novas metas
    }

    openModal(modal);
}


// Salvar meta (Criação ou Edição)
async function saveGoal() {
    const idInput = document.getElementById('goal-id');
    const isEditing = !!idInput.value;
    const goalId = isEditing ? idInput.value : uuid.v4();

    try {
        const goalData = {
            id: goalId,
            name: document.getElementById('goal-name').value.trim(),
            targetAmount: parseFloat(document.getElementById('goal-target').value),
            currentAmount: parseFloat(document.getElementById('goal-current').value) || 0, // Garante 0 se vazio/inválido
            targetDate: document.getElementById('goal-date').value,
            category: document.getElementById('goal-category').value,
            notes: document.getElementById('goal-notes').value.trim() || null
        };

        // Validação
        if (!goalData.name || isNaN(goalData.targetAmount) || goalData.targetAmount <= 0 || isNaN(goalData.currentAmount) || goalData.currentAmount < 0 || !goalData.targetDate) {
            showAlert('Preencha os campos obrigatórios: Nome, Valor Alvo (>0), Valor Atual (>=0) e Data Alvo.', 'warning');
            return;
        }
         if (goalData.currentAmount > goalData.targetAmount) {
             showAlert('O Valor Atual não pode ser maior que o Valor Alvo.', 'warning');
             return;
         }

        // Pega o firestoreId se estiver editando
        if (isEditing) {
            const existingGoal = goals.find(g => g.id === goalId);
            if (existingGoal) {
                 goalData.firestoreId = existingGoal.firestoreId;
            } else {
                console.error(`Erro: Meta para editar (ID: ${goalId}) não encontrada no array local.`);
                showAlert('Erro ao encontrar meta para editar.', 'danger');
                return;
            }
        }

        // Salva no Firestore
        const savedFirestoreId = await saveGoalToFirestore(goalData);
        goalData.firestoreId = savedFirestoreId; // Garante ID correto

        // Atualiza array local
        if (isEditing) {
            const index = goals.findIndex(g => g.id === goalId);
            if (index !== -1) goals[index] = goalData;
        } else {
            goals.push(goalData);
        }

        showAlert(`Meta ${isEditing ? 'atualizada' : 'adicionada'} com sucesso!`, 'success');
        closeModal(goalModal);
        // Atualiza a UI se a aba de metas estiver ativa
        if (document.getElementById('tab-goals')?.classList.contains('active')) {
             updateGoalsTab();
        }

    } catch (error) {
        console.error("Erro ao salvar meta:", error);
         // saveGoalToFirestore já mostra alerta
    }
}


// Abrir modal de categoria (criação ou edição)
function openCategoryModal(category = null) {
    const modal = document.getElementById('category-modal');
    const form = document.getElementById('category-form');
    const modalTitle = document.getElementById('category-modal-title');
    if (!modal || !form || !modalTitle) return;

    form.reset(); // Limpa formulário
    document.getElementById('category-id').value = ''; // Limpa ID oculto

    // Remove seleção de cor/ícone anterior
    document.querySelectorAll('.color-item.selected, .icon-item.selected').forEach(item => {
        item.classList.remove('selected');
         item.removeAttribute('aria-pressed');
    });

    if (category) {
        // MODO EDIÇÃO
        modalTitle.textContent = 'Editar Categoria';
        document.getElementById('category-id').value = category.id || '';
        document.getElementById('category-name').value = category.name || '';
        document.getElementById('category-type').value = category.type || 'expense';

        // Seleciona cor e ícone existentes
        const colorItem = document.querySelector(`.color-item[data-color="${category.color}"]`);
        if (colorItem) {
             colorItem.classList.add('selected');
             colorItem.setAttribute('aria-pressed', 'true');
        }
        const iconItem = document.querySelector(`.icon-item[data-icon="${category.icon}"]`);
        if (iconItem) {
            iconItem.classList.add('selected');
             iconItem.setAttribute('aria-pressed', 'true');
        }
    } else {
        // MODO CRIAÇÃO
        modalTitle.textContent = 'Nova Categoria';
        // Seleciona a primeira cor e ícone como padrão
        const firstColor = document.querySelector('.color-item');
        if (firstColor) {
            firstColor.classList.add('selected');
             firstColor.setAttribute('aria-pressed', 'true');
        }
        const firstIcon = document.querySelector('.icon-item');
        if (firstIcon) {
            firstIcon.classList.add('selected');
             firstIcon.setAttribute('aria-pressed', 'true');
        }
    }

    openModal(modal);
}


// Salvar categoria (Criação ou Edição)
async function saveCategory() {
    const idInput = document.getElementById('category-id');
    const isEditing = !!idInput.value;
    const categoryId = isEditing ? idInput.value : uuid.v4();

    try {
        const selectedColorElement = document.querySelector('.color-item.selected');
        const selectedIconElement = document.querySelector('.icon-item.selected');

        const categoryData = {
            id: categoryId,
            name: document.getElementById('category-name').value.trim(),
            type: document.getElementById('category-type').value,
            color: selectedColorElement ? selectedColorElement.dataset.color : null,
            icon: selectedIconElement ? selectedIconElement.dataset.icon : null
        };

        // Validação
        if (!categoryData.name || !categoryData.type || !categoryData.color || !categoryData.icon) {
            showAlert('Preencha todos os campos: Nome, Tipo, Cor e Ícone.', 'warning');
            return;
        }

        // Pega o firestoreId se estiver editando
        if (isEditing) {
             const existingCategory = categories.find(c => c.id === categoryId);
             if (existingCategory) {
                 categoryData.firestoreId = existingCategory.firestoreId;
             } else {
                 console.error(`Erro: Categoria para editar (ID: ${categoryId}) não encontrada no array local.`);
                 showAlert('Erro ao encontrar categoria para editar.', 'danger');
                 return;
             }
        }

        // Salva no Firestore
        const savedFirestoreId = await saveCategoryToFirestore(categoryData);
        categoryData.firestoreId = savedFirestoreId; // Garante ID correto

        // Atualiza array local
        if (isEditing) {
            const index = categories.findIndex(c => c.id === categoryId);
            if (index !== -1) categories[index] = categoryData;
        } else {
            categories.push(categoryData);
        }

        showAlert(`Categoria ${isEditing ? 'atualizada' : 'adicionada'} com sucesso!`, 'success');
        closeModal(categoryModal);
        updateCategorySelects(); // Atualiza todos os selects que usam categorias
        // Atualiza a UI se a aba de categorias estiver ativa
        if (document.getElementById('tab-categories')?.classList.contains('active')) {
            updateCategoriesTab();
        }

    } catch (error) {
        console.error("Erro ao salvar categoria:", error);
        // saveCategoryToFirestore já mostra alerta
    }
}

// Função Debounce simples
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// ===== Inicialização e Atualização de Gráficos (Continued) =====

// Variáveis globais para as instâncias dos gráficos
let incomeExpenseChart = null;
let categoryChart = null;
let cashflowChart = null;
let fixedVariableChart = null;
let trendChart = null;
let budgetChart = null;
let savingsProjectionChart = null;
let analysisChart = null;
let monthlyCategoryChart = null;
let monthlyDailyChart = null;
let reportPieChart = null; // Gráfico do relatório

// Destruir instância de gráfico existente se houver
function destroyChart(chartInstance) {
    if (chartInstance) {
        chartInstance.destroy();
    }
    return null; // Retorna null para reatribuir à variável
}

// Configurações comuns para todos os gráficos Chart.js
function getChartCommonOptions() {
    const rootElement = document.documentElement;
    const isDark = rootElement.getAttribute('data-theme') === 'dark';
    const textColor = isDark ? 'var(--text)' : 'var(--text)'; // Usa variáveis CSS
    const gridColor = isDark ? 'var(--chart-grid)' : 'var(--chart-grid)';
    const tooltipBgColor = isDark ? 'rgba(44, 44, 46, 0.9)' : 'rgba(255, 255, 255, 0.9)'; // Fundo do tooltip mais adequado
    const tooltipBorderColor = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';

    return {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
            legend: {
                position: 'bottom', // Posição mais comum e que economiza espaço vertical
                align: 'center',
                labels: {
                    color: textColor,
                    boxWidth: 12,
                    padding: 20, // Mais espaço
                    font: {
                        family: 'var(--font-sans)' // Usa variável CSS
                    },
                    usePointStyle: true,
                    pointStyle: 'circle'
                }
            },
            tooltip: {
                enabled: true,
                backgroundColor: tooltipBgColor,
                titleColor: textColor,
                bodyColor: textColor,
                borderColor: tooltipBorderColor,
                borderWidth: 1,
                cornerRadius: 8, // Raio de borda
                padding: 10, // Padding interno
                boxPadding: 4, // Padding da caixa de cor
                usePointStyle: true,
                titleFont: { weight: 'bold', family: 'var(--font-sans)' },
                bodyFont: { family: 'var(--font-sans)' },
                callbacks: {
                    label: function(context) {
                        let label = context.dataset.label || context.label || '';
                        if (label) {
                            label += ': ';
                        }
                        let value = context.parsed.y; // Para gráficos de barras/linha
                        if (typeof value !== 'number') {
                             value = context.parsed; // Para gráficos de pizza/doughnut
                        }
                        if (typeof value === 'number') {
                            label += formatCurrency(value);

                            // Adiciona porcentagem para Pizza/Doughnut
                            if (context.chart.config.type === 'pie' || context.chart.config.type === 'doughnut') {
                                const total = context.dataset.data.reduce((acc, data) => acc + data, 0);
                                if (total > 0) {
                                     const percentage = ((value / total) * 100).toFixed(1);
                                     label += ` (${percentage}%)`;
                                }
                            }
                        } else {
                             label += 'N/A';
                        }
                        return label;
                    }
                }
            }
        },
        scales: { // Configurações padrão para eixos X e Y (aplicável a barras/linhas)
            x: {
                grid: {
                    color: gridColor,
                    drawOnChartArea: false // Linhas de grade verticais menos intrusivas
                },
                ticks: {
                    color: textColor,
                    font: { family: 'var(--font-sans)' }
                },
                border: { // Linha do eixo
                  color: gridColor
                }
            },
            y: {
                beginAtZero: true, // Garante que o eixo Y comece em 0
                grid: {
                    color: gridColor
                },
                ticks: {
                    color: textColor,
                    font: { family: 'var(--font-sans)' },
                    callback: function(value) { // Formata os ticks do eixo Y como moeda
                         // Mostra valores mais concisos para números grandes
                         if (Math.abs(value) >= 1000000) return formatCurrency(value / 1000000) + 'M';
                         if (Math.abs(value) >= 1000) return formatCurrency(value / 1000) + 'k';
                         return formatCurrency(value);
                    }
                },
                 border: { // Linha do eixo
                   color: gridColor,
                   dash: [2, 4], // Linha tracejada sutil
                 }
            }
        },
        // Desabilita animações para atualizações mais rápidas, exceto na primeira renderização
        // animation: false // Pode ser reativado se desejado
    };
}

// Inicializar/Atualizar gráfico de receitas x despesas
function updateIncomeExpenseChart() {
    const ctx = document.getElementById('income-expense-chart')?.getContext('2d');
    if (!ctx) return; // Sai se o canvas não existir

    incomeExpenseChart = destroyChart(incomeExpenseChart); // Destroi o anterior

    const periodSelect = document.getElementById('income-expense-chart-period');
    const months = parseInt(periodSelect?.value || '12'); // Padrão 12 meses
    const { labels, incomeData, expenseData } = getIncomeVsExpensesByMonth(months);
    const commonOptions = getChartCommonOptions();

    incomeExpenseChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'Receitas',
                    data: incomeData,
                    backgroundColor: 'var(--success)',
                    borderColor: 'var(--success)',
                    borderWidth: 1,
                    borderRadius: 4, // Bordas arredondadas
                    barPercentage: 0.7, // Largura das barras
                    categoryPercentage: 0.6 // Espaçamento entre grupos
                },
                {
                    label: 'Despesas',
                    data: expenseData,
                    backgroundColor: 'var(--danger)',
                    borderColor: 'var(--danger)',
                    borderWidth: 1,
                    borderRadius: 4,
                    barPercentage: 0.7,
                    categoryPercentage: 0.6
                }
            ]
        },
        options: {
            ...commonOptions,
            plugins: {
                 ...commonOptions.plugins,
                 title: { display: false } // Já temos título no card
            },
            scales: { // Garante que o eixo Y seja formatado como moeda
                 ...commonOptions.scales,
                 y: { ...commonOptions.scales.y } // Herda formatação de moeda
            }
        }
    });
}

// Inicializar/Atualizar gráfico de despesas por categoria
function updateCategoryChart() {
    const ctx = document.getElementById('category-chart')?.getContext('2d');
    if (!ctx) return;

    categoryChart = destroyChart(categoryChart);

    const periodSelect = document.getElementById('category-chart-period');
    const period = periodSelect?.value || 'current'; // Padrão mês atual
    const today = new Date();
    const currentYear = today.getFullYear();
    const currentMonth = today.getMonth();
    let filteredTransactions;

    switch(period) {
        case 'last':
            const lastMonthDate = new Date(currentYear, currentMonth - 1, 1);
            filteredTransactions = filterTransactions({ year: lastMonthDate.getFullYear(), month: lastMonthDate.getMonth(), type: 'expense' });
            break;
        case 'average': // Média dos últimos 12 meses? Ou do ano atual? Vamos usar ano atual.
            filteredTransactions = filterTransactions({ year: currentYear, type: 'expense' });
            break;
        case 'current':
        default:
            filteredTransactions = filterTransactions({ year: currentYear, month: currentMonth, type: 'expense' });
            break;
    }

    const expensesByCategory = getExpensesByCategory(filteredTransactions);
    const commonOptions = getChartCommonOptions();

    // Preparar dados, mostrando as 6 maiores e agrupando o resto em "Outras"
    const sortedEntries = Object.entries(expensesByCategory)
        .filter(([, amount]) => amount > 0)
        .sort(([, a], [, b]) => b - a);

    const topEntries = sortedEntries.slice(0, 6);
    const otherAmount = sortedEntries.slice(6).reduce((sum, [, amount]) => sum + amount, 0);

    const labels = topEntries.map(([categoryId]) => categories.find(c => c.id === categoryId)?.name || 'Desconhecida');
    const data = topEntries.map(([, amount]) => amount);
    const backgroundColors = topEntries.map(([categoryId]) => categories.find(c => c.id === categoryId)?.color || '#cccccc');

    if (otherAmount > 0) {
        labels.push('Outras');
        data.push(otherAmount);
        backgroundColors.push('var(--text-secondary)'); // Cor para "Outras"
    }

    categoryChart = new Chart(ctx, {
        type: 'doughnut',
        data: {
            labels: labels,
            datasets: [{
                data: data,
                backgroundColor: backgroundColors,
                borderColor: 'var(--card-bg)', // Usa variável CSS
                borderWidth: 2,
                hoverOffset: 8 // Efeito sutil ao passar o mouse
            }]
        },
        options: {
            ...commonOptions,
            cutout: '70%', // Cria o efeito "doughnut"
            plugins: {
                ...commonOptions.plugins,
                legend: { ...commonOptions.plugins.legend, position: 'right' }, // Legenda à direita para doughnuts/pies
                title: { display: false }
            }
            // Remove a configuração de escalas, pois não se aplica a doughnut/pie
        }
    });
    // Remove scales explicitamente se getChartCommonOptions as adicionou
    delete categoryChart.options.scales;
}


// Inicializar/Atualizar gráfico de fluxo de caixa
function updateCashFlowChart() {
    const ctx = document.getElementById('cashflow-chart')?.getContext('2d');
    if (!ctx) return;

    cashflowChart = destroyChart(cashflowChart);

    const yearSelect = document.getElementById('cashflow-chart-year');
    const year = parseInt(yearSelect?.value || new Date().getFullYear());
    const { labels, balanceData } = getCashFlowData(year);
    const commonOptions = getChartCommonOptions();

    // Cores baseadas no valor (positivo/negativo)
    const backgroundColors = balanceData.map(value => value >= 0 ? 'var(--success)' : 'var(--danger)');

    cashflowChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels, // Jan, Fev, ...
            datasets: [{
                label: 'Saldo Mensal',
                data: balanceData,
                backgroundColor: backgroundColors,
                borderColor: backgroundColors, // Mesma cor para borda
                borderWidth: 1,
                borderRadius: 4,
                barPercentage: 0.7,
                categoryPercentage: 0.8
            }]
        },
        options: {
            ...commonOptions,
            plugins: {
                ...commonOptions.plugins,
                title: { display: false },
                legend: { display: false } // Não precisa de legenda para uma única série
            },
            scales: {
                 ...commonOptions.scales,
                 y: { ...commonOptions.scales.y } // Garante formatação de moeda
            }
        }
    });
}


// Inicializar/Atualizar gráfico de gastos fixos vs variáveis
function updateFixedVariableChart() {
    const ctx = document.getElementById('fixed-variable-chart')?.getContext('2d');
    if (!ctx) return;

    fixedVariableChart = destroyChart(fixedVariableChart);

    const today = new Date();
    const currentMonthExpenses = filterTransactions({
        year: today.getFullYear(),
        month: today.getMonth(),
        type: 'expense'
    });

    // Considera 'recurring' como fixo, o resto como variável
    const fixedExpenses = currentMonthExpenses
        .filter(t => t.recurring && (t.status === 'paid' || t.status === 'pending'))
        .reduce((sum, t) => sum + (Number(t.amount) || 0), 0);
    const variableExpenses = currentMonthExpenses
         .filter(t => !t.recurring && (t.status === 'paid' || t.status === 'pending'))
        .reduce((sum, t) => sum + (Number(t.amount) || 0), 0);

     const commonOptions = getChartCommonOptions();

     // Cores distintas para fixo e variável
     const backgroundColors = [
         'var(--primary)', // Fixo
         'var(--purple)'   // Variável
     ];

     fixedVariableChart = new Chart(ctx, {
         type: 'pie',
         data: {
             labels: ['Fixas', 'Variáveis'],
             datasets: [{
                 data: [fixedExpenses, variableExpenses],
                 backgroundColor: backgroundColors,
                 borderColor: 'var(--card-bg)',
                 borderWidth: 2,
                 hoverOffset: 8
             }]
         },
         options: {
             ...commonOptions,
             plugins: {
                 ...commonOptions.plugins,
                 legend: { ...commonOptions.plugins.legend, position: 'right' },
                 title: { display: false }
             }
         }
     });
     delete fixedVariableChart.options.scales; // Remove eixos
}


// Inicializar/Atualizar gráfico de tendência de gastos
function updateTrendChart() {
    const ctx = document.getElementById('trend-chart')?.getContext('2d');
    if (!ctx) return;

    trendChart = destroyChart(trendChart);

    const categorySelect = document.getElementById('trend-chart-category');
    const categoryId = categorySelect?.value || 'all';
    const today = new Date();
    const labels = [];
    const data = [];
    const numberOfMonths = 6; // Mostra os últimos 6 meses

    for (let i = numberOfMonths - 1; i >= 0; i--) {
        const date = new Date(today.getFullYear(), today.getMonth() - i, 1);
        const targetYear = date.getFullYear();
        const targetMonth = date.getMonth();
        const monthLabel = date.toLocaleDateString('pt-BR', { month: 'short' });
        labels.push(monthLabel);

        // Filtra despesas para o mês/ano e categoria (se selecionada)
        let monthExpenses = filterTransactions({
            year: targetYear,
            month: targetMonth,
            type: 'expense'
        });
        if (categoryId !== 'all') {
            monthExpenses = monthExpenses.filter(t => t.category === categoryId);
        }

        const totalExpenses = monthExpenses
             .filter(t => t.status === 'paid' || t.status === 'pending') // Apenas pagos/pendentes
            .reduce((sum, t) => sum + (Number(t.amount) || 0), 0);
        data.push(totalExpenses);
    }

    const commonOptions = getChartCommonOptions();
    let datasetLabel = 'Despesas Totais';
    let color = 'var(--primary)';
    if (categoryId !== 'all') {
        const category = categories.find(c => c.id === categoryId);
        if (category) {
            datasetLabel = `Despesas: ${category.name}`;
            color = category.color || color; // Usa a cor da categoria
        }
    }

    trendChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [{
                label: datasetLabel,
                data: data,
                borderColor: color,
                backgroundColor: Chart.helpers.color(color).alpha(0.1).rgbString(), // Cor de fundo com transparência
                borderWidth: 2,
                tension: 0.3, // Linha suave
                fill: true, // Preenche a área sob a linha
                pointBackgroundColor: color, // Cor dos pontos
                pointRadius: 3, // Tamanho dos pontos
                pointHoverRadius: 5 // Tamanho ao passar o mouse
            }]
        },
        options: {
             ...commonOptions,
             plugins: {
                 ...commonOptions.plugins,
                 title: { display: false },
                  legend: { display: categoryId === 'all' } // Mostra legenda só se for 'Todas'
             },
             scales: {
                  ...commonOptions.scales,
                  y: { ...commonOptions.scales.y } // Garante formatação de moeda
             }
        }
    });
}


// Inicializar/Atualizar gráfico de orçamento (Orçado vs. Gasto Atual)
async function updateBudgetChart() {
    const ctx = document.getElementById('budget-chart')?.getContext('2d');
    if (!ctx) return;

    budgetChart = destroyChart(budgetChart);

    const budget = await getCurrentBudget(); // Pega orçamento do mês atual
    const expensesByCategory = getCurrentExpensesByCategory(); // Pega gastos do mês atual
    const commonOptions = getChartCommonOptions();

    const labels = [];
    const budgetData = [];
    const expenseData = [];
    const backgroundColorsBudget = [];
    const backgroundColorsExpense = [];

    if (budget && budget.categories) {
        // Ordena categorias com orçamento definido pelo nome
        const budgetedCategories = budget.categories
            .filter(bc => bc.amount > 0)
            .map(bc => ({ ...bc, ...categories.find(c => c.id === bc.id) })) // Combina dados do orçamento e da categoria
            .filter(bc => bc.name) // Remove se a categoria não foi encontrada
            .sort((a, b) => a.name.localeCompare(b.name));

        budgetedCategories.forEach(categoryBudget => {
            const categoryId = categoryBudget.id;
            const spentAmount = expensesByCategory[categoryId] || 0;

            labels.push(categoryBudget.name);
            budgetData.push(categoryBudget.amount);
            expenseData.push(spentAmount);
             // Define cores - pode variar se o gasto exceder o orçamento
            backgroundColorsBudget.push('var(--primary-light)'); // Cor mais clara para o orçamento
            backgroundColorsExpense.push(spentAmount > categoryBudget.amount ? 'var(--danger)' : 'var(--warning)'); // Vermelho se estourou, laranja se não
        });
    }


    budgetChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'Orçamento',
                    data: budgetData,
                    backgroundColor: backgroundColorsBudget,
                    borderColor: backgroundColorsBudget,
                    borderWidth: 1,
                    borderRadius: 4,
                    barPercentage: 0.7,
                    categoryPercentage: 0.6
                },
                {
                    label: 'Gasto Atual',
                    data: expenseData,
                    backgroundColor: backgroundColorsExpense,
                    borderColor: backgroundColorsExpense,
                    borderWidth: 1,
                    borderRadius: 4,
                    barPercentage: 0.7,
                    categoryPercentage: 0.6
                }
            ]
        },
        options: {
            ...commonOptions,
             indexAxis: 'y', // Gráfico de barras horizontal para melhor leitura das categorias
             plugins: {
                 ...commonOptions.plugins,
                 title: { display: false },
                 legend: { ...commonOptions.plugins.legend, position: 'top', align: 'end'} // Legenda no topo
             },
             scales: {
                 x: { // Eixo X agora representa valor
                     ...commonOptions.scales.y, // Usa a formatação de moeda do eixo Y original
                     title: { display: true, text: 'Valor (R$)', color: commonOptions.scales.y.ticks.color },
                     grid: { ...commonOptions.scales.y.grid }, // Usa estilo de grid do Y original
                     border: { ...commonOptions.scales.y.border }
                 },
                 y: { // Eixo Y agora representa categorias
                    ...commonOptions.scales.x, // Usa a formatação de texto do eixo X original
                    title: { display: false }, // Não precisa de título para categorias
                    grid: { display: false }, // Remove grid vertical para categorias
                     border: { ...commonOptions.scales.x.border }
                 }
             }
        }
    });
}


// Inicializar/Atualizar gráfico de projeção de economia
function updateSavingsProjectionChart() {
    const ctx = document.getElementById('savings-projection-chart')?.getContext('2d');
    if (!ctx) return;

    savingsProjectionChart = destroyChart(savingsProjectionChart);

    const today = new Date();
    const labels = [];
    const projectedData = [];
    const numberOfMonthsHistory = 3; // Meses de histórico para calcular a média
    const numberOfMonthsProjection = 12; // Meses de projeção

    const monthlySavingsHistory = [];
    for (let i = numberOfMonthsHistory - 1; i >= 0; i--) {
        const date = new Date(today.getFullYear(), today.getMonth() - i, 1);
        const year = date.getFullYear();
        const month = date.getMonth();
        const monthTransactions = filterTransactions({ year, month });
        const summary = getFinanceSummary(monthTransactions);
        monthlySavingsHistory.push(summary.balance); // Usa o saldo (receita - despesa) como economia
    }

    // Calcula média, tratando valores negativos (se a média for negativa, projeta 0)
    let avgMonthlySavings = 0;
    if (monthlySavingsHistory.length > 0) {
         const sum = monthlySavingsHistory.reduce((acc, val) => acc + val, 0);
         avgMonthlySavings = Math.max(0, sum / monthlySavingsHistory.length); // Média >= 0
    }


    // Projeta para os próximos meses
    let accumulatedSavings = 0; // Começa do 0 relativo à projeção
    for (let i = 0; i < numberOfMonthsProjection; i++) {
        const date = new Date(today.getFullYear(), today.getMonth() + i, 1);
        const monthLabel = date.toLocaleDateString('pt-BR', { month: 'short', year: '2-digit' });
        labels.push(monthLabel);
        accumulatedSavings += avgMonthlySavings;
        projectedData.push(accumulatedSavings);
    }

    const commonOptions = getChartCommonOptions();

    savingsProjectionChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [{
                label: `Economia Projetada (Média: ${formatCurrency(avgMonthlySavings)}/mês)`,
                data: projectedData,
                borderColor: 'var(--success)',
                backgroundColor: Chart.helpers.color('var(--success)').alpha(0.1).rgbString(),
                borderWidth: 2,
                tension: 0.3,
                fill: true,
                 pointRadius: 0, // Sem pontos para projeção
                 pointHoverRadius: 0
            }]
        },
        options: {
            ...commonOptions,
            plugins: {
                ...commonOptions.plugins,
                title: { display: false },
                legend: { display: true, labels: { boxWidth: 0 } } // Mostra legenda mas esconde a caixa de cor
            },
             scales: {
                 ...commonOptions.scales,
                 y: { ...commonOptions.scales.y, beginAtZero: false } // Permite começar abaixo de 0 se necessário (embora a projeção seja >= 0)
             }
        }
    });
}


// Inicializar/Atualizar gráfico de análise na aba Relatórios
function updateAnalysisChart() {
    const ctx = document.getElementById('analysis-chart')?.getContext('2d');
    if (!ctx) return;

    analysisChart = destroyChart(analysisChart);

    const analysisTypeSelect = document.getElementById('analysis-type');
    const analysisType = analysisTypeSelect?.value || 'category'; // Padrão por categoria
    const commonOptions = getChartCommonOptions();
    let chartConfig = { type: 'bar', data: { labels: [], datasets: [] }, options: commonOptions };


    switch (analysisType) {
        case 'monthly':
            // Análise de despesas mensais (últimos 12 meses)
            chartConfig.type = 'line';
            const monthlyTrend = getIncomeVsExpensesByMonth(12); // Reusa a função, pega só despesas
            chartConfig.data = {
                labels: monthlyTrend.labels,
                datasets: [{
                    label: 'Despesas Mensais',
                    data: monthlyTrend.expenseData,
                    borderColor: 'var(--primary)',
                    backgroundColor: Chart.helpers.color('var(--primary)').alpha(0.1).rgbString(),
                    borderWidth: 2, tension: 0.3, fill: true, pointRadius: 3, pointHoverRadius: 5
                }]
            };
             chartConfig.options.plugins.legend = { display: false }; // Uma série só
             chartConfig.options.scales = { ...commonOptions.scales, y: { ...commonOptions.scales.y } }; // Garante moeda no Y
            break;

        case 'yearly':
            // Análise de despesas anuais (últimos 5 anos)
            chartConfig.type = 'bar';
            const yearlyLabels = [];
            const yearlyData = [];
            const currentYear = new Date().getFullYear();
            for (let i = 4; i >= 0; i--) {
                const year = currentYear - i;
                yearlyLabels.push(year.toString());
                const yearExpenses = filterTransactions({ year: year, type: 'expense' })
                     .filter(t => t.status === 'paid' || t.status === 'pending')
                    .reduce((sum, t) => sum + (Number(t.amount) || 0), 0);
                yearlyData.push(yearExpenses);
            }
            chartConfig.data = {
                labels: yearlyLabels,
                datasets: [{
                    label: 'Despesas Anuais',
                    data: yearlyData,
                    backgroundColor: 'var(--primary)',
                    borderColor: 'var(--primary)',
                    borderWidth: 1, borderRadius: 4, barPercentage: 0.7, categoryPercentage: 0.8
                }]
            };
            chartConfig.options.plugins.legend = { display: false };
            chartConfig.options.scales = { ...commonOptions.scales, y: { ...commonOptions.scales.y } }; // Garante moeda no Y
            break;

        case 'category':
        default:
             // Análise por categoria (mês atual) - Barras Horizontais
             chartConfig.type = 'bar';
             chartConfig.options.indexAxis = 'y'; // Barras horizontais
             const currentExpenses = getCurrentExpensesByCategory();
             const sortedCategoryEntries = Object.entries(currentExpenses)
                 .filter(([, amount]) => amount > 0)
                 .sort(([, a], [, b]) => b - a) // Mais gastos primeiro
                 .slice(0, 10); // Top 10 categorias

             const categoryLabels = sortedCategoryEntries.map(([id]) => categories.find(c => c.id === id)?.name || 'Desconhecida');
             const categoryData = sortedCategoryEntries.map(([, amount]) => amount);
             const categoryColors = sortedCategoryEntries.map(([id]) => categories.find(c => c.id === id)?.color || '#cccccc');

             chartConfig.data = {
                 labels: categoryLabels,
                 datasets: [{
                     label: 'Despesas por Categoria (Mês Atual)',
                     data: categoryData,
                     backgroundColor: categoryColors,
                     borderColor: categoryColors,
                     borderWidth: 1, borderRadius: 4, barPercentage: 0.7, categoryPercentage: 0.8
                 }]
             };
              chartConfig.options.plugins.legend = { display: false };
              chartConfig.options.scales = { // Inverte eixos para barras horizontais
                  x: { ...commonOptions.scales.y, title: { display: true, text: 'Valor (R$)', color: commonOptions.scales.y.ticks.color} }, // X é valor
                  y: { ...commonOptions.scales.x, grid: { display: false } } // Y é categoria
              };
            break;
    }

    // Cria o gráfico com a configuração definida
    analysisChart = new Chart(ctx, chartConfig);
}


// Inicializar/Atualizar gráficos da análise mensal
function updateMonthlyAnalysisCharts() {
    const categoryCtx = document.getElementById('monthly-category-chart')?.getContext('2d');
    const dailyCtx = document.getElementById('monthly-daily-chart')?.getContext('2d');
    if (!categoryCtx || !dailyCtx) return;

    monthlyCategoryChart = destroyChart(monthlyCategoryChart);
    monthlyDailyChart = destroyChart(monthlyDailyChart);

    // Pega mês/ano selecionado na UI da Análise Mensal
    const year = parseInt(document.getElementById('monthly-analysis-year')?.value || new Date().getFullYear());
    const month = parseInt(document.getElementById('monthly-analysis-month')?.value || new Date().getMonth());

    const monthTransactions = filterTransactions({ year, month });
    const commonOptions = getChartCommonOptions();

    // --- Gráfico de Categorias do Mês (Doughnut) ---
    const expensesByCategory = getExpensesByCategory(monthTransactions);
    const sortedCategoryEntries = Object.entries(expensesByCategory)
        .filter(([, amount]) => amount > 0)
        .sort(([, a], [, b]) => b - a);
    const topCategoryEntries = sortedCategoryEntries.slice(0, 5); // Top 5 + Outros
    const otherCategoryAmount = sortedCategoryEntries.slice(5).reduce((sum, [, amount]) => sum + amount, 0);

    const categoryLabels = topCategoryEntries.map(([id]) => categories.find(c => c.id === id)?.name || 'Desconhecida');
    const categoryData = topCategoryEntries.map(([, amount]) => amount);
    const categoryColors = topCategoryEntries.map(([id]) => categories.find(c => c.id === id)?.color || '#cccccc');

    if (otherCategoryAmount > 0) {
        categoryLabels.push('Outras');
        categoryData.push(otherCategoryAmount);
        categoryColors.push('var(--text-secondary)');
    }

    monthlyCategoryChart = new Chart(categoryCtx, {
        type: 'doughnut',
        data: {
            labels: categoryLabels,
            datasets: [{ data: categoryData, backgroundColor: categoryColors, borderColor: 'var(--card-bg)', borderWidth: 2, hoverOffset: 8 }]
        },
        options: {
            ...commonOptions,
            cutout: '65%',
            plugins: { ...commonOptions.plugins, legend: { ...commonOptions.plugins.legend, position: 'right' }, title: { display: false } }
        }
    });
     delete monthlyCategoryChart.options.scales; // Remove eixos


    // --- Gráfico de Distribuição Diária (Barras) ---
    const daysInMonth = new Date(year, month + 1, 0).getDate();
    const dailyLabels = Array.from({ length: daysInMonth }, (_, i) => (i + 1).toString()); // Dias 1 a N
    const dailyIncome = Array(daysInMonth).fill(0);
    const dailyExpenses = Array(daysInMonth).fill(0);

    monthTransactions.forEach(t => {
        if (t.date) {
            try {
                const dayOfMonth = new Date(t.date).getUTCDate(); // Dia do mês (1-31)
                const amount = Number(t.amount) || 0;
                if (dayOfMonth >= 1 && dayOfMonth <= daysInMonth) {
                     if (t.type === 'income' && (t.status === 'paid' || t.status === 'pending')) {
                        dailyIncome[dayOfMonth - 1] += amount;
                    } else if (t.type === 'expense' && (t.status === 'paid' || t.status === 'pending')) {
                        dailyExpenses[dayOfMonth - 1] += amount;
                    }
                }
            } catch (e) { console.error("Erro ao processar data da transação:", t.date, e); }
        }
    });


    monthlyDailyChart = new Chart(dailyCtx, {
        type: 'bar',
        data: {
            labels: dailyLabels,
            datasets: [
                { label: 'Receitas', data: dailyIncome, backgroundColor: 'var(--success)', barPercentage: 0.8, categoryPercentage: 0.7 },
                { label: 'Despesas', data: dailyExpenses, backgroundColor: 'var(--danger)', barPercentage: 0.8, categoryPercentage: 0.7 }
            ]
        },
        options: {
            ...commonOptions,
            plugins: { ...commonOptions.plugins, title: { display: false } },
            scales: {
                 x: { stacked: true, grid: { display: false } }, // Empilha barras no mesmo dia, sem grid vertical
                 y: { stacked: true, ...commonOptions.scales.y } // Empilha valores, usa formatação de moeda
            }
        }
    });
}


// Inicializar/Atualizar gráfico de pizza no relatório mensal
function updateReportPieChart() {
    const ctx = document.getElementById('report-pie-chart')?.getContext('2d');
    if (!ctx) return; // Sai se o canvas não foi renderizado ainda

    reportPieChart = destroyChart(reportPieChart); // Destroi gráfico anterior se existir

    const monthIndex = parseInt(document.getElementById('report-month')?.value || new Date().getMonth());
    const year = parseInt(document.getElementById('report-year')?.value || new Date().getFullYear());

    const monthTransactions = filterTransactions({ year, month: monthIndex, type: 'expense' });
    const expensesByCategory = getExpensesByCategory(monthTransactions);
    const commonOptions = getChartCommonOptions();

    // Prepara dados (Top 7 + Outros)
    const sortedEntries = Object.entries(expensesByCategory)
        .filter(([, amount]) => amount > 0)
        .sort(([, a], [, b]) => b - a);
    const topEntries = sortedEntries.slice(0, 7);
    const otherAmount = sortedEntries.slice(7).reduce((sum, [, amount]) => sum + amount, 0);

    const labels = topEntries.map(([id]) => categories.find(c => c.id === id)?.name || 'Desconhecida');
    const data = topEntries.map(([, amount]) => amount);
    const backgroundColors = topEntries.map(([id]) => categories.find(c => c.id === id)?.color || '#cccccc');

    if (otherAmount > 0) {
        labels.push('Outras');
        data.push(otherAmount);
        backgroundColors.push('var(--text-secondary)');
    }

    reportPieChart = new Chart(ctx, {
        type: 'pie', // Mudei para Pie para variar do Doughnut da análise mensal
        data: {
            labels: labels,
            datasets: [{ data: data, backgroundColor: backgroundColors, borderColor: 'var(--card-bg)', borderWidth: 2, hoverOffset: 8 }]
        },
        options: {
            ...commonOptions,
            plugins: {
                 ...commonOptions.plugins,
                 legend: { ...commonOptions.plugins.legend, position: 'right' }, // Legenda à direita
                 title: { display: false }
            }
        }
    });
    delete reportPieChart.options.scales; // Remove eixos
}


// Inicializar todos os gráficos da aplicação
async function initCharts() {
    console.log("Inicializando gráficos...");
    try {
        // Chama as funções de atualização que também inicializam se necessário
        updateIncomeExpenseChart();
        updateCategoryChart();
        updateCashFlowChart();
        updateFixedVariableChart();
        updateTrendChart();
        await updateBudgetChart(); // Precisa ser async por causa do await getCurrentBudget
        updateSavingsProjectionChart();
        updateAnalysisChart();
        updateMonthlyAnalysisCharts(); // Inicializa os gráficos da análise mensal
        // O gráfico do relatório é inicializado/atualizado dentro de generateMonthlyReport
        console.log("Gráficos inicializados.");
    } catch (error) {
        console.error('Erro geral ao inicializar gráficos:', error);
        showAlert('Alguns gráficos não puderam ser carregados.', 'warning');
    }
}

// Atualizar todos os gráficos (chamado ao mudar tema, por exemplo)
async function updateCharts() {
     console.log("Atualizando gráficos...");
     // Re-chama todas as funções de atualização
     updateIncomeExpenseChart();
     updateCategoryChart();
     updateCashFlowChart();
     updateFixedVariableChart();
     updateTrendChart();
     await updateBudgetChart();
     updateSavingsProjectionChart();
     updateAnalysisChart();
     updateMonthlyAnalysisCharts();
     if (document.getElementById('tab-reports')?.classList.contains('active')) {
         updateReportPieChart(); // Atualiza gráfico do relatório se a aba estiver ativa
     }
     console.log("Gráficos atualizados.");
}

// ===== Interface e Interação (Continued) =====

// Inicializar navegação por tabs e definir estado inicial
function initTabs() {
    const tabsElements = document.querySelectorAll('.tab');
    const tabContentsElements = document.querySelectorAll('.tab-content');

    tabsElements.forEach(tab => {
        tab.addEventListener('click', () => {
            const tabId = tab.dataset.tab;
            if (!tabId) return; // Ignora se não tiver data-tab

            // Atualiza estado visual das tabs
            tabsElements.forEach(t => t.classList.remove('active'));
            tab.classList.add('active');

            // Atualiza estado global
            currentTab = tabId;

            // Gerencia visibilidade dos conteúdos
            tabContentsElements.forEach(content => {
                content.style.display = (content.id === `tab-${tabId}`) ? 'block' : 'none';
            });

            // Chama a função de atualização específica para a tab selecionada
            switch (tabId) {
                case 'overview':
                    // A visão geral é atualizada principalmente por updateDashboard()
                    // Mas podemos forçar uma atualização dos gráficos se necessário
                    updateCharts(); // Garante que gráficos estejam atualizados
                    break;
                case 'transactions':
                    updateTransactionsTable();
                    break;
                case 'budget':
                    updateBudgetTab();
                    break;
                case 'goals':
                    updateGoalsTab();
                    break;
                case 'monthly':
                    updateMonthlyAnalysis();
                    break;
                case 'categories':
                    updateCategoriesTab();
                    break;
                case 'reports':
                    updateReportsTab();
                    break;
                default:
                    console.warn(`Nenhuma função de atualização definida para a tab: ${tabId}`);
            }
        });
    });

    // Ativa a primeira tab ('overview') por padrão ao carregar
    const initialTab = document.querySelector('.tab[data-tab="overview"]');
    if (initialTab) {
        initialTab.click(); // Simula um clique para ativar a tab e seu conteúdo
    } else {
         console.warn("Tab inicial 'overview' não encontrada.");
         // Mostra o primeiro conteúdo encontrado como fallback
         if(tabContentsElements.length > 0) tabContentsElements[0].style.display = 'block';
    }
}


// Atualizar KPIs do dashboard principal
function updateKPIs() {
    // Seleciona os elementos dos KPIs
    const kpiBalanceEl = document.getElementById('kpi-balance');
    const kpiIncomeEl = document.getElementById('kpi-income');
    const kpiExpensesEl = document.getElementById('kpi-expenses');
    const kpiSavingsEl = document.getElementById('kpi-savings');
    const kpiProjectionEl = document.getElementById('kpi-projection');
    const balanceTrendEl = document.getElementById('balance-trend');
    const incomeTrendEl = document.getElementById('income-trend');
    const expensesTrendEl = document.getElementById('expenses-trend');
    const savingsGoalEl = document.getElementById('savings-goal');
    const savingsProgressEl = document.getElementById('savings-progress');
    const projectionStatusEl = document.getElementById('projection-status');

    // Verifica se todos os elementos existem antes de prosseguir
    if (!kpiBalanceEl || !kpiIncomeEl || !kpiExpensesEl || !kpiSavingsEl || !kpiProjectionEl ||
        !balanceTrendEl || !incomeTrendEl || !expensesTrendEl || !savingsGoalEl ||
        !savingsProgressEl || !projectionStatusEl) {
        console.error("Um ou mais elementos KPI não foram encontrados.");
        return;
    }

    // Pega filtros principais
    const filterYear = document.getElementById('filter-year').value;
    const filterMonth = document.getElementById('filter-month').value;

    // Filtra transações para o período selecionado (mês/ano ou tudo)
    const currentPeriodTransactions = filterTransactions({
        year: filterYear === 'all' ? null : filterYear,
        month: filterMonth === 'all' ? null : filterMonth
    });
    const currentSummary = getFinanceSummary(currentPeriodTransactions);

    // Atualiza valores principais
    kpiBalanceEl.textContent = formatCurrency(currentSummary.balance);
    kpiIncomeEl.textContent = formatCurrency(currentSummary.income);
    kpiExpensesEl.textContent = formatCurrency(currentSummary.expenses);
    kpiSavingsEl.textContent = formatCurrency(currentSummary.balance); // Economia = Saldo do período
    kpiProjectionEl.textContent = formatCurrency(currentSummary.expenses + currentSummary.pendingExpenses); // Projeção = Gastos + Agendados

    // Atualiza Meta de Economia (Exemplo com meta fixa, poderia vir do Firestore)
    const savingsGoalValue = 1000.00; // Exemplo de meta
    savingsGoalEl.textContent = formatCurrency(savingsGoalValue);
    const savingsPercentage = savingsGoalValue > 0 ? Math.min(100, Math.max(0, (currentSummary.balance / savingsGoalValue) * 100)) : 0;
    savingsProgressEl.style.width = `${savingsPercentage}%`;
    savingsProgressEl.className = `progress-bar ${savingsPercentage >= 75 ? 'success' : savingsPercentage >= 40 ? 'warning' : 'danger'}`;

    // Atualiza Status da Projeção (Comparação com orçamento, se houver)
    // (Esta lógica precisa do orçamento carregado)
    updateProjectionStatus(currentSummary.expenses + currentSummary.pendingExpenses, filterYear, filterMonth);


    // Atualiza Tendências (Comparação com período anterior)
    // Define o período anterior com base no filtro atual
    let previousPeriodTransactions;
    if (filterMonth !== 'all' && filterYear !== 'all') {
        // Compara com o mês anterior do mesmo ano
        const prevMonthDate = new Date(parseInt(filterYear), parseInt(filterMonth) - 1, 1);
        previousPeriodTransactions = filterTransactions({ year: prevMonthDate.getFullYear(), month: prevMonthDate.getMonth() });
    } else if (filterYear !== 'all') {
         // Compara com o ano anterior
         previousPeriodTransactions = filterTransactions({ year: parseInt(filterYear) - 1 });
    } else {
        // Compara tudo com o ano anterior completo
        previousPeriodTransactions = filterTransactions({ year: new Date().getFullYear() - 1 });
    }
    const previousSummary = getFinanceSummary(previousPeriodTransactions);

    // Função auxiliar para calcular e formatar variação
    const calculateTrend = (current, previous) => {
        if (previous === 0 && current === 0) return { text: '0.0%', classSuffix: '' };
        if (previous === 0 && current !== 0) return { text: '+100%', classSuffix: 'up' }; // Ou 'N/A'
        const variation = ((current - previous) / Math.abs(previous)) * 100;
         const text = `${variation >= 0 ? '+' : ''}${formatNumber(variation, 1)}%`;
        let classSuffix = '';
        if (variation > 5) classSuffix = 'up'; // Aumento significativo
        if (variation < -5) classSuffix = 'down'; // Queda significativa
        return { text, classSuffix };
    };

    // Calcula e atualiza tendências
    const balanceTrend = calculateTrend(currentSummary.balance, previousSummary.balance);
    balanceTrendEl.textContent = balanceTrend.text;
    balanceTrendEl.parentElement.className = `kpi-trend ${balanceTrend.classSuffix}`;

    const incomeTrend = calculateTrend(currentSummary.income, previousSummary.income);
    incomeTrendEl.textContent = incomeTrend.text;
    incomeTrendEl.parentElement.className = `kpi-trend ${incomeTrend.classSuffix}`;

    // Para despesas, a classe é invertida (queda é 'up'/bom, aumento é 'down'/ruim)
    const expensesTrend = calculateTrend(currentSummary.expenses, previousSummary.expenses);
    expensesTrendEl.textContent = expensesTrend.text;
    let expenseClassSuffix = '';
    if (expensesTrend.classSuffix === 'up') expenseClassSuffix = 'down'; // Aumento é ruim
    if (expensesTrend.classSuffix === 'down') expenseClassSuffix = 'up'; // Queda é bom
    expensesTrendEl.parentElement.className = `kpi-trend ${expenseClassSuffix}`;
}


// Função auxiliar para atualizar o status da projeção comparando com o orçamento
async function updateProjectionStatus(projectedExpenses, filterYear, filterMonth) {
    const projectionStatusEl = document.getElementById('projection-status');
    if (!projectionStatusEl) return;

    let totalBudgetValue = 0;
    let statusText = 'Sem orçamento definido';
    let statusClass = '';
    let statusIcon = `
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="12" cy="12" r="10"></circle>
          <line x1="12" y1="8" x2="12" y2="12"></line>
          <line x1="12" y1="16" x2="12.01" y2="16"></line>
        </svg>`; // Ícone padrão (info)


    if (filterMonth !== 'all' && filterYear !== 'all') {
        const budget = await getBudgetForMonthAndYear(parseInt(filterMonth), parseInt(filterYear));
        if (budget && budget.categories) {
            totalBudgetValue = budget.categories.reduce((sum, cat) => sum + (Number(cat.amount) || 0), 0);
        }
    }
    // Se não for filtro mensal, podemos comparar com a média anual de orçamento? (complexo)
    // Por simplicidade, só mostraremos status detalhado para filtro mensal.

    if (totalBudgetValue > 0) {
        const percentageUsed = (projectedExpenses / totalBudgetValue) * 100;
        if (projectedExpenses <= totalBudgetValue * 0.85) { // Abaixo de 85%
            statusText = 'Dentro do orçamento';
            statusClass = 'up';
            statusIcon = `
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                  <polyline points="22 4 12 14.01 9 11.01"></polyline>
                </svg>`; // Ícone check (sucesso)
        } else if (projectedExpenses <= totalBudgetValue) { // Entre 85% e 100%
            statusText = 'Próximo do limite';
             statusClass = ''; // Neutro
             // Ícone padrão (info) já definido
        } else { // Acima de 100%
            statusText = 'Acima do orçamento';
            statusClass = 'down';
             statusIcon = `
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>
                  <line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line>
                </svg>`; // Ícone warning/danger
        }
    }

    projectionStatusEl.className = `kpi-trend ${statusClass}`;
    projectionStatusEl.innerHTML = `${statusIcon} <span>${statusText}</span>`;
}


// Atualizar lista de transações recentes na Visão Geral
function updateRecentTransactions() {
    const container = document.getElementById('recent-transactions');
    if (!container) return;

    container.innerHTML = ''; // Limpa container

    // Pega as últimas 5 transações GERAIS (sem filtro de período aplicado aqui)
    const recent = [...transactions]
        .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime()) // Ordena por data desc
        .slice(0, 5); // Pega as 5 mais recentes

    if (recent.length === 0) {
        container.innerHTML = `<div style="text-align: center; padding: 2rem 0; color: var(--text-secondary);">Nenhuma transação encontrada.</div>`;
        return;
    }

    recent.forEach(transaction => {
        const category = categories.find(c => c.id === transaction.category) || { name: '?', color: '#ccc', icon: '?' };
        const item = document.createElement('div');
        item.className = 'flow-item';
        item.style.cursor = 'pointer'; // Indica clicável
        item.setAttribute('role', 'button');
        item.setAttribute('tabindex', '0');
        item.setAttribute('aria-label', `Detalhes da transação: ${transaction.description}`);


        item.innerHTML = `
            <div class="flow-item-left">
                <div class="flow-item-icon ${transaction.type}" style="background-color: ${category.color};">
                    ${category.icon}
                </div>
                <div class="flow-item-info">
                    <div class="flow-item-title">${transaction.description}</div>
                    <div class="flow-item-meta">${formatDate(transaction.date)} · ${category.name}</div>
                </div>
            </div>
            <div class="flow-item-amount ${transaction.type}">
                ${transaction.type === 'income' ? '+' : '-'} ${formatCurrency(transaction.amount)}
            </div>
        `;

        // Adiciona listener para mostrar detalhes ao clicar ou pressionar Enter
        const showDetailsAction = () => showTransactionDetails(transaction.id);
        item.addEventListener('click', showDetailsAction);
        item.addEventListener('keydown', (e) => {
             if (e.key === 'Enter' || e.key === ' ') {
                  showDetailsAction();
             }
        });


        container.appendChild(item);
    });
}


// Atualizar tabela de transações na aba Transações (com paginação)
let currentTransactionsPage = 1;
const transactionsPerPage = 10;
let currentFilteredTransactions = []; // Armazena a lista filtrada atual

function updateTransactionsTable() {
    const tableBody = document.getElementById('transactions-table-body');
    const showingText = document.getElementById('transactions-showing');
    const prevButton = document.getElementById('transactions-prev');
    const nextButton = document.getElementById('transactions-next');

    if (!tableBody || !showingText || !prevButton || !nextButton) {
        console.error("Elementos da tabela de transações não encontrados.");
        return;
    }

    // Obter filtros específicos da aba de transações
    const filters = {
        year: document.getElementById('transactions-filter-year').value,
        month: document.getElementById('transactions-filter-month').value,
        type: document.getElementById('transactions-filter-type').value,
        category: document.getElementById('transactions-filter-category').value,
        status: document.getElementById('transactions-filter-status').value,
        search: document.getElementById('transactions-search').value
    };

    // Aplica filtros e armazena o resultado
    currentFilteredTransactions = filterTransactions(filters);

    // Cálculos de paginação
    const totalItems = currentFilteredTransactions.length;
    const totalPages = Math.ceil(totalItems / transactionsPerPage);
    // Garante que a página atual não seja maior que o total de páginas
    currentTransactionsPage = Math.max(1, Math.min(currentTransactionsPage, totalPages));

    const startIndex = (currentTransactionsPage - 1) * transactionsPerPage;
    const endIndex = Math.min(startIndex + transactionsPerPage, totalItems);
    const pageItems = currentFilteredTransactions.slice(startIndex, endIndex);

    // Atualiza informações de paginação
    showingText.textContent = totalItems > 0
        ? `Mostrando ${startIndex + 1}-${endIndex} de ${totalItems} transações`
        : 'Nenhuma transação encontrada';
    prevButton.disabled = currentTransactionsPage <= 1;
    nextButton.disabled = currentTransactionsPage >= totalPages;

    // Renderiza a tabela
    tableBody.innerHTML = ''; // Limpa tabela
    if (pageItems.length === 0) {
        tableBody.innerHTML = `<tr><td colspan="6" style="text-align: center; padding: 2rem 0; color: var(--text-secondary);">Nenhuma transação encontrada com os filtros aplicados.</td></tr>`;
    } else {
        pageItems.forEach(transaction => {
            const row = document.createElement('tr');
            const category = categories.find(c => c.id === transaction.category) || { name: '?', color: '#ccc', icon: '?' };
            const statusInfo = TRANSACTION_STATUS[transaction.status] || { name: '?', class: '' };
            const amountColor = transaction.type === 'income' ? 'var(--success)' : 'var(--danger)';
            const amountPrefix = transaction.type === 'income' ? '+' : '-';

            row.innerHTML = `
                <td>${formatDate(transaction.date)}</td>
                <td>${transaction.description}</td>
                <td>
                    <span style="display: inline-flex; align-items: center; gap: 0.5rem;" title="${category.name}">
                        <span style="width: 1.25rem; height: 1.25rem; font-size: 0.8rem; border-radius: 50%; background-color: ${category.color}; display: flex; align-items: center; justify-content: center; color: white; flex-shrink: 0;">${category.icon}</span>
                        <span style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 150px;">${category.name}</span>
                    </span>
                </td>
                <td style="color: ${amountColor}; font-weight: 600;">${amountPrefix} ${formatCurrency(transaction.amount)}</td>
                <td><span class="status ${statusInfo.class}">${statusInfo.name}</span></td>
                <td>
                    <div class="table-actions">
                        <button class="table-action-btn btn-view" title="Ver Detalhes" aria-label="Ver detalhes de ${transaction.description}">
                             <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>
                        </button>
                        <button class="table-action-btn btn-edit" title="Editar" aria-label="Editar ${transaction.description}">
                             <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>
                        </button>
                        <button class="table-action-btn btn-delete" title="Excluir" aria-label="Excluir ${transaction.description}">
                             <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
                        </button>
                    </div>
                </td>
            `;
            // Adiciona listeners aos botões da linha
            row.querySelector('.btn-view').addEventListener('click', () => showTransactionDetails(transaction.id));
            row.querySelector('.btn-edit').addEventListener('click', () => openTransactionModal(transaction));
            row.querySelector('.btn-delete').addEventListener('click', () => confirmDeleteTransaction(transaction.id));

            tableBody.appendChild(row);
        });
    }

    // Listeners de paginação (removidos e recriados para evitar duplicação)
    const newPrevButton = prevButton.cloneNode(true); // Clona para remover listeners antigos
    prevButton.parentNode.replaceChild(newPrevButton, prevButton);
    newPrevButton.disabled = currentTransactionsPage <= 1;
    newPrevButton.addEventListener('click', () => {
        if (currentTransactionsPage > 1) {
            currentTransactionsPage--;
            updateTransactionsTable();
        }
    });


    const newNextButton = nextButton.cloneNode(true);
    nextButton.parentNode.replaceChild(newNextButton, nextButton);
    newNextButton.disabled = currentTransactionsPage >= totalPages;
    newNextButton.addEventListener('click', () => {
         if (currentTransactionsPage < totalPages) {
            currentTransactionsPage++;
            updateTransactionsTable();
        }
    });
}


// Atualizar conteúdo da aba de Orçamento
async function updateBudgetTab() {
    try {
        // Atualiza o gráfico Orçado vs. Gasto Atual
        await updateBudgetChart();
        // Atualiza a tabela/lista de progresso do orçamento
        await updateBudgetProgress();
    } catch (error) {
        console.error('Erro ao atualizar aba de orçamento:', error);
        showAlert('Erro ao carregar dados do orçamento.', 'danger');
         // Mostra mensagem de erro nos containers se falhar
         document.getElementById('budget-progress-container').innerHTML = '<div style="text-align: center; padding: 1rem; color: var(--danger);">Erro ao carregar progresso.</div>';
         document.getElementById('budget-table-body').innerHTML = '<tr><td colspan="5" style="text-align: center; padding: 2rem 0; color: var(--danger);">Erro ao carregar orçamento.</td></tr>';
    }
}


// Atualizar a lista/tabela de progresso do orçamento
async function updateBudgetProgress() {
    const progressContainer = document.getElementById('budget-progress-container'); // Container de barras
    const budgetTableBody = document.getElementById('budget-table-body'); // Corpo da tabela
    if (!progressContainer || !budgetTableBody) return;

    progressContainer.innerHTML = '<div style="text-align: center; padding: 1rem; color: var(--text-secondary);">Carregando...</div>';
    budgetTableBody.innerHTML = '<tr><td colspan="5" style="text-align: center; padding: 2rem 0; color: var(--text-secondary);">Carregando...</td></tr>';

    try {
        const budget = await getCurrentBudget(); // Pega orçamento do mês atual
        const expensesByCategory = getCurrentExpensesByCategory(); // Pega gastos do mês atual

        // Filtra apenas categorias que têm um valor orçado > 0
        const budgetedItems = budget && budget.categories
            ? budget.categories
                  .filter(bc => bc.amount > 0)
                  .map(bc => {
                      const categoryInfo = categories.find(c => c.id === bc.id);
                      const spent = expensesByCategory[bc.id] || 0;
                      const budgetAmount = bc.amount;
                      const remaining = budgetAmount - spent;
                      const percentage = budgetAmount > 0 ? Math.min(100, Math.max(0, (spent / budgetAmount) * 100)) : 0;
                      let statusClass = 'success';
                      if (percentage >= 95) statusClass = 'danger'; // Mais sensível
                      else if (percentage >= 80) statusClass = 'warning';

                      return {
                          ...categoryInfo, // name, color, icon
                          budgetAmount, spent, remaining, percentage, statusClass
                      };
                  })
                  .filter(item => item.name) // Remove categorias não encontradas
                   .sort((a, b) => a.name.localeCompare(b.name)) // Ordena por nome
            : [];


        progressContainer.innerHTML = ''; // Limpa container de barras
        budgetTableBody.innerHTML = ''; // Limpa corpo da tabela

        if (budgetedItems.length === 0) {
            const noBudgetText = 'Nenhum item orçado para este mês. Clique em "Editar Orçamento".';
            progressContainer.innerHTML = `<div style="text-align: center; padding: 1rem; color: var(--text-secondary);">${noBudgetText}</div>`;
            budgetTableBody.innerHTML = `<tr><td colspan="5" style="text-align: center; padding: 2rem 0; color: var(--text-secondary);">${noBudgetText}</td></tr>`;
            return;
        }

        // Renderiza barras de progresso
        budgetedItems.forEach(item => {
            const progressElement = document.createElement('div');
            progressElement.style.marginBottom = '1.25rem';
            progressElement.innerHTML = `
                <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem; align-items: center;">
                    <div style="display: flex; align-items: center; gap: 0.75rem;">
                        <div style="width: 1.25rem; height: 1.25rem; font-size: 0.8rem; border-radius: 50%; background-color: ${item.color}; display: flex; align-items: center; justify-content: center; color: white; flex-shrink: 0;">${item.icon}</div>
                        <span style="font-weight: 500;">${item.name}</span>
                    </div>
                    <div style="font-size: 0.9rem; color: var(--text-secondary);">
                        <span style="font-weight: 600; color: var(--text);">${formatCurrency(item.spent)}</span> / ${formatCurrency(item.budgetAmount)}
                    </div>
                </div>
                <div class="progress-container">
                    <div class="progress-bar ${item.statusClass}" style="width: ${item.percentage}%" title="${item.percentage.toFixed(1)}% usado"></div>
                </div>
                 <div style="font-size: 0.75rem; text-align: right; margin-top: 0.25rem; color: ${item.remaining >= 0 ? 'var(--success)' : 'var(--danger)'};">
                     ${item.remaining >= 0 ? `Restam ${formatCurrency(item.remaining)}` : `Excedido ${formatCurrency(Math.abs(item.remaining))}`}
                 </div>
            `;
            progressContainer.appendChild(progressElement);
        });


         // Renderiza tabela de orçamento
        budgetedItems.forEach(item => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>
                    <div style="display: flex; align-items: center; gap: 0.75rem;">
                         <div style="width: 1.25rem; height: 1.25rem; font-size: 0.8rem; border-radius: 50%; background-color: ${item.color}; display: flex; align-items: center; justify-content: center; color: white; flex-shrink: 0;">${item.icon}</div>
                        ${item.name}
                    </div>
                </td>
                <td>${formatCurrency(item.budgetAmount)}</td>
                <td>${formatCurrency(item.spent)}</td>
                <td style="color: ${item.remaining >= 0 ? 'var(--success)' : 'var(--danger)'}; font-weight: 500;">
                    ${item.remaining >= 0 ? '+' : '-'} ${formatCurrency(Math.abs(item.remaining))}
                </td>
                <td>
                    <div class="progress-container" style="margin: 0;">
                        <div class="progress-bar ${item.statusClass}" style="width: ${item.percentage}%" title="${item.percentage.toFixed(1)}% usado"></div>
                    </div>
                </td>
            `;
            budgetTableBody.appendChild(row);
        });

    } catch (error) {
        console.error('Erro ao atualizar progresso do orçamento:', error);
        progressContainer.innerHTML = '<div style="text-align: center; padding: 1rem; color: var(--danger);">Erro ao carregar progresso.</div>';
        budgetTableBody.innerHTML = '<tr><td colspan="5" style="text-align: center; padding: 2rem 0; color: var(--danger);">Erro ao carregar orçamento.</td></tr>';
    }
}


// Atualizar conteúdo da aba de Metas
function updateGoalsTab() {
    const goalsContainer = document.getElementById('goals-container');
    if (!goalsContainer) return;

    goalsContainer.innerHTML = ''; // Limpa container

    if (goals.length === 0) {
        goalsContainer.innerHTML = `<div style="text-align: center; padding: 2rem 0; color: var(--text-secondary);">Nenhuma meta definida. Clique em "Nova Meta".</div>`;
        updateSavingsProjectionChart(); // Atualiza gráfico mesmo sem metas
        return;
    }

    // Ordena metas: mais próximas da data alvo primeiro, depois por progresso
    const sortedGoals = [...goals].sort((a, b) => {
        const dateDiff = new Date(a.targetDate).getTime() - new Date(b.targetDate).getTime();
        if (dateDiff !== 0) return dateDiff;
        // Se datas iguais, ordena por maior progresso primeiro
        return calculateGoalProgress(b).progress - calculateGoalProgress(a).progress;
    });

    // Renderiza cada meta
    sortedGoals.forEach(goal => {
        const progress = calculateGoalProgress(goal);
        let statusClass = 'success';
        if (progress.progress < 30) statusClass = 'danger';
        else if (progress.progress < 70) statusClass = 'warning';

        const goalElement = document.createElement('div');
        goalElement.className = 'card goal-card'; // Adiciona classe específica
        goalElement.style.marginBottom = '1.5rem'; // Espaçamento entre cards
        goalElement.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 1rem; flex-wrap: wrap; gap: 0.5rem;">
                <div>
                    <h3 class="goal-name">${goal.name}</h3>
                    <div class="goal-meta">
                        Meta: ${formatCurrency(goal.targetAmount)} • Data: ${formatDate(goal.targetDate)}
                        (${progress.daysRemaining > 0 ? `${progress.daysRemaining} dias restantes` : 'Prazo atingido'})
                    </div>
                </div>
                <div class="goal-actions" style="display: flex; gap: 0.5rem; align-items: center;">
                    <button class="btn btn-icon btn-sm btn-update-goal" title="Atualizar Saldo" aria-label="Atualizar saldo de ${goal.name}">
                        <svg width="16" height="16" viewBox="0 0 24 24"><path fill="currentColor" d="M17 13h-4v4h-2v-4H7v-2h4V7h2v4h4v2z"/></svg>
                    </button>
                     <button class="btn btn-icon btn-sm btn-edit-goal" title="Editar Meta" aria-label="Editar meta ${goal.name}">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>
                    </button>
                    <button class="btn btn-icon btn-sm btn-delete-goal" title="Excluir Meta" aria-label="Excluir meta ${goal.name}">
                         <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
                    </button>
                </div>
            </div>

            <div class="goal-progress-details" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                 <span class="goal-current-amount" style="font-weight: 600;">${formatCurrency(goal.currentAmount)}</span>
                 <span class="goal-percentage" style="font-weight: 600; color: var(--${statusClass});">${progress.progress.toFixed(1)}%</span>
                 <span class="goal-remaining-amount" style="color: var(--text-secondary);">Faltam ${formatCurrency(progress.remainingAmount)}</span>
            </div>

            <div class="progress-container">
                <div class="progress-bar ${statusClass}" style="width: ${progress.progress}%"></div>
            </div>

            <div class="goal-projection" style="font-size: 0.8rem; color: var(--text-secondary); margin-top: 0.5rem; text-align: right;">
                 ${progress.daysRemaining > 0 ? `Necessário: ${formatCurrency(progress.monthlySavingsNeeded)}/mês` : ''}
            </div>
        `;

        // Adiciona listeners aos botões da meta
        goalElement.querySelector('.btn-edit-goal').addEventListener('click', () => openGoalModal(goal));
        goalElement.querySelector('.btn-update-goal').addEventListener('click', () => openUpdateGoalBalanceModal(goal));
        goalElement.querySelector('.btn-delete-goal').addEventListener('click', () => confirmDeleteGoal(goal.id));

        goalsContainer.appendChild(goalElement);
    });

    // Atualiza gráfico de projeção
    updateSavingsProjectionChart();
}


// Abrir modal para atualizar saldo da meta (reconfigura modal de confirmação)
function openUpdateGoalBalanceModal(goal) {
    const confirmModalElement = document.getElementById('confirm-modal');
    const title = document.getElementById('confirm-modal-title');
    const message = document.getElementById('confirm-modal-message');
    const confirmBtn = document.getElementById('confirm-modal-confirm');
    const cancelBtn = document.getElementById('confirm-modal-cancel');

    if (!confirmModalElement || !title || !message || !confirmBtn || !cancelBtn) return;

    title.textContent = 'Atualizar Saldo da Meta';
    message.innerHTML = `
        <p>Meta: <strong>${goal.name}</strong></p>
        <p>Valor Alvo: ${formatCurrency(goal.targetAmount)}</p>
        <div class="form-group" style="margin-top: 1rem;">
            <label for="update-goal-amount" style="display: block; margin-bottom: 0.5rem;">Novo Saldo Atual:</label>
            <input type="number" id="update-goal-amount" class="form-control"
                   value="${goal.currentAmount.toFixed(2)}" min="0" step="0.01"
                   max="${goal.targetAmount}" required>
        </div>
    `;
    confirmBtn.textContent = 'Atualizar Saldo';
    confirmBtn.className = 'btn btn-primary'; // Muda para botão primário

    // Clona o botão para remover listeners antigos e adiciona o novo
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    newConfirmBtn.addEventListener('click', async () => {
        const inputAmount = document.getElementById('update-goal-amount');
        const newAmount = parseFloat(inputAmount.value);
        if (isNaN(newAmount) || newAmount < 0) {
            showAlert('Valor inválido. Insira um número positivo.', 'warning');
            inputAmount.focus();
            return;
        }
        if (newAmount > goal.targetAmount) {
             showAlert('O Valor Atual não pode ser maior que o Valor Alvo.', 'warning');
             inputAmount.focus();
             return;
        }
        await updateGoalBalance(goal.id, newAmount);
        closeModal(confirmModalElement);
    });

    // Garante que o botão cancelar funcione
    const newCancelBtn = cancelBtn.cloneNode(true);
    cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
    newCancelBtn.addEventListener('click', () => closeModal(confirmModalElement));


    openModal(confirmModalElement);

    // Foca no input ao abrir
    setTimeout(() => document.getElementById('update-goal-amount')?.focus(), 100);
}


// Atualizar saldo da meta (lógica + UI)
async function updateGoalBalance(goalId, newAmount) {
    try {
        const goalIndex = goals.findIndex(g => g.id === goalId);
        if (goalIndex === -1) throw new Error("Meta não encontrada localmente.");

        // Cria um objeto atualizado para salvar
        const updatedGoal = { ...goals[goalIndex], currentAmount: newAmount };

        await saveGoalToFirestore(updatedGoal); // Salva no Firestore

        // Atualiza o array local
        goals[goalIndex] = updatedGoal;

        showAlert('Saldo da meta atualizado!', 'success');

        // Re-renderiza a aba de metas se estiver ativa
        if (document.getElementById('tab-goals')?.classList.contains('active')) {
            updateGoalsTab();
        }

    } catch (error) {
        console.error('Erro ao atualizar saldo da meta:', error);
        showAlert('Falha ao atualizar saldo da meta.', 'danger');
    }
}


// Atualizar conteúdo da aba de Análise Mensal
function updateMonthlyAnalysis() {
    try {
        const yearSelect = document.getElementById('monthly-analysis-year');
        const monthSelect = document.getElementById('monthly-analysis-month');
        if (!yearSelect || !monthSelect) return;

        const selectedYear = parseInt(yearSelect.value);
        const selectedMonth = parseInt(monthSelect.value);

        // Validação básica
        if (isNaN(selectedYear) || isNaN(selectedMonth)) {
            console.warn("Ano ou mês inválido na análise mensal.");
            return;
        }

        const monthTransactions = filterTransactions({ year: selectedYear, month: selectedMonth });
        const summary = getFinanceSummary(monthTransactions);

        // Atualiza Resumos
        document.getElementById('monthly-income').textContent = formatCurrency(summary.income);
        document.getElementById('monthly-income-count').textContent = `${monthTransactions.filter(t=>t.type==='income').length} transações`;
        document.getElementById('monthly-expense').textContent = formatCurrency(summary.expenses);
        document.getElementById('monthly-expense-count').textContent = `${monthTransactions.filter(t=>t.type==='expense').length} transações`;
        document.getElementById('monthly-balance').textContent = formatCurrency(summary.balance);

        // Atualiza status do saldo
        const balanceEl = document.getElementById('monthly-balance');
        const balanceStatusEl = document.getElementById('monthly-balance-status');
        if (summary.balance > 0) {
            balanceEl.style.color = 'var(--success)';
            balanceStatusEl.textContent = 'Superávit';
             balanceStatusEl.style.color = 'var(--success)';
        } else if (summary.balance < 0) {
            balanceEl.style.color = 'var(--danger)';
            balanceStatusEl.textContent = 'Déficit';
            balanceStatusEl.style.color = 'var(--danger)';
        } else {
             balanceEl.style.color = 'var(--text)';
             balanceStatusEl.textContent = 'Equilibrado';
             balanceStatusEl.style.color = 'var(--text-secondary)';
        }


        // Atualiza Gráficos da aba
        updateMonthlyAnalysisCharts();

        // Atualiza Listas de Transações da aba
        updateMonthlyTransactionLists(monthTransactions);

    } catch (error) {
        console.error("Erro ao atualizar análise mensal:", error);
        showAlert('Erro ao carregar dados da análise mensal.', 'danger');
    }
}


// Atualizar as listas de receitas/despesas na Análise Mensal
function updateMonthlyTransactionLists(monthTransactions) {
    const incomeListContainer = document.getElementById('monthly-income-list');
    const expenseListContainer = document.getElementById('monthly-expense-list');
    if (!incomeListContainer || !expenseListContainer) return;

    // Separa e ordena
    const incomeItems = monthTransactions.filter(t => t.type === 'income').sort((a, b) => new Date(b.date) - new Date(a.date));
    const expenseItems = monthTransactions.filter(t => t.type === 'expense').sort((a, b) => new Date(b.date) - new Date(a.date));

    // Função auxiliar para renderizar uma lista
    const renderList = (container, items, type) => {
        container.innerHTML = ''; // Limpa
        if (items.length === 0) {
            container.innerHTML = `<div style="text-align: center; padding: 2rem 0; color: var(--text-secondary);">Nenhuma ${type === 'income' ? 'receita' : 'despesa'} neste mês.</div>`;
        } else {
            items.forEach(transaction => {
                 const category = categories.find(c => c.id === transaction.category) || { name: '?', color: '#ccc', icon: '?' };
                 const itemElement = document.createElement('div');
                 itemElement.className = 'month-transaction';
                 itemElement.style.cursor = 'pointer';
                 itemElement.setAttribute('role', 'button');
                 itemElement.setAttribute('tabindex', '0');
                 itemElement.setAttribute('aria-label', `Detalhes de ${transaction.description}`);
                 itemElement.innerHTML = `
                    <div class="month-transaction-left">
                        <div class="month-transaction-icon" style="background-color: ${category.color};">
                            ${category.icon}
                        </div>
                        <div class="month-transaction-info">
                            <div class="month-transaction-title">${transaction.description}</div>
                            <div class="month-transaction-date">${formatDate(transaction.date)}</div>
                        </div>
                    </div>
                    <div class="month-transaction-amount" style="color: var(--${type === 'income' ? 'success' : 'danger'});">
                        ${formatCurrency(transaction.amount)}
                    </div>
                `;
                // Listener para detalhes
                 const showDetailsAction = () => showTransactionDetails(transaction.id);
                 itemElement.addEventListener('click', showDetailsAction);
                 itemElement.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') showDetailsAction(); });

                 container.appendChild(itemElement);
            });
        }
    };

    // Renderiza ambas as listas
    renderList(incomeListContainer, incomeItems, 'income');
    renderList(expenseListContainer, expenseItems, 'expense');
}


// Navegar para o mês anterior na Análise Mensal
function navigateToPreviousMonth() {
    const yearSelect = document.getElementById('monthly-analysis-year');
    const monthSelect = document.getElementById('monthly-analysis-month');
    if (!yearSelect || !monthSelect) return;

    let year = parseInt(yearSelect.value);
    let month = parseInt(monthSelect.value);

    month--;
    if (month < 0) {
        month = 11;
        year--;
        // Verifica se o novo ano existe no select, se não, adiciona? (ou limita)
         if (!Array.from(yearSelect.options).some(opt => opt.value == year)) {
             console.warn("Ano anterior não disponível no select.");
             // Poderia adicionar o ano dinamicamente ou apenas parar a navegação
             return; // Para a navegação se o ano não existir
         }
    }

    yearSelect.value = year;
    monthSelect.value = month;
    updateMonthlyAnalysis(); // Atualiza a UI
}

// Navegar para o próximo mês na Análise Mensal
function navigateToNextMonth() {
    const yearSelect = document.getElementById('monthly-analysis-year');
    const monthSelect = document.getElementById('monthly-analysis-month');
     if (!yearSelect || !monthSelect) return;

    let year = parseInt(yearSelect.value);
    let month = parseInt(monthSelect.value);

    month++;
    if (month > 11) {
        month = 0;
        year++;
         if (!Array.from(yearSelect.options).some(opt => opt.value == year)) {
             console.warn("Próximo ano não disponível no select.");
             return; // Para a navegação
         }
    }

    yearSelect.value = year;
    monthSelect.value = month;
    updateMonthlyAnalysis();
}


// Atualizar conteúdo da aba de Categorias
function updateCategoriesTab() {
    const incomeContainer = document.getElementById('income-categories-list');
    const expenseContainer = document.getElementById('expense-categories-list');
    if (!incomeContainer || !expenseContainer) return;

    // Separa e ordena categorias
    const incomeCategories = categories.filter(c => c.type === 'income').sort((a, b) => a.name.localeCompare(b.name));
    const expenseCategories = categories.filter(c => c.type === 'expense').sort((a, b) => a.name.localeCompare(b.name));

    // Função auxiliar para renderizar lista de categorias
    const renderCategoryList = (container, categoryList, type) => {
        container.innerHTML = ''; // Limpa
        if (categoryList.length === 0) {
             container.innerHTML = `<div style="text-align: center; padding: 2rem 0; color: var(--text-secondary);">Nenhuma categoria de ${type === 'income' ? 'receita' : 'despesa'} encontrada.</div>`;
        } else {
            categoryList.forEach(category => {
                const item = document.createElement('div');
                item.className = 'category-item';
                item.innerHTML = `
                    <div class="category-item-color" style="background-color: ${category.color}; font-size: 1.1rem;">
                        ${category.icon}
                    </div>
                    <div class="category-item-info">
                        <div style="font-weight: 500;">${category.name}</div>
                        <!-- Poderíamos adicionar contagem de transações aqui se necessário -->
                    </div>
                    <div class="category-item-actions">
                        <button class="table-action-btn btn-edit" title="Editar" aria-label="Editar categoria ${category.name}">
                             <svg width="16" height="16" viewBox="0 0 24 24"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>
                        </button>
                        <button class="table-action-btn btn-delete" title="Excluir" aria-label="Excluir categoria ${category.name}">
                             <svg width="16" height="16" viewBox="0 0 24 24"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
                        </button>
                    </div>
                `;
                 // Adiciona listeners
                 item.querySelector('.btn-edit').addEventListener('click', () => openCategoryModal(category));
                 item.querySelector('.btn-delete').addEventListener('click', () => confirmDeleteCategory(category.id));
                 container.appendChild(item);
            });
        }
    };

    renderCategoryList(incomeContainer, incomeCategories, 'income');
    renderCategoryList(expenseContainer, expenseCategories, 'expense');
}


// Atualizar conteúdo da aba de Relatórios
function updateReportsTab() {
    // Garante que os selects de mês/ano estejam populados (pode ser redundante, mas seguro)
    // populateYearSelects(); // Chamado na inicialização
    // populateMonthSelects(); // Chamado na inicialização

    // Define o mês/ano atual como padrão nos selects do relatório se não tiverem valor
    const reportMonthSelect = document.getElementById('report-month');
    const reportYearSelect = document.getElementById('report-year');
    if (reportMonthSelect && !reportMonthSelect.value) {
        reportMonthSelect.value = new Date().getMonth();
    }
    if (reportYearSelect && !reportYearSelect.value) {
         reportYearSelect.value = new Date().getFullYear();
    }

    // Gera o relatório para o período selecionado
    generateMonthlyReport();
    // Atualiza o gráfico de análise (que também tem seu próprio filtro)
    updateAnalysisChart();
}


// Gerar o conteúdo do relatório mensal na aba Relatórios
function generateMonthlyReport() {
    const reportContainer = document.getElementById('monthly-report-container');
    const monthSelect = document.getElementById('report-month');
    const yearSelect = document.getElementById('report-year');
    if (!reportContainer || !monthSelect || !yearSelect) return;

    const monthIndex = parseInt(monthSelect.value);
    const year = parseInt(yearSelect.value);
    const months = moment.months(); // Nomes completos dos meses

    if (isNaN(monthIndex) || isNaN(year)) {
        reportContainer.innerHTML = `<div style="text-align: center; padding: 2rem 0; color: var(--text-secondary);">Selecione um mês e ano válidos.</div>`;
        return;
    }

     reportContainer.innerHTML = `<div style="text-align: center; padding: 2rem 0; color: var(--text-secondary);">Gerando relatório para ${months[monthIndex]} de ${year}...</div>`;


    // Usa setTimeout para permitir que o feedback "Gerando..." apareça antes do processamento pesado
    setTimeout(() => {
        const monthTransactions = filterTransactions({ year, month: monthIndex });
        const summary = getFinanceSummary(monthTransactions);
        const expensesByCategory = getExpensesByCategory(monthTransactions);

        // Ordena categorias por valor descrescente
        const sortedCategoryEntries = Object.entries(expensesByCategory)
            .filter(([, amount]) => amount > 0)
            .sort(([, a], [, b]) => b - a);

        if (monthTransactions.length === 0) {
             reportContainer.innerHTML = `<div style="text-align: center; padding: 2rem 0; color: var(--text-secondary);">Nenhuma transação encontrada para ${months[monthIndex]} de ${year}.</div>`;
             // Limpa o canvas do gráfico se não houver dados
             const pieCtx = document.getElementById('report-pie-chart')?.getContext('2d');
             if(pieCtx) {
                 reportPieChart = destroyChart(reportPieChart);
                 pieCtx.clearRect(0, 0, pieCtx.canvas.width, pieCtx.canvas.height);
             }
             return;
        }

        // Constrói o HTML do relatório
        let categoryDetailsHtml = '';
        if (sortedCategoryEntries.length > 0) {
            categoryDetailsHtml = sortedCategoryEntries.map(([id, amount]) => {
                const category = categories.find(c => c.id === id) || { name: '?', color: '#ccc', icon: '?' };
                const percentage = summary.expenses > 0 ? (amount / summary.expenses * 100).toFixed(1) : 0;
                return `
                    <div class="report-category-item">
                        <span style="display: flex; align-items: center; gap: 0.5rem;">
                           <span style="width: 1rem; height: 1rem; font-size: 0.75rem; border-radius: 50%; background-color: ${category.color}; display: flex; align-items: center; justify-content: center; color: white; flex-shrink: 0;">${category.icon}</span>
                           ${category.name}
                        </span>
                        <span>${formatCurrency(amount)} (${percentage}%)</span>
                    </div>
                `;
            }).join('');
        } else {
            categoryDetailsHtml = '<p style="color: var(--text-secondary); font-size: 0.9rem;">Nenhuma despesa registrada neste período.</p>';
        }

        reportContainer.innerHTML = `
            <style>
                .report-summary-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem; margin-bottom: 1.5rem; text-align: center; }
                .report-summary-item > div:first-child { color: var(--text-secondary); margin-bottom: 0.5rem; font-size: 0.9rem; }
                .report-summary-item > div:last-child { font-size: 1.3rem; font-weight: 600; }
                .report-category-item { display: flex; justify-content: space-between; padding: 0.5rem 0; border-bottom: 1px solid var(--border); font-size: 0.9rem; }
                .report-category-item:last-child { border-bottom: none; }
            </style>
            <div class="card" style="padding: 1.5rem;">
                <h3 style="margin-top: 0; margin-bottom: 1.5rem; font-size: 1.25rem;">Relatório Mensal - ${months[monthIndex]} ${year}</h3>
                <div class="report-summary-grid">
                    <div class="report-summary-item">
                        <div>Receitas</div>
                        <div style="color: var(--success);">${formatCurrency(summary.income)}</div>
                    </div>
                    <div class="report-summary-item">
                        <div>Despesas</div>
                        <div style="color: var(--danger);">${formatCurrency(summary.expenses)}</div>
                    </div>
                    <div class="report-summary-item">
                        <div>Saldo Final</div>
                        <div style="color: ${summary.balance >= 0 ? 'var(--success)' : 'var(--danger)'};">${formatCurrency(summary.balance)}</div>
                    </div>
                </div>

                <h4 style="margin-top: 2rem; margin-bottom: 1rem; font-size: 1.1rem; border-bottom: 1px solid var(--border); padding-bottom: 0.5rem;">Detalhamento de Despesas</h4>
                ${categoryDetailsHtml}

                 <div style="margin-top: 2rem;">
                     <h4 style="margin-bottom: 1rem; font-size: 1.1rem;">Visualização das Despesas</h4>
                     <div style="position: relative; height: 280px;">
                         <canvas id="report-pie-chart"></canvas>
                     </div>
                 </div>
            </div>
        `;

        // Renderiza o gráfico de pizza APÓS o HTML ser inserido no DOM
        updateReportPieChart();

    }, 50); // Pequeno delay para UI atualizar
}


// Exportar relatório mensal (Simulação - Cria CSV)
function exportMonthlyReport() {
    const monthIndex = parseInt(document.getElementById('report-month').value);
    const year = parseInt(document.getElementById('report-year').value);
     const months = moment.months();
     if (isNaN(monthIndex) || isNaN(year)) {
         showAlert('Selecione mês e ano para exportar.', 'warning');
         return;
     }

     const monthTransactions = filterTransactions({ year, month: monthIndex });

     if (monthTransactions.length === 0) {
         showAlert(`Nenhuma transação para exportar em ${months[monthIndex]} de ${year}.`, 'info');
         return;
     }

     // Cria cabeçalho CSV
     let csvContent = "data:text/csv;charset=utf-8,";
     csvContent += "Data,Tipo,Descricao,Categoria,Valor,Status,FormaPagamento,Notas\r\n";

     // Adiciona linhas de dados
     monthTransactions.forEach(t => {
         const categoryName = categories.find(c => c.id === t.category)?.name || t.category;
         const statusName = TRANSACTION_STATUS[t.status]?.name || t.status;
         const paymentMethodName = PAYMENT_METHODS[t.paymentMethod] || t.paymentMethod || '';
         // Escapa vírgulas e aspas na descrição e notas
         const descriptionEscaped = `"${(t.description || '').replace(/"/g, '""')}"`;
         const notesEscaped = `"${(t.notes || '').replace(/"/g, '""')}"`;

         const row = [
             formatDate(t.date),
             t.type === 'income' ? 'Receita' : 'Despesa',
             descriptionEscaped,
             `"${categoryName.replace(/"/g, '""')}"`, // Escapa nome da categoria também
             t.amount.toFixed(2), // Formato numérico simples para CSV
             statusName,
             paymentMethodName,
             notesEscaped
         ].join(",");
         csvContent += row + "\r\n";
     });

     // Cria link para download
     const encodedUri = encodeURI(csvContent);
     const link = document.createElement("a");
     link.setAttribute("href", encodedUri);
     link.setAttribute("download", `relatorio_${year}_${String(monthIndex + 1).padStart(2, '0')}.csv`);
     document.body.appendChild(link); // Necessário para Firefox
     link.click();
     document.body.removeChild(link);

     showAlert(`Relatório de ${months[monthIndex]} ${year} exportado como CSV!`, 'success');
}

// ===== Lógica Principal da Aplicação (Continued) =====

// Atualizar todo o dashboard (chamado após mudanças de dados ou filtros principais)
async function updateDashboard() {
    console.log("Atualizando dashboard...");
    showLoading(); // Mostra loading geral

    try {
        // 1. Atualiza os KPIs principais
        updateKPIs();

        // 2. Atualiza a lista de transações recentes (se na Visão Geral)
        if (currentTab === 'overview') {
            updateRecentTransactions();
        }

        // 3. Atualiza os gráficos principais (Visão Geral e outros que dependem dos filtros globais)
        // Algumas funções de gráfico já são chamadas por updateKPIs ou outras atualizações de UI,
        // mas chamar updateCharts() garante que todos sejam atualizados consistentemente.
        await updateCharts(); // É async por causa do updateBudgetChart

        // 4. Atualiza o conteúdo da tab ATUAL, se ela tiver uma função de atualização específica
        //    que precise ser chamada além das atualizações gerais.
        switch (currentTab) {
            case 'transactions':
                updateTransactionsTable(); // Já considera seus próprios filtros
                break;
            case 'budget':
                await updateBudgetTab(); // Atualiza gráfico e tabela de orçamento
                break;
            case 'goals':
                updateGoalsTab(); // Atualiza lista de metas
                break;
            case 'monthly':
                updateMonthlyAnalysis(); // Atualiza resumos, gráficos e listas do mês
                break;
            case 'categories':
                updateCategoriesTab(); // Atualiza listas de categorias
                break;
             case 'reports':
                 updateReportsTab(); // Atualiza conteúdo do relatório e gráfico de análise
                 break;
            // 'overview' é atualizado por KPIs, Recentes e Gráficos gerais.
        }

         console.log("Dashboard atualizado.");
    } catch (error) {
        console.error("Erro ao atualizar dashboard:", error);
        showAlert("Ocorreu um erro ao atualizar os dados.", "danger");
    } finally {
        hideLoading(); // Esconde loading geral
    }
}


// ===== Inicialização da Aplicação =====

// Função principal de inicialização
async function init() {
    console.log("Iniciando aplicação...");
    showLoading(); // Mostra loading inicial

    try {
        // 1. Configura o tema visual (light/dark)
        setupTheme();
        console.log("Tema configurado.");

        // 2. Espera o Firebase estar pronto (definido na Parte 1)
        await waitForFirebase();
        console.log("Firebase pronto.");

        // 3. Carrega dados essenciais do Firestore
        //    Ordem importa: Categorias primeiro, depois transações, etc.
        console.log("Carregando categorias...");
        categories = await loadCategoriesFromFirestore();
        console.log(`${categories.length} categorias carregadas.`);

        console.log("Carregando transações...");
        transactions = await loadTransactionsFromFirestore();
         console.log(`${transactions.length} transações carregadas.`);

        console.log("Carregando orçamentos...");
        budgets = await loadBudgetsFromFirestore();
        console.log(`${budgets.length} orçamentos carregados.`);

        console.log("Carregando metas...");
        goals = await loadGoalsFromFirestore();
        console.log(`${goals.length} metas carregadas.`);

        // 4. Popula os selects de ano e mês nos filtros e modais
        populateYearSelects();
        populateMonthSelects();
        console.log("Selects de data populados.");

        // 5. Inicializa os filtros e seus listeners
        initFilters();
        console.log("Filtros inicializados.");

        // 6. Inicializa os modais e seus listeners
        initModals();
        console.log("Modais inicializados.");

        // 7. Inicializa a navegação por tabs
        initTabs(); // Isso também ativa a primeira tab (overview)
        console.log("Tabs inicializadas.");

        // 8. Inicializa todos os gráficos
        await initCharts(); // É async
        console.log("Gráficos inicializados.");

        // 9. Realiza a primeira atualização completa do dashboard com os dados carregados
        //    (A ativação da tab 'overview' por initTabs() já chama updateDashboard indiretamente,
        //     mas uma chamada explícita aqui garante a atualização inicial)
        // await updateDashboard(); // Removido pois initTabs já dispara a atualização inicial

        console.log("Aplicação inicializada com sucesso!");

    } catch (error) {
        console.error("Erro crítico durante a inicialização:", error);
        showAlert("Falha ao carregar a aplicação. Verifique a conexão ou o console.", "danger");
        // Poderia mostrar uma mensagem de erro mais proeminente na tela aqui
    } finally {
        hideLoading(); // Garante que o loading seja escondido mesmo se houver erro
    }
}

// ----- Ponto de Entrada da Aplicação -----
// Adiciona o listener para iniciar tudo quando o HTML estiver pronto.
document.addEventListener('DOMContentLoaded', init);
