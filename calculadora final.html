<!DOCTYPE html>
<html lang="pt-BR" data-theme="light">
<head>
  <!-- =================================================================== -->
  <!-- CHECKLIST DE DESENVOLVIMENTO - APP GESTÃO FINANCEIRA -->
  <!-- =================================================================== -->
  <!--
   * CHECKLIST COMPLETO DE TAREFAS (12 TOTAL):
   * 
   * (A) Migração e Reestruturação Visual (Base):
   * ✅ A1. Estruturar o HTML base do projeto seguindo exatamente o Mockup.html.
   * ✅ A2. Aplicar todo o CSS (estilos, fontes, cores, layout responsivo) definido no Mockup.html.
   * ✅ A3. Migrar e adaptar a lógica JavaScript do codigo completo.txt.
   * 
   * (B) Novas Funcionalidades e Correções:
   * ✅ B1. Campo "Pessoas": Adicionar campo ao formulário de despesas.
   * ✅ B2. Gerenciamento de Pessoas: Criar interface e lógica.
   * ✅ B3. Novo Gráfico (Fixas vs. Variáveis).
   * ✅ B4. Posicionamento Novo Gráfico ao lado do existente.
   * ✅ B5. Seção "Investimentos": Criar nova seção/tela.
   * ✅ B6. Cadastro em Investimentos: Implementar CRUD de categorias.
   * ✅ B7. Filtro por "Pessoas" na lista de transações.
   * ✅ B8. Análise por Pessoa: Implementar KPI ou Gráfico.
   * ✅ B9. Correção Bug Categorias: Listar todas imediatamente.
   *
   * PROGRESSO: 12/12 tarefas concluídas (100%)
   * APLICAÇÃO CONCLUÍDA
   -->
  
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Gestão Financeira da Família - Controle financeiro com estilo Apple">
  <title>Gestão Financeira da Família</title>
  
  <!-- Fonte Inter via Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  
  <!-- Scripts CDN: Chart.js 4 -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  
  <!-- Scripts CDN: Firebase v9 compat -->
  <script src="https://www.gstatic.com/firebasejs/9.10.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.10.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.10.0/firebase-auth-compat.js"></script>
  
  <style>
    /* Design-tokens em :root */
    :root {
      /* Cores neutras */
      --color-background: #ffffff;
      --color-surface: #f5f5f7;
      --color-surface-variant: #e8e8ed;
      --color-on-surface: #1d1d1f;
      --color-on-surface-variant: #86868b;
      --color-outline: #d2d2d7;
      
      /* Cores semânticas */
      --color-primary: #007AFF;
      --color-on-primary: #ffffff;
      --color-success: #34c759;
      --color-on-success: #ffffff;
      --color-warning: #ff9500;
      --color-on-warning: #ffffff;
      --color-error: #ff3b30;
      --color-on-error: #ffffff;
      --color-info: #007aff;
      --color-on-info: #ffffff;
      
      /* Cores para receitas e despesas */
      --color-income: #34c759;
      --color-expense: #ff3b30;
      
      /* Cores de cartões */
      --color-card-blue: #007aff;
      --color-card-green: #34c759;
      --color-card-orange: #ff9500;
      --color-card-red: #ff3b30;
      --color-card-purple: #af52de;
      --color-card-invoice: #FFD700; /* Cor amarelo ouro para fatura */
      
      /* Tipografia */
      --font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      --font-size-xs: 0.75rem;
      --font-size-sm: 0.875rem;
      --font-size-md: 1rem;
      --font-size-lg: 1.125rem;
      --font-size-xl: 1.25rem;
      --font-size-2xl: 1.5rem;
      --font-size-3xl: 1.875rem;
      --font-size-4xl: 2.25rem;
      --font-weight-light: 300;
      --font-weight-regular: 400;
      --font-weight-medium: 500;
      --font-weight-semibold: 600;
      --font-weight-bold: 700;
      
      /* Espaçamento */
      --spacing-2xs: 0.25rem;
      --spacing-xs: 0.5rem;
      --spacing-sm: 0.75rem;
      --spacing-md: 1rem;
      --spacing-lg: 1.5rem;
      --spacing-xl: 2rem;
      --spacing-2xl: 3rem;
      
      /* Bordas e raios */
      --radius-sm: 0.5rem;
      --radius-md: 0.75rem;
      --radius-lg: 1rem;
      --radius-xl: 1.5rem;
      --radius-full: 9999px;
      
      /* Sombras */
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
      --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.05), 0 1px 3px rgba(0, 0, 0, 0.1);
      --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.05), 0 4px 6px rgba(0, 0, 0, 0.05);
      
      /* Animações */
      --transition-fast: 0.15s cubic-bezier(0.4, 0, 0.2, 1);
      --transition-normal: 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      --transition-slow: 0.35s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    /* Tema escuro */
    [data-theme="dark"] {
      --color-background: #000000;
      --color-surface: #1c1c1e;
      --color-surface-variant: #2c2c2e;
      --color-on-surface: #f5f5f7;
      --color-on-surface-variant: #8e8e93;
      --color-outline: #38383a;
      color: var(--color-on-surface);
    }
    
    /* Reset básico */
    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    html, body {
      height: 100%;
      font-family: var(--font-family);
      background-color: var(--color-background);
      color: var(--color-on-surface);
      font-size: var(--font-size-md);
      line-height: 1.5;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      transition: background-color var(--transition-normal), color var(--transition-normal);
    }
    
    img, picture, video, canvas, svg {
      display: block;
      max-width: 100%;
    }
    
    input, button, textarea, select {
      font: inherit;
      color: inherit;
    }
    
    button {
      background: none;
      border: none;
      cursor: pointer;
    }
    
    a {
      color: inherit;
      text-decoration: none;
    }
    
    table {
      border-collapse: collapse;
      width: 100%;
    }

    /* Layout principal */
    .container {
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
      padding: var(--spacing-md);
    }
  
    /* Header */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--spacing-md) 0;
      margin-bottom: var(--spacing-xl);
      position: sticky;
      top: 0;
      background-color: var(--color-background);
      z-index: 100;
      transition: background-color var(--transition-normal);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--color-outline);
    }
    
    .header-filters {
      display: flex;
      gap: var(--spacing-md);
      align-items: center;
    }
    
    .header-actions {
      display: flex;
      gap: var(--spacing-md);
      align-items: center;
    }
    
    /* Título principal do app */
    .app-title {
      font-size: var(--font-size-2xl);
      font-weight: var(--font-weight-semibold);
      letter-spacing: -0.02em;
      margin-bottom: var(--spacing-md);
    }
    
    .hero {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      text-align: left;
      padding: 40px 0;
      margin-bottom: 20px;
    }
    
    .hero-title {
      font-size: var(--font-size-3xl);
      font-weight: var(--font-weight-semibold);
      letter-spacing: -0.03em;
      margin-bottom: var(--spacing-md);
      line-height: 1.1;
    }
    
    .hero-subtitle {
      font-size: var(--font-size-lg);
      color: var(--color-on-surface-variant);
      margin-bottom: var(--spacing-xl);
      max-width: 600px;
    }
    
    /* Área de KPIs */
    .kpi-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: var(--spacing-lg);
      margin-bottom: var(--spacing-xl);
    }
    
    /* Insights banner */
    .insights-banner {
      margin-bottom: var(--spacing-xl);
      border-radius: var(--radius-lg);
      overflow: hidden;
    }
    
    /* Gráficos */
    .charts-container {
      margin-bottom: var(--spacing-2xl);
    }
    
    .charts-title {
      font-size: var(--font-size-xl);
      font-weight: var(--font-weight-semibold);
      margin-bottom: var(--spacing-lg);
    }
    
    .charts-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: var(--spacing-xl);
      margin-bottom: var(--spacing-xl);
    }
    
    .chart-container {
      position: relative;
      height: 340px;
      border-radius: var(--radius-lg);
      background-color: var(--color-surface);
      padding: var(--spacing-md);
      box-shadow: var(--shadow-sm);
      transition: transform var(--transition-normal), box-shadow var(--transition-normal);
      overflow: hidden;
    }
    
    .chart-container:hover {
      transform: translateY(-4px);
      box-shadow: var(--shadow-md);
    }
    
    .chart-container h3 {
      font-weight: var(--font-weight-semibold);
      font-size: var(--font-size-lg);
      margin-bottom: var(--spacing-md);
    }
    
    /* Compromissos longos */
    .commitments {
      margin-bottom: var(--spacing-xl);
      background-color: var(--color-surface);
      border-radius: var(--radius-lg);
      padding: var(--spacing-md);
      box-shadow: var(--shadow-sm);
      margin-top: var(--spacing-2xl); /* Espaço extra no topo para separar do gráfico */
      transition: transform var(--transition-normal), box-shadow var(--transition-normal);
    }
    
    .commitments:hover {
      transform: translateY(-4px);
      box-shadow: var(--shadow-md);
    }
    
    .commitments-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--spacing-md);
      cursor: pointer;
      padding: var(--spacing-sm) var(--spacing-md);
      border-radius: var(--radius-md);
      transition: background-color var(--transition-normal);
    }
    
    .commitments-header:hover {
      background-color: var(--color-surface-variant);
    }
    
    .commitments-header h3 {
      font-weight: var(--font-weight-semibold);
      font-size: var(--font-size-lg);
    }
    
    .commitments-content {
      overflow: hidden;
      transition: max-height var(--transition-normal);
      max-height: 0;
    }
    
    .commitment-item {
      display: flex;
      align-items: center;
      gap: var(--spacing-md);
      padding: var(--spacing-md);
      border-radius: var(--radius-md);
      margin-bottom: var(--spacing-sm);
      background-color: var(--color-surface-variant);
    }
    
    .commitment-progress {
      width: 100%;
      height: 8px;
      background-color: var(--color-surface);
      border-radius: var(--radius-full);
      overflow: hidden;
    }
    
    .commitment-progress-bar {
      height: 100%;
      border-radius: var(--radius-full);
      transition: width var(--transition-normal);
    }
    
    /* Tabela de transações */
    .transactions-container {
      margin-bottom: var(--spacing-2xl);
    }
    
    .card-transacoes {
      background-color: var(--color-surface);
      border-radius: var(--radius-lg);
      padding: var(--spacing-lg);
      box-shadow: var(--shadow-sm);
      display: flex;
      flex-direction: column;
      gap: var(--spacing-md);
      margin-bottom: var(--spacing-xl);
      transition: transform var(--transition-normal), box-shadow var(--transition-normal);
    }
    
    .card-transacoes:hover {
      transform: translateY(-4px);
      box-shadow: var(--shadow-md);
    }
    
    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: var(--spacing-md);
      margin-bottom: var(--spacing-md);
    }
    
    .card-title {
      font-size: var(--font-size-xl);
      font-weight: var(--font-weight-semibold);
      margin: 0;
    }
    
    .filters {
      display: flex;
      gap: var(--spacing-md);
      flex-wrap: wrap;
    }
    
    .transactions-table-container {
      background-color: var(--color-surface);
      border-radius: var(--radius-lg);
      overflow: hidden;
    }
    
    .transactions-table {
      width: 100%;
      background-color: var(--color-surface);
      border-radius: var(--radius-lg);
      overflow: hidden;
      box-shadow: var(--shadow-sm);
    }
    
    .transactions-table th {
      text-align: left;
      padding: var(--spacing-md);
      font-weight: var(--font-weight-medium);
      color: var(--color-on-surface-variant);
      background-color: var(--color-surface);
      position: sticky;
      top: 0;
      z-index: 10;
      white-space: nowrap;
      cursor: pointer;
    }
    
    .transactions-table th.sortable:hover {
      background-color: var(--color-surface-variant);
    }
    
    .transactions-table td {
      padding: var(--spacing-md);
      border-top: 1px solid var(--color-outline);
    }
    
    .transactions-table tr:hover {
      background-color: var(--color-surface-variant);
    }
    
    .transaction-icon {
      display: inline-flex;
      justify-content: center;
      align-items: center;
      width: 2.5rem;
      height: 2.5rem;
      border-radius: var(--radius-full);
      background-color: var(--color-surface-variant);
    }
    
    .actions-cell {
      display: flex;
      gap: var(--spacing-xs);
      justify-content: flex-end;
    }
    
    /* Componentes */
    /* Botões */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: var(--spacing-xs);
      padding: var(--spacing-xs) var(--spacing-md);
      border-radius: var(--radius-full);
      font-weight: var(--font-weight-medium);
      transition: all var(--transition-normal);
      white-space: nowrap;
      border: none;
      min-height: 36px;
    }
    
    .btn-primary {
      background-color: var(--color-primary);
      color: var(--color-on-primary);
    }
    
    .btn-primary:hover {
      opacity: 0.9;
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .btn-primary:active {
      transform: translateY(0);
      box-shadow: none;
    }
    
    .btn-success {
      background-color: var(--color-success);
      color: var(--color-on-success);
    }
    
    .btn-success:hover {
      opacity: 0.9;
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .btn-success:active {
      transform: translateY(0);
      box-shadow: none;
    }
    
    .btn-danger {
      background-color: var(--color-error);
      color: var(--color-on-error);
    }
    
    .btn-danger:hover {
      opacity: 0.9;
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .btn-danger:active {
      transform: translateY(0);
      box-shadow: none;
    }
    
    .btn-outline {
      border: 1px solid var(--color-outline);
      background-color: transparent;
      color: var(--color-primary);
    }
    
    .btn-outline:hover {
      background-color: var(--color-surface-variant);
      border-color: var(--color-primary);
    }
    
    .btn-icon {
      width: 36px;
      height: 36px;
      padding: 0;
      border-radius: var(--radius-full);
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    
    /* Select personalizado */
    .select-wrapper {
      position: relative;
      display: inline-block;
    }
    
    .select {
      appearance: none;
      -webkit-appearance: none;
      padding: var(--spacing-xs) var(--spacing-xl) var(--spacing-xs) var(--spacing-md);
      border-radius: var(--radius-full);
      border: 1px solid var(--color-outline);
      background-color: var(--color-surface);
      cursor: pointer;
      transition: border-color var(--transition-normal), box-shadow var(--transition-normal);
      font-size: var(--font-size-sm);
    }
    
    .select:focus {
      outline: none;
      border-color: var(--color-primary);
      box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.2);
    }
    
    .select:hover {
      border-color: var(--color-primary);
    }
    
    .select-icon {
      position: absolute;
      right: var(--spacing-md);
      top: 50%;
      transform: translateY(-50%);
      pointer-events: none;
      color: var(--color-on-surface-variant);
    }
    
    /* Cards */
    .card {
      background-color: var(--color-surface);
      border-radius: var(--radius-lg);
      padding: var(--spacing-md);
      box-shadow: var(--shadow-sm);
      transition: transform var(--transition-normal), box-shadow var(--transition-normal);
    }
    
    .card:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }
    
    /* KPI Cards */
    .kpi-card {
      display: flex;
      flex-direction: column;
      background-color: var(--color-surface);
      padding: var(--spacing-md);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-sm);
      transition: transform var(--transition-normal), box-shadow var(--transition-normal);
    }
    
    .kpi-card:hover {
      transform: translateY(-4px);
      box-shadow: var(--shadow-md);
    }
    
    .kpi-title {
      font-size: var(--font-size-sm);
      color: var(--color-on-surface-variant);
      margin-bottom: var(--spacing-xs);
      font-weight: var(--font-weight-medium);
    }
    
    .kpi-value {
      font-size: var(--font-size-2xl);
      font-weight: var(--font-weight-semibold);
      margin-bottom: var(--spacing-xs);
    }
    
    .kpi-subtitle {
      font-size: var(--font-size-xs);
      color: var(--color-on-surface-variant);
      display: flex;
      align-items: center;
      gap: var(--spacing-xs);
    }
    
    .kpi-income {
      border-left: 4px solid var(--color-income);
    }
    
    .kpi-expense {
      border-left: 4px solid var(--color-expense);
    }
    
    .kpi-balance {
      border-left: 4px solid var(--color-primary);
    }
    
    .kpi-card-invoice {
      border-left: 4px solid var(--color-card-invoice);
    }
    
    /* Insights */
    .insight-banner {
      display: flex;
      align-items: center;
      gap: var(--spacing-md);
      padding: var(--spacing-md);
      border-radius: var(--radius-lg);
      margin-bottom: var(--spacing-md);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    
    .insight-icon {
      font-size: 1.5rem;
    }
    
    .insight-content {
      flex: 1;
    }
    
    .insight-title {
      font-weight: var(--font-weight-medium);
      margin-bottom: var(--spacing-2xs);
    }
    
    .insight-danger {
      background-color: rgba(255, 59, 48, 0.1);
      border-left: 4px solid var(--color-error);
    }
    
    .insight-warning {
      background-color: rgba(255, 149, 0, 0.1);
      border-left: 4px solid var(--color-warning);
    }
    
    .insight-info {
      background-color: rgba(0, 122, 255, 0.1);
      border-left: 4px solid var(--color-info);
    }
    
    .insight-success {
      background-color: rgba(52, 199, 89, 0.1);
      border-left: 4px solid var(--color-success);
    }
    
    /* Badge */
    .badge {
      display: inline-block;
      padding: var(--spacing-2xs) var(--spacing-xs);
      border-radius: var(--radius-full);
      font-size: var(--font-size-xs);
      font-weight: var(--font-weight-medium);
    }
    
    .badge-success {
      background-color: rgba(52, 199, 89, 0.1);
      color: var(--color-success);
    }
    
    .badge-warning {
      background-color: rgba(255, 149, 0, 0.1);
      color: var(--color-warning);
    }
    
    .badge-danger {
      background-color: rgba(255, 59, 48, 0.1);
      color: var(--color-error);
    }
    
    .badge-info {
      background-color: rgba(0, 122, 255, 0.1);
      color: var(--color-info);
    }
    
    /* Modais */
    .modal-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: opacity var(--transition-normal), visibility var(--transition-normal);
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
    }
    
    .modal-backdrop.active {
      opacity: 1;
      visibility: visible;
    }
    
    .modal {
      width: 90%;
      max-width: 500px;
      background-color: var(--color-surface);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-lg);
      opacity: 0;
      transform: translateY(20px) scale(0.98);
      transition: opacity var(--transition-normal), transform var(--transition-normal);
    }
    
    .modal-backdrop.active .modal {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
    
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--spacing-md) var(--spacing-lg);
      border-bottom: 1px solid var(--color-outline);
    }
    
    .modal-title {
      font-size: var(--font-size-xl);
      font-weight: var(--font-weight-semibold);
    }
    
    .modal-close {
      font-size: var(--font-size-xl);
      color: var(--color-on-surface-variant);
      cursor: pointer;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: var(--radius-full);
      transition: background-color var(--transition-normal);
    }
    
    .modal-close:hover {
      background-color: var(--color-surface-variant);
    }
    
    .modal-body {
      padding: var(--spacing-lg);
      max-height: 70vh;
      overflow-y: auto;
    }
    
    .modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: var(--spacing-md);
      padding: var(--spacing-md) var(--spacing-lg);
      border-top: 1px solid var(--color-outline);
    }
    
    /* Toast */
    .toast-container {
      position: fixed;
      top: var(--spacing-md);
      right: var(--spacing-md);
      z-index: 2000;
    }
    
    .toast {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      background-color: var(--color-surface);
      border-radius: var(--radius-md);
      padding: var(--spacing-md);
      margin-bottom: var(--spacing-md);
      box-shadow: var(--shadow-md);
      min-width: 300px;
      max-width: 400px;
      transform: translateX(120%);
      transition: transform var(--transition-normal);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    
    .toast.show {
      transform: translateX(0);
    }
    
    .toast-icon {
      font-size: 1.5rem;
    }
    
    .toast-content {
      flex: 1;
    }
    
    .toast-close {
      font-size: var(--font-size-lg);
      color: var(--color-on-surface-variant);
      cursor: pointer;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: var(--radius-full);
      transition: background-color var(--transition-normal);
    }
    
    .toast-close:hover {
      background-color: var(--color-surface-variant);
    }
    
    .toast-success {
      border-left: 4px solid var(--color-success);
    }
    
    .toast-error {
      border-left: 4px solid var(--color-error);
    }
    
    .toast-warning {
      border-left: 4px solid var(--color-warning);
    }
    
    .toast-info {
      border-left: 4px solid var(--color-info);
    }
    
    /* Inputs */
    .form-group {
      margin-bottom: var(--spacing-md);
    }
    
    .form-label {
      display: block;
      font-size: var(--font-size-sm);
      color: var(--color-on-surface-variant);
      margin-bottom: var(--spacing-xs);
      font-weight: var(--font-weight-medium);
    }
    
    .form-control {
      width: 100%;
      padding: var(--spacing-xs) var(--spacing-md);
      border-radius: var(--radius-md);
      border: 1px solid var(--color-outline);
      background-color: var(--color-surface);
      transition: border-color var(--transition-normal), box-shadow var(--transition-normal);
    }
    
    .form-control:focus {
      outline: none;
      border-color: var(--color-primary);
      box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.2);
    }
    
    .form-control:hover:not(:focus) {
      border-color: var(--color-primary);
    }
    
    /* Radio buttons */
    .radio-group {
      display: flex;
      gap: var(--spacing-md);
      margin-bottom: var(--spacing-md);
      flex-wrap: wrap;
    }
    
    .radio-wrapper {
      position: relative;
    }
    
    .radio {
      position: absolute;
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    .radio-label {
      display: inline-flex;
      align-items: center;
      gap: var(--spacing-xs);
      padding: var(--spacing-xs) var(--spacing-md);
      border-radius: var(--radius-full);
      border: 1px solid var(--color-outline);
      cursor: pointer;
      transition: all var(--transition-normal);
    }
    
    .radio:checked + .radio-label {
      border-color: var(--color-primary);
      background-color: rgba(0, 122, 255, 0.1);
    }
    
    .radio-circle {
      display: inline-block;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 1px solid var(--color-outline);
      position: relative;
    }
    
    .radio:checked + .radio-label .radio-circle:after {
      content: '';
      position: absolute;
      top: 3px;
      left: 3px;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background-color: var(--color-primary);
    }
    
    /* Checkbox personalizado */
    .checkbox-wrapper {
      position: relative;
      display: inline-block;
    }
    
    .checkbox {
      position: absolute;
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    .checkbox-label {
      display: inline-block;
      width: 20px;
      height: 20px;
      border-radius: var(--radius-sm);
      border: 1px solid var(--color-outline);
      background-color: var(--color-surface);
      cursor: pointer;
      transition: all var(--transition-normal);
    }
    
    .checkbox:checked + .checkbox-label {
      background-color: var(--color-primary);
      border-color: var(--color-primary);
    }
    
    .checkbox:checked + .checkbox-label:after {
      content: '';
      position: absolute;
      left: 7px;
      top: 3px;
      width: 6px;
      height: 10px;
      border: solid white;
      border-width: 0 2px 2px 0;
      transform: rotate(45deg);
    }
    
    /* Tema Toggle */
    .theme-toggle {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
      border-radius: var(--radius-full);
      cursor: pointer;
      background-color: var(--color-surface-variant);
      transition: background-color var(--transition-normal);
    }
    
    .theme-toggle:hover {
      background-color: var(--color-outline);
    }
    
    .theme-toggle .icon-sun,
    .theme-toggle .icon-moon {
      width: 20px;
      height: 20px;
      color: var(--color-on-surface-variant);
    }
    
    /* Esconder o ícone não ativo */
    [data-theme="light"] .theme-toggle .icon-moon {
      display: none;
    }
    
    [data-theme="dark"] .theme-toggle .icon-sun {
      display: none;
    }
    
    /* Investimentos */
    .investment-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: var(--spacing-lg);
      margin-bottom: var(--spacing-xl);
    }
    
    .investment-card {
      background-color: var(--color-surface);
      border-radius: var(--radius-lg);
      padding: var(--spacing-lg);
      box-shadow: var(--shadow-sm);
      transition: transform var(--transition-normal), box-shadow var(--transition-normal);
      display: flex;
      flex-direction: column;
    }
    
    .investment-card:hover {
      transform: translateY(-4px);
      box-shadow: var(--shadow-md);
    }
    
    .investment-card-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: var(--spacing-md);
    }
    
    .investment-card-title {
      font-size: var(--font-size-xl);
      font-weight: var(--font-weight-semibold);
      margin: 0;
    }
    
    .investment-card-body {
      flex: 1;
      margin-bottom: var(--spacing-md);
    }
    
    .investment-card-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: auto;
    }
    
    .investment-progress {
      margin-top: var(--spacing-md);
    }
    
    .investment-progress-bar {
      height: 8px;
      background-color: var(--color-surface-variant);
      border-radius: var(--radius-full);
      overflow: hidden;
      margin-bottom: var(--spacing-xs);
    }
    
    .investment-progress-fill {
      height: 100%;
      background-color: var(--color-primary);
      border-radius: var(--radius-full);
    }
    
    .investment-progress-text {
      display: flex;
      justify-content: space-between;
      font-size: var(--font-size-sm);
      color: var(--color-on-surface-variant);
    }
    
    .investment-detail {
      margin-bottom: var(--spacing-md);
    }
    
    .investment-detail-header {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: var(--spacing-md);
      margin-bottom: var(--spacing-lg);
    }
    
    .investment-detail-stat {
      background-color: var(--color-surface-variant);
      border-radius: var(--radius-md);
      padding: var(--spacing-md);
    }
    
    .investment-detail-title {
      font-size: var(--font-size-sm);
      color: var(--color-on-surface-variant);
      margin-bottom: var(--spacing-xs);
    }
    
    .investment-detail-value {
      font-size: var(--font-size-lg);
      font-weight: var(--font-weight-semibold);
    }
    
    .investment-history {
      margin-bottom: var(--spacing-lg);
    }
    
    .investment-history-title {
      font-size: var(--font-size-lg);
      font-weight: var(--font-weight-semibold);
      margin-bottom: var(--spacing-md);
    }
    
    .investment-history-table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: var(--spacing-md);
    }
    
    .investment-history-table th {
      text-align: left;
      padding: var(--spacing-sm);
      font-weight: var(--font-weight-medium);
      color: var(--color-on-surface-variant);
      background-color: var(--color-surface);
      border-bottom: 1px solid var(--color-outline);
    }
    
    .investment-history-table td {
      padding: var(--spacing-sm);
      border-bottom: 1px solid var(--color-outline);
    }
    
    /* Gerenciamento de categorias */
    .categories-container {
      padding: var(--spacing-lg);
    }
    
    .nav-tabs {
      display: flex;
      list-style: none;
      padding: 0;
      margin: 0 0 var(--spacing-lg) 0;
      border-bottom: 1px solid var(--color-outline);
    }
    
    .nav-item {
      margin-right: var(--spacing-lg);
    }
    
    .nav-link {
      display: inline-block;
      padding: var(--spacing-sm) 0;
      border-bottom: 2px solid transparent;
      font-weight: var(--font-weight-medium);
      color: var(--color-on-surface-variant);
      transition: all var(--transition-normal);
    }
    
    .nav-link:hover {
      color: var(--color-primary);
    }
    
    .nav-link.active {
      color: var(--color-primary);
      border-bottom-color: var(--color-primary);
    }
    
    .tab-content {
      padding: var(--spacing-md) 0;
    }
    
    .tab-pane {
      display: none;
    }
    
    .tab-pane.active {
      display: block;
    }
    
    .tab-pane.show {
      animation: fadeIn var(--transition-normal);
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    .category-list {
      margin-bottom: var(--spacing-lg);
    }
    
    .category-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--spacing-sm);
      border-radius: var(--radius-md);
      transition: background-color var(--transition-normal);
      margin-bottom: var(--spacing-xs);
    }
    
    .category-item:hover {
      background-color: var(--color-surface-variant);
    }
    
    .category-item-content {
      display: flex;
      align-items: center;
      gap: var(--spacing-md);
    }
    
    .category-item-icon {
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: var(--radius-full);
      background-color: var(--color-surface);
    }
    
    .category-item-actions {
      display: flex;
      gap: var(--spacing-xs);
    }
    
    .add-category-form {
      display: flex;
      align-items: flex-end;
      gap: var(--spacing-sm);
    }
    
    .custom-icon-input {
      display: flex;
      align-items: center;
      gap: var(--spacing-xs);
    }
    
    .custom-icon-preview {
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: var(--color-surface-variant);
      border-radius: var(--radius-full);
    }
    
    /* Responsividade */
    @media (max-width: 992px) {
      .charts-grid {
        grid-template-columns: 1fr 1fr;
      }
    }
    
    @media (max-width: 768px) {
      .header {
        flex-direction: column;
        align-items: flex-start;
        gap: var(--spacing-md);
      }
      
      .header-filters, .header-actions {
        width: 100%;
        justify-content: flex-start;
        flex-wrap: wrap;
        gap: var(--spacing-sm);
      }
      
      .transactions-table {
        display: block;
        overflow-x: auto;
      }
      
      .hero-title {
        font-size: var(--font-size-2xl);
      }
      
      .charts-grid {
        grid-template-columns: 1fr;
      }
      
      .investment-grid {
        grid-template-columns: 1fr;
      }
    }
    
    @media (max-width: 576px) {
      .kpi-grid {
        grid-template-columns: 1fr;
      }
      
      .header-filters {
        flex-direction: column;
        align-items: flex-start;
      }
      
      .add-category-form {
        flex-direction: column;
        align-items: stretch;
      }
      
      .investment-detail-header {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <!-- SVG Sprite de ícones (HeroIcons) -->
  <svg style="display: none;">
    <!-- Ícones de navegação -->
    <symbol id="icon-home" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" />
    </symbol>
    <symbol id="icon-plus" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M12 4v16m8-8H4" />
    </symbol>
    <symbol id="icon-calendar" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
    </symbol>
    <symbol id="icon-chart" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M7 12l3-3 3 3 4-4M8 21l4-4 4 4M3 4h18M4 4h16v12a1 1 0 01-1 1H5a1 1 0 01-1-1V4z" />
    </symbol>
    <symbol id="icon-credit-card" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M3 10h18M7 15h1m4 0h1m-7 4h12a3 3 0 003-3V8a3 3 0 00-3-3H6a3 3 0 00-3 3v8a3 3 0 003 3z" />
    </symbol>
    
    <!-- Ícones de ações -->
    <symbol id="icon-edit" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
    </symbol>
    <symbol id="icon-trash" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
    </symbol>
    <symbol id="icon-check" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
    </symbol>
    <symbol id="icon-x" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
    </symbol>
    <symbol id="icon-chevron-down" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
    </symbol>
    <symbol id="icon-chevron-up" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M5 15l7-7 7 7" />
    </symbol>
    <symbol id="icon-arrow-left" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M10 19l-7-7m0 0l7-7m-7 7h18" />
    </symbol>
    
    <!-- Ícones tema claro/escuro -->
    <symbol id="icon-sun" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
    </symbol>
    <symbol id="icon-moon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
    </symbol>
    
    <!-- Ícones para categorias -->
    <symbol id="icon-shopping" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M16 11V7a4 4 0 00-8 0v4M5 9h14l1 12H4L5 9z" />
    </symbol>
    <symbol id="icon-food" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M3 3h2l.4 2M7 13h10l4-8H5.4M7 13L5.4 5M7 13l-2.293 2.293c-.63.63-.184 1.707.707 1.707H17m0 0a2 2 0 100 4 2 2 0 000-4zm-8 2a2 2 0 11-4 0 2 2 0 014 0z" />
    </symbol>
    <symbol id="icon-home-category" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" />
    </symbol>
    <symbol id="icon-bill" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
    </symbol>
    <symbol id="icon-default" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
    </symbol>
    <symbol id="icon-money" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
    </symbol>
    
    <!-- Ícones para alertas -->
    <symbol id="icon-alert" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
    </symbol>
    <symbol id="icon-info" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
    </symbol>
    <symbol id="icon-settings" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
      <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
    </symbol>
    
    <!-- Ícones para ordenação -->
    <symbol id="icon-sort-asc" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M5 15l7-7 7 7" />
    </symbol>
    <symbol id="icon-sort-desc" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
    </symbol>
  </svg>

  <div class="container">
    <!-- Header -->
    <header class="header">
      <div class="header-filters">
        <div class="select-date-container">
          <div class="select-wrapper">
            <select id="yearSelect" class="select">
              <option value="2023">2023</option>
              <option value="2024">2024</option>
              <option value="2025" selected>2025</option>
              <option value="2026">2026</option>
              <option value="2027">2027</option>
              <option value="2028">2028</option>
              <option value="2029">2029</option>
              <option value="2030">2030</option>
            </select>
            <svg class="select-icon" width="16" height="16">
              <use href="#icon-chevron-down"></use>
            </svg>
          </div>
          
          <div class="select-wrapper">
            <select id="monthSelect" class="select">
              <option value="0">Janeiro</option>
              <option value="1">Fevereiro</option>
              <option value="2">Março</option>
              <option value="3">Abril</option>
              <option value="4" selected>Maio</option>
              <option value="5">Junho</option>
              <option value="6">Julho</option>
              <option value="7">Agosto</option>
              <option value="8">Setembro</option>
              <option value="9">Outubro</option>
              <option value="10">Novembro</option>
              <option value="11">Dezembro</option>
            </select>
            <svg class="select-icon" width="16" height="16">
              <use href="#icon-chevron-down"></use>
            </svg>
          </div>
        </div>
      </div>
      
      <div class="header-actions">
        <!-- Ajuste 5: Reposicionamento do botão de tema -->
        <div id="themeToggle" class="theme-toggle" role="button" aria-label="Alternar tema">
          <svg class="icon-sun" width="20" height="20">
            <use href="#icon-sun"></use>
          </svg>
          <svg class="icon-moon" width="20" height="20">
            <use href="#icon-moon"></use>
          </svg>
        </div>
        
        <button id="newIncomeBtn" class="btn btn-success">
          Nova Receita
        </button>
        
        <button id="newExpenseBtn" class="btn btn-danger">
          Nova Despesa
        </button>
        
        <button id="cardsBtn" class="btn btn-outline">
          <svg width="16" height="16">
            <use href="#icon-credit-card"></use>
          </svg>
          Cartões
        </button>
        
        <button id="categoriesBtn" class="btn btn-outline">
          <svg width="16" height="16">
            <use href="#icon-settings"></use>
          </svg>
          Categorias
        </button>
        
        <button id="investmentsBtn" class="btn btn-outline">
          <svg width="16" height="16">
            <use href="#icon-chart"></use>
          </svg>
          Investimentos
        </button>
      </div>
    </header>
    
    <!-- Hero Section (AJUSTE 1: Texto alterado) -->
    <section class="hero">
      <h1 class="hero-title">Wagner. Bárbara. Joaquim.</h1>
      <p class="hero-subtitle">Porque o futuro que sonhamos começa com o que fazemos hoje.</p>
    </section>
    
    <!-- KPIs -->
    <div class="kpi-grid">
      <div class="kpi-card kpi-balance">
        <div class="kpi-title">Saldo Real (Caixa)</div>
        <div class="kpi-value" id="balanceValue">R$ 0,00</div>
        <div class="kpi-subtitle">
          <svg width="16" height="16">
            <use href="#icon-info"></use>
          </svg>
          <span>Saldo comprometido: R$ 0,00</span>
        </div>
      </div>
      
      <div class="kpi-card kpi-income">
        <div class="kpi-title">Receitas</div>
        <div class="kpi-value" id="incomeValue">R$ 0,00</div>
        <div class="kpi-subtitle">
          <span id="incomeReceivedValue">R$ 0,00 recebidos</span> /
          <span id="incomePendingValue">R$ 0,00 pendentes</span>
        </div>
      </div>
      
      <div class="kpi-card kpi-expense">
        <div class="kpi-title">Despesas</div>
        <div class="kpi-value" id="expenseValue">R$ 0,00</div>
        <div class="kpi-subtitle">
          <span id="expensePaidValue">R$ 0,00 pagos</span> /
          <span id="expensePendingValue">R$ 0,00 pendentes</span>
        </div>
      </div>
      
      <div class="kpi-card kpi-card-invoice">
        <div class="kpi-title">Fatura do Mês</div>
        <div class="kpi-value" id="invoiceValue">R$ 0,00</div>
        <div class="kpi-subtitle">
          <svg width="16" height="16">
            <use href="#icon-credit-card"></use>
          </svg>
          <span>Vencimento: <span id="invoiceDueDate">15/05/2025</span></span>
        </div>
      </div>
    </div>
    
    <!-- Insights Banner -->
    <div class="insights-banner" id="insightsBanner">
      <!-- Insights serão inseridos aqui dinamicamente -->
    </div>
    
    <!-- AJUSTE 7: Reorganização dos gráficos em grade 2x2 -->
    <section class="charts-container">
      <h2 class="charts-title">Resumo Financeiro</h2>
      
      <!-- Primeira linha: Despesas por Categoria e Limite do Cartão -->
      <div class="charts-grid">
        <div class="chart-container">
          <h3>Despesas por Categoria</h3>
          <canvas id="catPie"></canvas>
        </div>
        
        <div class="chart-container">
          <h3>Limite do Cartão</h3>
          <canvas id="cardArea"></canvas>
        </div>
      </div>
      
      <!-- Segunda linha: Despesas Fixas vs Variáveis e Despesas por Pessoa -->
      <div class="charts-grid">
        <div class="chart-container">
          <h3>Despesas Fixas vs Variáveis</h3>
          <canvas id="fixedVsVariableChart"></canvas>
        </div>
        
        <div class="chart-container">
          <h3>Despesas por Pessoa</h3>
          <canvas id="personAnalysisChart"></canvas>
        </div>
      </div>
    </section>
    
    <!-- Gráfico Anual de Barras -->
    <div class="chart-container" style="margin-bottom: var(--spacing-2xl);">
      <h3>Receitas x Despesas (12 meses)</h3>
      <canvas id="annualBars"></canvas>
    </div>
    
    <!-- Compromissos Longos -->
    <div class="commitments">
      <div class="commitments-header active" id="commitmentsHeader">
        <h3>Compromissos Longos</h3>
      </div>
      
      <div class="commitments-content" id="commitmentsContent" style="max-height: none;">
        <!-- Compromissos serão inseridos aqui dinamicamente -->
      </div>
    </div>
    
    <!-- AJUSTE 8, 10 e 11: Revisão da seção de Transações -->
    <section class="transactions-container">
      <div class="card-transacoes">
        <div class="card-header">
          <h3 class="card-title">Transações</h3>
          <div class="filters transaction-filters" id="transaction-filters">
            <!-- Filtros serão inseridos aqui dinamicamente -->
          </div>
        </div>
        
        <div class="card-body">
          <table class="transactions-table" id="transactionsTable">
            <thead>
              <tr>
                <th></th>
                <th class="sortable" data-sort="name">Nome</th>
                <th class="sortable" data-sort="category">Categoria</th>
                <!-- AJUSTE 15: Nova coluna de Pessoas -->
                <th class="sortable" data-sort="person">Pessoa</th>
                <th class="sortable" data-sort="date">Data</th>
                <th class="sortable" data-sort="dueDate">Vencimento</th>
                <th class="sortable" data-sort="amount">Valor</th>
                <th class="sortable" data-sort="status">Status</th>
                <th class="sortable" data-sort="paymentMethod">Pagamento</th>
                <th class="sortable" data-sort="isFixed">Tipo</th>
                <th>Pago?</th>
                <th>Ações</th>
              </tr>
            </thead>
            <tbody id="transactionsTableBody">
              <!-- Transações serão inseridas aqui dinamicamente -->
            </tbody>
          </table>
        </div>
      </div>
    </section>
  </div>

  <!-- Modais -->
  <!-- Modal de Nova Receita -->
  <div class="modal-backdrop" id="incomeModal">
    <div class="modal">
      <div class="modal-header">
        <h2 class="modal-title">Nova Receita</h2>
        <span class="modal-close" id="closeIncomeModal">
          <svg width="24" height="24">
            <use href="#icon-x"></use>
          </svg>
        </span>
      </div>
      
      <div class="modal-body">
        <form id="incomeForm">
          <div class="form-group">
            <label class="form-label" for="incomeName">Nome</label>
            <input type="text" class="form-control" id="incomeName" placeholder="Nome da receita">
          </div>
          
          <div class="form-group">
            <label class="form-label" for="incomeAmount">Valor</label>
            <input type="number" class="form-control" id="incomeAmount" placeholder="0,00" min="0" step="0.01">
          </div>
          
          <div class="form-group">
            <label class="form-label" for="incomeCategory">Categoria</label>
            <div class="select-wrapper">
              <select class="select" id="incomeCategory">
                <!-- Categorias serão carregadas dinamicamente -->
             </select>
             <svg class="select-icon" width="16" height="16">
               <use href="#icon-chevron-down"></use>
             </svg>
           </div>
         </div>
         
         <div class="form-group">
           <label class="form-label" for="incomeDate">Data de Lançamento</label>
           <input type="date" class="form-control" id="incomeDate">
         </div>
         
         <div class="form-group">
           <label class="form-label" for="incomePaymentMethod">Forma de Recebimento</label>
           <div class="select-wrapper">
             <select class="select" id="incomePaymentMethod">
               <!-- Formas de pagamento serão carregadas dinamicamente -->
             </select>
             <svg class="select-icon" width="16" height="16">
               <use href="#icon-chevron-down"></use>
             </svg>
           </div>
         </div>
         
         <div class="form-group">
           <div class="checkbox-wrapper">
             <input type="checkbox" class="checkbox" id="incomeIsRecurrent">
             <label class="checkbox-label" for="incomeIsRecurrent"></label>
           </div>
           <label class="form-label" for="incomeIsRecurrent" style="display: inline-block; margin-left: 8px;">Receita Recorrente</label>
         </div>
         
         <div class="form-group" id="incomeRecurrenceGroup" style="display: none;">
           <label class="form-label" for="incomeInstallments">Quantidade de Parcelas</label>
           <input type="number" class="form-control" id="incomeInstallments" min="2" value="2">
         </div>

         <div class="form-group" id="incomeStatusGroup">
           <label class="form-label">Status</label>
           <div class="radio-group">
             <div class="radio-wrapper">
               <input type="radio" class="radio" id="incomeStatusReceived" name="incomeStatus" value="received" checked>
               <label class="radio-label" for="incomeStatusReceived">
                 <span class="radio-circle"></span>
                 Recebido
               </label>
             </div>
             
             <div class="radio-wrapper">
               <input type="radio" class="radio" id="incomeStatusPending" name="incomeStatus" value="pending">
               <label class="radio-label" for="incomeStatusPending">
                 <span class="radio-circle"></span>
                 A Receber
               </label>
             </div>
           </div>
         </div>
         
         <div class="form-group">
           <label class="form-label" for="incomeNotes">Observação (opcional)</label>
           <textarea class="form-control" id="incomeNotes" rows="3"></textarea>
         </div>
       </form>
     </div>
     
     <div class="modal-footer">
       <button class="btn btn-outline" id="cancelIncomeBtn">Cancelar</button>
       <button class="btn btn-success" id="saveIncomeBtn">Salvar Receita</button>
     </div>
   </div>
 </div>

 <!-- Modal de Nova Despesa -->
 <div class="modal-backdrop" id="expenseModal">
   <div class="modal">
     <div class="modal-header">
       <h2 class="modal-title">Nova Despesa</h2>
       <span class="modal-close" id="closeExpenseModal">
         <svg width="24" height="24">
           <use href="#icon-x"></use>
         </svg>
       </span>
     </div>
     
     <div class="modal-body">
       <form id="expenseForm">
         <div class="form-group">
           <label class="form-label" for="expenseName">Nome</label>
           <input type="text" class="form-control" id="expenseName" placeholder="Nome da despesa">
         </div>
         
         <div class="form-group">
           <label class="form-label" for="expenseAmount">Valor</label>
           <input type="number" class="form-control" id="expenseAmount" placeholder="0,00" min="0" step="0.01">
         </div>
         
         <div class="form-group">
           <label class="form-label" for="expensePaymentMethod">Forma de Pagamento</label>
           <div class="select-wrapper">
             <select class="select" id="expensePaymentMethod">
               <!-- Formas de pagamento serão carregadas dinamicamente -->
             </select>
             <svg class="select-icon" width="16" height="16">
               <use href="#icon-chevron-down"></use>
             </svg>
           </div>
         </div>
         
         <!-- AJUSTE 13: Reposicionamento do campo Cartão de Crédito -->
         <div class="form-group" id="creditCardGroup" style="display: none;">
           <label class="form-label" for="expenseCreditCard">Cartão de Crédito</label>
           <div class="select-wrapper">
             <select class="select" id="expenseCreditCard">
               <!-- Opções de cartões serão inseridas dinamicamente -->
             </select>
             <svg class="select-icon" width="16" height="16">
               <use href="#icon-chevron-down"></use>
             </svg>
           </div>
         </div>
         
         <div class="form-group">
           <label class="form-label" for="expenseCategory">Categoria</label>
           <div class="select-wrapper">
             <select class="select" id="expenseCategory">
               <!-- Categorias serão carregadas dinamicamente -->
            </select>
            <svg class="select-icon" width="16" height="16">
              <use href="#icon-chevron-down"></use>
            </svg>
          </div>
        </div>
        
        <!-- Campo Pessoas (já existente) -->
        <div class="form-group">
          <label class="form-label" for="expensePerson">Pessoa</label>
          <div class="select-wrapper">
            <select class="select" id="expensePerson">
              <!-- Pessoas serão carregadas dinamicamente -->
            </select>
            <svg class="select-icon" width="16" height="16">
              <use href="#icon-chevron-down"></use>
            </svg>
          </div>
        </div>
        
        <!-- AJUSTE 16: Campo obrigatório para marcar despesa como fixa ou variável -->
        <div class="form-group">
          <label class="form-label">Tipo de Despesa</label>
          <div class="radio-group">
            <div class="radio-wrapper">
              <input type="radio" class="radio" id="expenseTypeFixed" name="expenseType" value="fixed" required>
              <label class="radio-label" for="expenseTypeFixed">
                <span class="radio-circle"></span>
                Fixa
              </label>
            </div>
            
            <div class="radio-wrapper">
              <input type="radio" class="radio" id="expenseTypeVariable" name="expenseType" value="variable" required>
              <label class="radio-label" for="expenseTypeVariable">
                <span class="radio-circle"></span>
                Variável
              </label>
            </div>
          </div>
        </div>
        
        <div class="form-group">
          <label class="form-label" for="expenseDate">Data de Lançamento</label>
          <input type="date" class="form-control" id="expenseDate">
        </div>
        
        <div class="form-group" id="expenseDueDateGroup">
          <label class="form-label" for="expenseDueDate">Data de Vencimento</label>
          <input type="date" class="form-control" id="expenseDueDate">
        </div>
        
        <div class="form-group">
          <div class="checkbox-wrapper">
            <input type="checkbox" class="checkbox" id="expenseIsRecurrent">
            <label class="checkbox-label" for="expenseIsRecurrent"></label>
          </div>
          <label class="form-label" for="expenseIsRecurrent" style="display: inline-block; margin-left: 8px;">Despesa Recorrente</label>
        </div>
        
        <div class="form-group" id="expenseRecurrenceGroup" style="display: none;">
          <label class="form-label" for="expenseInstallments">Quantidade de Parcelas</label>
          <input type="number" class="form-control" id="expenseInstallments" min="2" value="2">
        </div>
        
        <div class="form-group" id="expenseStatusGroup">
          <label class="form-label">Status</label>
          <div class="radio-group">
            <div class="radio-wrapper">
              <input type="radio" class="radio" id="expenseStatusPaid" name="expenseStatus" value="paid">
              <label class="radio-label" for="expenseStatusPaid">
                <span class="radio-circle"></span>
                Pago
              </label>
            </div>
            
            <div class="radio-wrapper">
              <input type="radio" class="radio" id="expenseStatusPending" name="expenseStatus" value="pending" checked>
              <label class="radio-label" for="expenseStatusPending">
                <span class="radio-circle"></span>
                Pendente
              </label>
            </div>
            
            <div class="radio-wrapper">
              <input type="radio" class="radio" id="expenseStatusScheduled" name="expenseStatus" value="scheduled">
              <label class="radio-label" for="expenseStatusScheduled">
                <span class="radio-circle"></span>
                Agendado
              </label>
            </div>
          </div>
        </div>
        
        <div class="form-group" id="scheduledDateGroup" style="display: none;">
          <label class="form-label" for="expenseScheduledDate">Data de Agendamento</label>
          <input type="date" class="form-control" id="expenseScheduledDate">
        </div>
        
        <div class="form-group">
          <label class="form-label" for="expenseNotes">Observação (opcional)</label>
          <textarea class="form-control" id="expenseNotes" rows="3"></textarea>
        </div>
      </form>
    </div>
    
    <div class="modal-footer">
      <button class="btn btn-outline" id="cancelExpenseBtn">Cancelar</button>
      <button class="btn btn-danger" id="saveExpenseBtn">Salvar Despesa</button>
    </div>
  </div>
 </div>

 <!-- Modal de Edição de Transação -->
 <div class="modal-backdrop" id="editModal">
  <div class="modal">
    <div class="modal-header">
      <h2 class="modal-title" id="editModalTitle">Editar Transação</h2>
      <span class="modal-close" id="closeEditModal">
        <svg width="24" height="24">
          <use href="#icon-x"></use>
        </svg>
      </span>
    </div>
    
    <div class="modal-body">
      <form id="editForm">
        <input type="hidden" id="editTransactionId">
        <input type="hidden" id="editTransactionType">
        
        <div class="form-group">
          <label class="form-label" for="editName">Nome</label>
          <input type="text" class="form-control" id="editName">
        </div>
        
        <div class="form-group">
          <label class="form-label" for="editAmount">Valor</label>
          <input type="number" class="form-control" id="editAmount" min="0" step="0.01">
        </div>
        
        <div class="form-group">
          <label class="form-label" for="editCategory">Categoria</label>
          <div class="select-wrapper">
            <select class="select" id="editCategory">
              <!-- Opções de categorias serão inseridas dinamicamente -->
            </select>
            <svg class="select-icon" width="16" height="16">
              <use href="#icon-chevron-down"></use>
            </svg>
          </div>
        </div>
        
        <!-- Campo de Pessoa na edição (já existente) -->
        <div class="form-group" id="editPersonGroup">
          <label class="form-label" for="editPerson">Pessoa</label>
          <div class="select-wrapper">
            <select class="select" id="editPerson">
              <!-- Pessoas serão carregadas dinamicamente -->
            </select>
            <svg class="select-icon" width="16" height="16">
              <use href="#icon-chevron-down"></use>
            </svg>
          </div>
        </div>
        
        <!-- AJUSTE 16: Campo de tipo de despesa (fixa/variável) na edição -->
        <div class="form-group" id="editExpenseTypeGroup" style="display: none;">
          <label class="form-label">Tipo de Despesa</label>
          <div class="radio-group">
            <div class="radio-wrapper">
              <input type="radio" class="radio" id="editExpenseTypeFixed" name="editExpenseType" value="fixed">
              <label class="radio-label" for="editExpenseTypeFixed">
                <span class="radio-circle"></span>
                Fixa
              </label>
            </div>
            
            <div class="radio-wrapper">
              <input type="radio" class="radio" id="editExpenseTypeVariable" name="editExpenseType" value="variable">
              <label class="radio-label" for="editExpenseTypeVariable">
                <span class="radio-circle"></span>
                Variável
              </label>
            </div>
          </div>
        </div>
        
        <div class="form-group">
          <label class="form-label" for="editDate">Data de Lançamento</label>
          <input type="date" class="form-control" id="editDate">
        </div>
        
        <div class="form-group" id="editDueDateGroup">
          <label class="form-label" for="editDueDate">Data de Vencimento</label>
          <input type="date" class="form-control" id="editDueDate">
        </div>
        
        <div class="form-group">
          <label class="form-label" for="editPaymentMethod">Forma de Pagamento</label>
          <div class="select-wrapper">
            <select class="select" id="editPaymentMethod">
              <!-- Opções de formas de pagamento serão inseridas dinamicamente -->
            </select>
            <svg class="select-icon" width="16" height="16">
              <use href="#icon-chevron-down"></use>
            </svg>
          </div>
        </div>
        
        <!-- AJUSTE 13: Reposicionamento do campo Cartão de Crédito -->
        <div class="form-group" id="editCreditCardGroup" style="display: none;">
          <label class="form-label" for="editCreditCard">Cartão de Crédito</label>
          <div class="select-wrapper">
            <select class="select" id="editCreditCard">
              <!-- Opções de cartões serão inseridas dinamicamente -->
            </select>
            <svg class="select-icon" width="16" height="16">
              <use href="#icon-chevron-down"></use>
            </svg>
          </div>
        </div>
        
        <div class="form-group">
          <div class="checkbox-wrapper">
            <input type="checkbox" class="checkbox" id="editIsRecurrent">
            <label class="checkbox-label" for="editIsRecurrent"></label>
          </div>
          <label class="form-label" for="editIsRecurrent" style="display: inline-block; margin-left: 8px;">Transação Recorrente</label>
        </div>
        
        <div class="form-group" id="editRecurrenceGroup" style="display: none;">
          <label class="form-label" for="editInstallments">Quantidade de Parcelas</label>
          <input type="number" class="form-control" id="editInstallments" min="2" value="2">
        </div>
        
        <div class="form-group">
          <label class="form-label">Status</label>
          <div class="radio-group" id="editStatusGroup">
            <!-- Opções de status serão inseridas dinamicamente -->
          </div>
        </div>
        
        <div class="form-group" id="editScheduledDateGroup" style="display: none;">
          <label class="form-label" for="editScheduledDate">Data de Agendamento</label>
          <input type="date" class="form-control" id="editScheduledDate">
        </div>
        
        <div class="form-group">
          <label class="form-label" for="editNotes">Observação (opcional)</label>
          <textarea class="form-control" id="editNotes" rows="3"></textarea>
        </div>
      </form>
    </div>
    
    <div class="modal-footer">
      <button class="btn btn-outline" id="cancelEditBtn">Cancelar</button>
      <button class="btn btn-primary" id="saveEditBtn">Salvar Alterações</button>
    </div>
  </div>
 </div>

 <!-- Modal de Cartões -->
 <div class="modal-backdrop" id="cardsListModal">
  <div class="modal">
    <div class="modal-header">
      <h2 class="modal-title">Cartões</h2>
      <span class="modal-close" id="closeCardsListModal">
        <svg width="24" height="24">
          <use href="#icon-x"></use>
        </svg>
      </span>
    </div>
    
    <div class="modal-body">
      <div id="cardsList">
        <!-- Cards serão inseridos aqui dinamicamente -->
      </div>
      
      <button class="btn btn-primary" id="newCardBtn" style="margin-top: var(--spacing-md);">
        <svg width="16" height="16">
          <use href="#icon-plus"></use>
        </svg>
        Novo Cartão
      </button>
    </div>
  </div>
 </div>

 <!-- Modal de Novo Cartão -->
 <div class="modal-backdrop" id="newCardModal">
  <div class="modal">
    <div class="modal-header">
      <h2 class="modal-title">Novo Cartão</h2>
      <span class="modal-close" id="closeNewCardModal">
        <svg width="24" height="24">
          <use href="#icon-x"></use>
        </svg>
      </span>
    </div>
    
    <div class="modal-body">
      <form id="cardForm">
        <div class="form-group">
          <label class="form-label" for="cardName">Nome do Cartão</label>
          <input type="text" class="form-control" id="cardName" placeholder="Ex: Nubank">
        </div>
        
        <div class="form-group">
          <label class="form-label" for="cardLimit">Limite Total</label>
          <input type="number" class="form-control" id="cardLimit" placeholder="0,00" min="0" step="0.01">
        </div>
        
        <div class="form-group">
          <label class="form-label" for="cardClosingDay">Dia de Fechamento</label>
          <input type="number" class="form-control" id="cardClosingDay" placeholder="1-31" min="1" max="31">
        </div>
        
        <div class="form-group">
          <label class="form-label" for="cardDueDay">Dia de Vencimento</label>
          <input type="number" class="form-control" id="cardDueDay" placeholder="1-31" min="1" max="31">
        </div>
      </form>
    </div>
    
    <div class="modal-footer">
      <button class="btn btn-outline" id="cancelCardBtn">Cancelar</button>
      <button class="btn btn-primary" id="saveCardBtn">Salvar Cartão</button>
    </div>
  </div>
 </div>

 <!-- Modal de Fatura do Cartão -->
 <div class="modal-backdrop" id="cardInvoiceModal">
  <div class="modal" style="max-width: 700px;">
    <div class="modal-header">
      <h2 class="modal-title" id="cardInvoiceTitle">Fatura do Cartão</h2>
      <span class="modal-close" id="closeCardInvoiceModal">
        <svg width="24" height="24">
          <use href="#icon-x"></use>
        </svg>
      </span>
    </div>
    
    <div class="modal-body">
      <div class="card" style="margin-bottom: var(--spacing-md);">
        <div id="cardInvoiceDetails">
          <!-- Detalhes da fatura serão inseridos aqui dinamicamente -->
        </div>
      </div>
      
      <h3>Despesas desta Fatura</h3>
      <table class="transactions-table" id="cardInvoiceTable">
        <thead>
          <tr>
            <th></th>
            <th>Nome</th>
            <th>Data</th>
            <th>Valor</th>
            <th>Pago?</th>
          </tr>
        </thead>
        <tbody id="cardInvoiceTableBody">
          <!-- Despesas da fatura serão inseridas aqui dinamicamente -->
        </tbody>
      </table>
    </div>
    
    <div class="modal-footer">
      <button class="btn btn-outline" id="backToCardsBtn">Voltar</button>
      <button class="btn btn-primary" id="payInvoiceBtn">Pagar Fatura</button>
    </div>
  </div>
 </div>

 <!-- Modal de Confirmação de Exclusão -->
 <div class="modal-backdrop" id="deleteConfirmModal">
  <div class="modal" style="max-width: 400px;">
    <div class="modal-header">
      <h2 class="modal-title">
        <svg width="24" height="24" style="vertical-align: middle; margin-right: 8px;">
          <use href="#icon-alert"></use>
        </svg>
        Confirmar Exclusão
      </h2>
      <span class="modal-close" id="closeDeleteConfirmModal">
        <svg width="24" height="24">
          <use href="#icon-x"></use>
        </svg>
      </span>
    </div>
    
    <div class="modal-body">
      <p>Você deseja realmente excluir esta transação? Esta ação é irreversível.</p>
      
      <div id="recurrenceDeleteOptions" style="display: none; margin-top: var(--spacing-md);">
        <p><strong>Esta é uma transação recorrente. O que deseja fazer?</strong></p>
        
        <div class="radio-group" style="flex-direction: column; gap: var(--spacing-sm);">
          <div class="radio-wrapper">
            <input type="radio" class="radio" id="deleteSingle" name="deleteOption" value="single" checked>
            <label class="radio-label" for="deleteSingle">
              <span class="radio-circle"></span>
              Excluir apenas esta parcela
            </label>
          </div>
          
          <div class="radio-wrapper">
            <input type="radio" class="radio" id="deleteAllFuture" name="deleteOption" value="future">
            <label class="radio-label" for="deleteAllFuture">
              <span class="radio-circle"></span>
              Excluir todas as parcelas futuras
            </label>
          </div>
        </div>
      </div>
    </div>
    
    <div class="modal-footer">
      <button class="btn btn-outline" id="cancelDeleteBtn">Cancelar</button>
      <button class="btn btn-danger" id="confirmDeleteBtn">Excluir</button>
    </div>
  </div>
 </div>

 <!-- Modal de Confirmação de Pagamento de Fatura -->
 <div class="modal-backdrop" id="payInvoiceConfirmModal">
  <div class="modal" style="max-width: 400px;">
    <div class="modal-header">
      <h2 class="modal-title">
        <svg width="24" height="24" style="vertical-align: middle; margin-right: 8px;">
          <use href="#icon-credit-card"></use>
        </svg>
        Pagar Fatura do Cartão
      </h2>
      <span class="modal-close" id="closePayInvoiceConfirmModal">
        <svg width="24" height="24">
          <use href="#icon-x"></use>
        </svg>
      </span>
    </div>
    
    <div class="modal-body">
      <p>Confirmar pagamento de todas as despesas desta fatura?</p>
      <p style="margin-top: var(--spacing-xs);">Total: <strong id="invoiceConfirmAmount">R$ 0,00</strong></p>
    </div>
    
    <div class="modal-footer">
      <button class="btn btn-outline" id="cancelPayInvoiceBtn">Cancelar</button>
      <button class="btn btn-primary" id="confirmPayInvoiceBtn">Pagar</button>
    </div>
  </div>
 </div>

 <!-- AJUSTE 3: Modal de Categorias reformulado -->
 <div class="modal-backdrop" id="categoriesModal">
  <div class="modal" style="max-width: 600px;">
    <div class="modal-header">
      <h2 class="modal-title">Gerenciar Categorias</h2>
      <span class="modal-close" id="closeCategoriesModal">
        <svg width="24" height="24">
          <use href="#icon-x"></use>
        </svg>
      </span>
    </div>
    
    <div class="modal-body categories-container">
      <ul class="nav-tabs" id="categoryTabs" role="tablist">
        <li class="nav-item">
          <a class="nav-link active" id="income-cat-tab" data-toggle="tab" href="#income-cat" role="tab">Receitas</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" id="expense-cat-tab" data-toggle="tab" href="#expense-cat" role="tab">Despesas</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" id="payment-methods-tab" data-toggle="tab" href="#payment-methods" role="tab">Pagamentos</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" id="people-tab" data-toggle="tab" href="#people" role="tab">Pessoas</a>
        </li>
        <!-- AJUSTE 2: Inclusão de gerenciamento de categorias de investimentos -->
        <li class="nav-item">
          <a class="nav-link" id="investment-cat-tab" data-toggle="tab" href="#investment-cat" role="tab">Investimentos</a>
        </li>
      </ul>
      
      <div class="tab-content" id="categoryTabContent">
        <!-- Categorias de Receita -->
        <div class="tab-pane fade show active" id="income-cat" role="tabpanel">
          <div class="category-list" id="incomeCategoriesList">
            <!-- Categorias serão carregadas dinamicamente -->
          </div>
          
          <div class="add-category-form">
            <div class="custom-icon-input">
              <div class="custom-icon-preview" id="newIncomeCategoryIconPreview">
                <svg width="24" height="24">
                  <use href="#icon-money"></use>
                </svg>
              </div>
              <input type="text" class="form-control" id="newIncomeCategoryIconInput" placeholder="Emoji ou ícone">
            </div>
            <input type="text" class="form-control" id="newIncomeCategoryInput" placeholder="Nova categoria">
            <button class="btn btn-primary" id="addIncomeCategoryBtn">Adicionar</button>
          </div>
        </div>
        
        <!-- Categorias de Despesa -->
        <div class="tab-pane fade" id="expense-cat" role="tabpanel">
          <div class="category-list" id="expenseCategoriesList">
            <!-- Categorias serão carregadas dinamicamente -->
          </div>
          
          <div class="add-category-form">
            <div class="custom-icon-input">
              <div class="custom-icon-preview" id="newExpenseCategoryIconPreview">
                <svg width="24" height="24">
                  <use href="#icon-shopping"></use>
                </svg>
              </div>
              <input type="text" class="form-control" id="newExpenseCategoryIconInput" placeholder="Emoji ou ícone">
            </div>
            <input type="text" class="form-control" id="newExpenseCategoryInput" placeholder="Nova categoria">
            <button class="btn btn-primary" id="addExpenseCategoryBtn">Adicionar</button>
          </div>
        </div>
        
        <!-- Formas de Pagamento -->
        <div class="tab-pane fade" id="payment-methods" role="tabpanel">
          <div class="category-list" id="paymentMethodsList">
            <!-- Formas de pagamento serão carregadas dinamicamente -->
          </div>
          
          <div class="add-category-form">
            <div class="custom-icon-input">
              <div class="custom-icon-preview" id="newPaymentMethodIconPreview">
                <svg width="24" height="24">
                  <use href="#icon-money"></use>
                </svg>
              </div>
              <input type="text" class="form-control" id="newPaymentMethodIconInput" placeholder="Emoji ou ícone">
            </div>
            <input type="text" class="form-control" id="newPaymentMethodInput" placeholder="Nova forma de pagamento">
            <button class="btn btn-primary" id="addPaymentMethodBtn">Adicionar</button>
          </div>
        </div>
        
        <!-- Pessoas -->
        <div class="tab-pane fade" id="people" role="tabpanel">
          <div class="category-list" id="peopleList">
            <!-- Pessoas serão carregadas dinamicamente -->
          </div>
          
          <div class="add-category-form">
            <div class="custom-icon-input">
              <div class="custom-icon-preview" id="newPersonIconPreview">
                <svg width="24" height="24">
                  <use href="#icon-default"></use>
                </svg>
              </div>
              <input type="text" class="form-control" id="newPersonIconInput" placeholder="Emoji ou ícone">
            </div>
            <input type="text" class="form-control" id="newPersonInput" placeholder="Nome da pessoa">
            <button class="btn btn-primary" id="addPersonBtn">Adicionar</button>
          </div>
        </div>
        
        <!-- AJUSTE 2: Aba de Categorias de Investimento -->
        <div class="tab-pane fade" id="investment-cat" role="tabpanel">
          <div class="category-list" id="investmentCategoriesList">
            <!-- Categorias de investimento serão carregadas dinamicamente -->
          </div>
          
          <div class="add-category-form">
            <div class="custom-icon-input">
              <div class="custom-icon-preview" id="newInvestmentCategoryIconPreview">
                <svg width="24" height="24">
                  <use href="#icon-chart"></use>
                </svg>
              </div>
              <input type="text" class="form-control" id="newInvestmentCategoryIconInput" placeholder="Emoji ou ícone">
            </div>
            <input type="text" class="form-control" id="newInvestmentCategoryInput" placeholder="Nova categoria de investimento">
            <button class="btn btn-primary" id="addInvestmentCategoryBtn">Adicionar</button>
          </div>
        </div>
      </div>
    </div>
    
    <div class="modal-footer">
      <button class="btn btn-outline" id="closeCategoriesBtn">Fechar</button>
    </div>
  </div>
 </div>

 <!-- Modal de Edição de Categoria -->
 <div class="modal-backdrop" id="editCategoryModal">
  <div class="modal" style="max-width: 400px;">
    <div class="modal-header">
      <h2 class="modal-title" id="editCategoryTitle">Editar Categoria</h2>
      <span class="modal-close" id="closeEditCategoryModal">
        <svg width="24" height="24">
          <use href="#icon-x"></use>
        </svg>
      </span>
    </div>
    
    <div class="modal-body">
      <form id="editCategoryForm">
        <input type="hidden" id="editCategoryId">
        <input type="hidden" id="editCategoryType">
        
        <div class="form-group">
          <label class="form-label">Ícone</label>
          <div class="custom-icon-input">
            <div class="custom-icon-preview" id="editCategoryIconPreview">
              <svg width="24" height="24">
                <use href="#icon-default"></use>
              </svg>
            </div>
            <input type="text" class="form-control" id="editCategoryIconInput" placeholder="Emoji ou código unicode">
          </div>
        </div>
        
        <div class="form-group">
          <label class="form-label" for="editCategoryName">Nome</label>
          <input type="text" class="form-control" id="editCategoryName" placeholder="Nome da categoria">
        </div>
      </form>
    </div>
    
    <div class="modal-footer">
      <button class="btn btn-outline" id="cancelEditCategoryBtn">Cancelar</button>
      <button class="btn btn-primary" id="saveEditCategoryBtn">Salvar</button>
    </div>
  </div>
 </div>

 <!-- AJUSTE 6: Novas Telas de Investimentos -->
 <!-- Modal Principal de Investimentos -->
 <div class="modal-backdrop" id="investmentsModal">
  <div class="modal" style="max-width: 900px;">
    <div class="modal-header">
      <h2 class="modal-title">Investimentos</h2>
      <span class="modal-close" id="closeInvestmentsModal">
        <svg width="24" height="24">
          <use href="#icon-x"></use>
        </svg>
      </span>
    </div>
    
    <div class="modal-body">
      <div class="investment-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--spacing-lg);">
        <h3>Investimentos</h3>
        <button class="btn btn-primary" id="newInvestmentBtn">
          <svg width="16" height="16">
            <use href="#icon-plus"></use>
          </svg>
          Novo Investimento
        </button>
      </div>
      
      <div class="investment-grid" id="investmentsGrid">
        <!-- Cards de investimentos serão inseridos aqui dinamicamente -->
      </div>
    </div>
    
    <div class="modal-footer">
      <button class="btn btn-outline" id="closeInvestmentsBtn">Fechar</button>
    </div>
  </div>
 </div>

 <!-- Modal para Detalhe do Investimento -->
 <div class="modal-backdrop" id="investmentDetailModal">
  <div class="modal" style="max-width: 800px;">
    <div class="modal-header">
      <h2 class="modal-title" id="investmentDetailTitle">
        <button class="btn btn-icon btn-outline" id="backToInvestmentsBtn" style="margin-right: var(--spacing-sm);">
          <svg width="16" height="16">
            <use href="#icon-arrow-left"></use>
          </svg>
        </button>
        <span id="investmentDetailName">Nome do Investimento</span>
      </h2>
      <span class="modal-close" id="closeInvestmentDetailModal">
        <svg width="24" height="24">
          <use href="#icon-x"></use>
        </svg>
      </span>
    </div>
    
    <div class="modal-body">
      <div class="investment-detail">
        <div class="investment-detail-header">
          <div class="investment-detail-stat">
            <div class="investment-detail-title">Guardado</div>
            <div class="investment-detail-value" id="investmentDetailSaved">R$ 0,00</div>
          </div>
          
          <div class="investment-detail-stat">
            <div class="investment-detail-title">Meta</div>
            <div class="investment-detail-value" id="investmentDetailGoal">R$ 0,00</div>
          </div>
          
          <div class="investment-detail-stat">
            <div class="investment-detail-title">Progresso</div>
            <div class="investment-detail-value" id="investmentDetailProgress">0%</div>
          </div>
        </div>
        
        <div class="investment-detail-info" style="margin-bottom: var(--spacing-lg);">
          <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: var(--spacing-md);">
            <div>
              <div class="investment-detail-title">Categoria</div>
              <div id="investmentDetailCategory">Viagem</div>
            </div>
            
            <div>
              <div class="investment-detail-title">Criado em</div>
              <div id="investmentDetailCreatedAt">01/01/2025</div>
            </div>
            
            <div>
              <div class="investment-detail-title">Objetivo</div>
              <div id="investmentDetailTarget">Julho de 2026</div>
            </div>
          </div>
          
          <div style="margin-top: var(--spacing-md);">
            <div class="investment-detail-title">Observação</div>
            <div id="investmentDetailNotes">-</div>
          </div>
        </div>
      </div>
      
      <div class="investment-history">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--spacing-md);">
          <h3 class="investment-history-title">Histórico de Aportes</h3>
          <button class="btn btn-primary" id="addInvestmentContributionBtn">
            <svg width="16" height="16">
              <use href="#icon-plus"></use>
            </svg>
            Adicionar novo valor
          </button>
        </div>
        
        <table class="investment-history-table">
          <thead>
            <tr>
              <th>Data</th>
              <th>Valor</th>
              <th>Descrição</th>
              <th>Ações</th>
            </tr>
          </thead>
          <tbody id="investmentHistoryTableBody">
            <!-- Histórico de aportes será inserido aqui dinamicamente -->
          </tbody>
        </table>
      </div>
    </div>
    
    <div class="modal-footer">
      <button class="btn btn-danger" id="deleteInvestmentBtn">Excluir Investimento</button>
      <button class="btn btn-primary" id="editInvestmentBtn">Editar Investimento</button>
    </div>
  </div>
 </div>

 <!-- Modal de Novo Investimento -->
 <div class="modal-backdrop" id="newInvestmentModal">
  <div class="modal">
    <div class="modal-header">
      <h2 class="modal-title">Novo Investimento</h2>
      <span class="modal-close" id="closeNewInvestmentModal">
        <svg width="24" height="24">
          <use href="#icon-x"></use>
        </svg>
      </span>
    </div>
    
    <div class="modal-body">
      <form id="investmentForm">
        <div class="form-group">
          <label class="form-label" for="investmentName">Nome do objetivo</label>
          <input type="text" class="form-control" id="investmentName" placeholder="Ex: Viagem em Família">
        </div>
        
        <div class="form-group">
          <label class="form-label" for="investmentAmount">Valor inicial</label>
          <input type="number" class="form-control" id="investmentAmount" placeholder="0,00" min="0" step="0.01">
        </div>
        
        <div class="form-group">
          <label class="form-label" for="investmentGoal">Meta final (opcional)</label>
          <input type="number" class="form-control" id="investmentGoal" placeholder="0,00" min="0" step="0.01">
        </div>
        
        <div class="form-group">
          <label class="form-label" for="investmentCategory">Tipo/Categoria</label>
          <div class="select-wrapper">
            <select class="select" id="investmentCategory">
              <option value="viagem">Viagem</option>
              <option value="emergencia">Emergência</option>
              <option value="filho">Filho</option>
              <option value="outro">Outro</option>
            </select>
            <svg class="select-icon" width="16" height="16">
              <use href="#icon-chevron-down"></use>
            </svg>
          </div>
        </div>
        
        <div class="form-group">
          <label class="form-label" for="investmentTargetDate">Data-alvo (opcional)</label>
          <input type="date" class="form-control" id="investmentTargetDate">
        </div>
        
        <div class="form-group">
          <label class="form-label" for="investmentNotes">Observações (opcional)</label>
          <textarea class="form-control" id="investmentNotes" rows="3"></textarea>
        </div>
      </form>
    </div>
    
    <div class="modal-footer">
      <button class="btn btn-outline" id="cancelInvestmentBtn">Cancelar</button>
      <button class="btn btn-primary" id="saveInvestmentBtn">Salvar Investimento</button>
    </div>
  </div>
 </div>

 <!-- Modal para Adicionar Aporte -->
 <div class="modal-backdrop" id="newContributionModal">
  <div class="modal" style="max-width: 400px;">
    <div class="modal-header">
      <h2 class="modal-title">Adicionar Novo Valor</h2>
      <span class="modal-close" id="closeNewContributionModal">
        <svg width="24" height="24">
          <use href="#icon-x"></use>
        </svg>
      </span>
    </div>
    
    <div class="modal-body">
      <form id="contributionForm">
        <input type="hidden" id="contributionInvestmentId">
        
        <div class="form-group">
          <label class="form-label" for="contributionAmount">Valor</label>
          <input type="number" class="form-control" id="contributionAmount" placeholder="0,00" min="0" step="0.01" required>
        </div>
        
        <div class="form-group">
          <label class="form-label" for="contributionDate">Data</label>
          <input type="date" class="form-control" id="contributionDate" required>
        </div>
        
        <div class="form-group">
          <label class="form-label" for="contributionDescription">Descrição</label>
          <input type="text" class="form-control" id="contributionDescription" placeholder="Ex: Depósito mensal">
        </div>
      </form>
    </div>
    
    <div class="modal-footer">
      <button class="btn btn-outline" id="cancelContributionBtn">Cancelar</button>
      <button class="btn btn-primary" id="saveContributionBtn">Adicionar</button>
    </div>
  </div>
 </div>

 <!-- Modal para detalhes de contas vencidas -->
 <div class="modal-backdrop" id="overdueDetailsModal">
  <div class="modal" style="max-width: 700px;">
    <div class="modal-header">
      <h2 class="modal-title">
        <svg width="24" height="24" style="vertical-align: middle; margin-right: 8px;">
          <use href="#icon-alert"></use>
        </svg>
        Contas Vencidas
      </h2>
      <span class="modal-close" id="closeOverdueDetailsModal">
        <svg width="24" height="24">
          <use href="#icon-x"></use>
        </svg>
      </span>
    </div>
    
    <div class="modal-body">
      <table class="transactions-table" id="overdueTransactionsTable">
        <thead>
          <tr>
            <th></th>
            <th>Nome</th>
            <th>Categoria</th>
            <th>Vencimento</th>
            <th>Valor</th>
            <th>Ações</th>
          </tr>
        </thead>
        <tbody id="overdueTransactionsTableBody">
          <!-- Contas vencidas serão inseridas aqui dinamicamente -->
        </tbody>
      </table>
    </div>
    
    <div class="modal-footer">
      <button class="btn btn-outline" id="closeOverdueDetailsBtn">Fechar</button>
      <button class="btn btn-primary" id="payAllOverdueBtn">Pagar Todas</button>
    </div>
  </div>
 </div>

 <!-- Toast Container -->
 <div class="toast-container" id="toastContainer">
  <!-- Toasts serão inseridos aqui dinamicamente -->
 </div>

 <script>
  // =================================================================== 
  // CHECKLIST DE DESENVOLVIMENTO - APP GESTÃO FINANCEIRA
  // =================================================================== 
  /*
   * CHECKLIST COMPLETO DE TAREFAS (12 TOTAL):
   * 
   * (A) Migração e Reestruturação Visual (Base):
   * ✅ A1. Estruturar o HTML base do projeto seguindo exatamente o Mockup.html.
   * ✅ A2. Aplicar todo o CSS (estilos, fontes, cores, layout responsivo) definido no Mockup.html.
   * ✅ A3. Migrar e adaptar a lógica JavaScript do codigo completo.txt.
   * 
   * (B) Novas Funcionalidades e Correções:
   * ✅ B1. Campo "Pessoas": Adicionar campo ao formulário de despesas.
   * ✅ B2. Gerenciamento de Pessoas: Criar interface e lógica.
   * ✅ B3. Novo Gráfico (Fixas vs. Variáveis).
   * ✅ B4. Posicionamento Novo Gráfico ao lado do existente.
   * ✅ B5. Seção "Investimentos": Criar nova seção/tela.
   * ✅ B6. Cadastro em Investimentos: Implementar CRUD de categorias.
   * ✅ B7. Filtro por "Pessoas" na lista de transações.
   * ✅ B8. Análise por Pessoa: Implementar KPI ou Gráfico.
   * ✅ B9. Correção Bug Categorias: Listar todas imediatamente.
   *
   * PROGRESSO: 12/12 tarefas concluídas (100%)
   * APLICAÇÃO CONCLUÍDA
   */
  
  // Helpers DOM
  const $ = selector => document.querySelector(selector);
  const $$ = selector => Array.from(document.querySelectorAll(selector));

  // Estado global da aplicação
  const state = {
    year: 2025,
    month: 4, // Maio (0-indexed)
    transactions: [],
    cards: [],
    filteredTransactions: [],
    insights: [],
    sortColumn: 'date', // Coluna padrão para ordenação
    sortDirection: 'desc', // Direção padrão (decrescente para datas)
    filters: {
      category: '',
      status: '',
      paymentMethod: '',
      person: '' // Filtro por pessoa
    },
    categories: {
      income: [
        { id: 'salario', name: 'Salário', icon: '💰' },
        { id: 'investimentos', name: 'Investimentos', icon: '📈' },
        { id: 'freelance', name: 'Freelance', icon: '💻' },
        { id: 'presente', name: 'Presente', icon: '🎁' },
        { id: 'outros_income', name: 'Outros', icon: 'ℹ️' }
      ],
      expense: [
        { id: 'alimentacao', name: 'Alimentação', icon: '🍔' },
        { id: 'moradia', name: 'Moradia', icon: '🏠' },
        { id: 'transporte', name: 'Transporte', icon: '🚗' },
        { id: 'saude', name: 'Saúde', icon: '⚕️' },
        { id: 'educacao', name: 'Educação', icon: '📚' },
        { id: 'lazer', name: 'Lazer', icon: '🎮' },
        { id: 'compras', name: 'Compras', icon: '🛍️' },
        { id: 'contas', name: 'Contas e serviços', icon: '📝' },
        { id: 'impostos', name: 'Impostos', icon: '💸' },
        { id: 'outros_expense', name: 'Outros', icon: 'ℹ️' }
      ],
      investment: [ // Categorias de investimento
        { id: 'viagem', name: 'Viagem', icon: '✈️' },
        { id: 'emergencia', name: 'Emergência', icon: '🚨' },
        { id: 'filho', name: 'Filho', icon: '👶' },
        { id: 'tesouro', name: 'Tesouro Direto', icon: '🏛️' },
        { id: 'acoes', name: 'Ações', icon: '📊' },
        { id: 'outro', name: 'Outro', icon: '💰' }
      ]
    },
    paymentMethods: [
      { id: 'dinheiro', name: 'Dinheiro', icon: '💵' },
      { id: 'pix', name: 'Pix', icon: '⚡' },
      { id: 'debito', name: 'Débito', icon: '💳' },
      { id: 'debito_conta', name: 'Débito em Conta', icon: '🏦' },
      { id: 'transferencia', name: 'Transferência Bancária', icon: '🔄' },
      { id: 'boleto', name: 'Boleto', icon: '📄' },
      { id: 'credito', name: 'Crédito', icon: '💳' }
    ],
    people: [ // Lista de pessoas
      { id: 'familia', name: 'Família', icon: '👨‍👩‍👧‍👦' },
      { id: 'eu', name: 'Eu', icon: '👤' },
      { id: 'conjuge', name: 'Cônjuge', icon: '💑' },
      { id: 'filhos', name: 'Filhos', icon: '👶' }
    ],
    investments: [], // Array para investimentos
    investmentContributions: [], // Array para contribuições de investimentos
    currentTransaction: null,
    currentCard: null,
    currentCategory: null,
    currentInvestment: null,
    currentContribution: null,
    themePreference: 'light'
  };

  // Formatadores
  const formatCurrency = value => {
    return new Intl.NumberFormat('pt-BR', {
      style: 'currency',
      currency: 'BRL'
    }).format(value);
  };

  // Função auxiliar para parsing de datas locais
  const parseLocalDateString = (dateInput) => {
    if (dateInput instanceof Date && !isNaN(dateInput)) {
      return dateInput;
    }
    if (typeof dateInput === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(dateInput)) {
      const parts = dateInput.split('-');
      return new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
    }
    return null;
  };

  const formatDate = (date, options = {}) => {
    let dateObj;
    if (!date) return '';
    
    if (typeof date === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(date)) {
      dateObj = parseLocalDateString(date);
    } else {
      dateObj = date instanceof Date ? date : new Date(date);
    }
    
    return dateObj.toLocaleDateString('pt-BR', options);
  };

  // Função para manipular datas sem problemas de fuso horário
  const localDateToISOString = (date) => {
    if (!date) return null;
    const localDate = date instanceof Date ? date : new Date(date);
    // Criar uma string de data no formato ISO, mas mantendo a data local
    return localDate.getFullYear() + '-' + 
           String(localDate.getMonth() + 1).padStart(2, '0') + '-' + 
           String(localDate.getDate()).padStart(2, '0');
  };

  // Função para atualizar cores do tema para os gráficos
  const updateChartColors = () => {
    const isDarkTheme = document.documentElement.getAttribute('data-theme') === 'dark';
    const textColor = isDarkTheme ? 'rgba(245, 245, 247, 1)' : 'rgba(29, 29, 31, 1)';
    const gridColor = isDarkTheme ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
    
    // AJUSTE 22: Usar paleta de cores da Apple
    const appleColors = [
      '#007AFF', // azul
      '#34C759', // verde
      '#FF9500', // laranja
      '#FF3B30', // vermelho
      '#AF52DE', // roxo
      '#5E5CE6', // azul índigo
      '#FF2D55', // rosa
      '#FF9F0A', // amarelo
      '#64D2FF', // azul claro
      '#30B0C7'  // azul esverdeado
    ];
    
    // Atualizar cores padrão do Chart.js
    Chart.defaults.color = textColor;
    Chart.defaults.borderColor = gridColor;
    
    // Atualizar definições de tooltips
    Chart.defaults.plugins.tooltip.backgroundColor = isDarkTheme ? 'rgba(28, 28, 30, 0.95)' : 'rgba(255, 255, 255, 0.95)';
    Chart.defaults.plugins.tooltip.titleColor = textColor;
    Chart.defaults.plugins.tooltip.bodyColor = textColor;
    Chart.defaults.plugins.tooltip.borderColor = isDarkTheme ? 'rgba(255, 255, 255, 0.2)' : 'rgba(0, 0, 0, 0.1)';
    Chart.defaults.plugins.tooltip.borderWidth = 1;
    
    // Atualizar cada gráfico individualmente
    if (pieChart) {
      pieChart.options.plugins.legend.labels.color = textColor;
      pieChart.options.plugins.tooltip.titleColor = textColor;
      pieChart.options.plugins.tooltip.bodyColor = textColor;
      pieChart.data.datasets[0].borderColor = isDarkTheme ? '#000000' : '#ffffff';
      pieChart.data.datasets[0].backgroundColor = appleColors;
      pieChart.update();
    }
    
    if (barChart) {
      barChart.options.scales.x.ticks.color = textColor;
      barChart.options.scales.x.grid.color = gridColor;
      barChart.options.scales.y.ticks.color = textColor;
      barChart.options.scales.y.grid.color = gridColor;
      barChart.options.plugins.legend.labels.color = textColor;
      barChart.options.plugins.tooltip.titleColor = textColor;
      barChart.options.plugins.tooltip.bodyColor = textColor;
      barChart.data.datasets[0].backgroundColor = appleColors[1]; // verde
      barChart.data.datasets[1].backgroundColor = appleColors[3]; // vermelho
      barChart.update();
    }
    
    if (areaChart) {
      areaChart.options.scales.x.ticks.color = textColor;
      areaChart.options.scales.x.grid.color = gridColor;
      areaChart.options.scales.y.ticks.color = textColor;
      areaChart.options.scales.y.grid.color = gridColor;
      areaChart.options.plugins.legend.labels.color = textColor;
      areaChart.options.plugins.tooltip.titleColor = textColor;
      areaChart.options.plugins.tooltip.bodyColor = textColor;
      areaChart.data.datasets[0].backgroundColor = 'rgba(255, 59, 48, 0.2)';
      areaChart.data.datasets[0].borderColor = appleColors[3];
      areaChart.data.datasets[1].borderColor = appleColors[0];
      areaChart.data.datasets[2].borderColor = appleColors[1];
      areaChart.update();
    }
    
    // AJUSTE 17: Atualizar gráfico de despesas fixas vs variáveis
    if (fixedVsVariableChart) {
      fixedVsVariableChart.options.plugins.legend.labels.color = textColor;
      fixedVsVariableChart.options.plugins.tooltip.titleColor = textColor;
      fixedVsVariableChart.options.plugins.tooltip.bodyColor = textColor;
      fixedVsVariableChart.data.datasets[0].backgroundColor = [appleColors[0], appleColors[2]];
      fixedVsVariableChart.data.datasets[0].borderColor = isDarkTheme ? '#000000' : '#ffffff';
      fixedVsVariableChart.update();
    }
    
    // AJUSTE 20: Atualizar gráfico de despesas por pessoa
    if (personAnalysisChart) {
      personAnalysisChart.options.plugins.legend.labels.color = textColor;
      personAnalysisChart.options.plugins.tooltip.titleColor = textColor;
      personAnalysisChart.options.plugins.tooltip.bodyColor = textColor;
      personAnalysisChart.data.datasets[0].backgroundColor = appleColors;
      personAnalysisChart.data.datasets[0].borderColor = isDarkTheme ? '#000000' : '#ffffff';
      personAnalysisChart.update();
    }
  };

  // Função de tema claro/escuro
  const toggleTheme = () => {
    const currentTheme = document.documentElement.getAttribute('data-theme');
    const newTheme = currentTheme === 'light' ? 'dark' : 'light';
    
    document.documentElement.setAttribute('data-theme', newTheme);
    state.themePreference = newTheme;
    
    // Armazenar preferência em localStorage
    localStorage.setItem('themePreference', newTheme);
    
    // Atualizar cores de gráficos quando o tema é alterado
    updateChartColors();
  };

  // Verificar a preferência de tema do usuário
  const initTheme = () => {
    const savedTheme = localStorage.getItem('themePreference');
    if (savedTheme) {
      document.documentElement.setAttribute('data-theme', savedTheme);
      state.themePreference = savedTheme;
    } else {
      // Verificar preferência do sistema
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.documentElement.setAttribute('data-theme', 'dark');
        state.themePreference = 'dark';
      }
    }
    
    // Listener para o botão de alternar tema
    $('#themeToggle').addEventListener('click', toggleTheme);
  };

  // Configuração do Firebase
  const firebaseConfig = {
    apiKey: "AIzaSyDvL_nYWhv_8rPouejiWbDZtDCKHYOQyEY",
    authDomain: "calculadora-da-familia.firebaseapp.com",
    projectId: "calculadora-da-familia",
    storageBucket: "calculadora-da-familia.appspot.com",
    messagingSenderId: "69721783786",
    appId: "1:69721783786:web:c4703b5c182e3681e8c693",
    measurementId: "G-YM5TR661S6"
  };

  // Inicializar Firebase com tratamento de erro
  let db;
  try {
    firebase.initializeApp(firebaseConfig);
    db = firebase.firestore();
    
    // Configurar persistência offline para melhor experiência do usuário
    db.enablePersistence({experimentalForceOwningTab: true})
      .catch(err => {
        if (err.code === 'failed-precondition') {
          console.warn('Múltiplas abas abertas, persistência não suportada. Usando apenas modo online.');
          // Continuar sem persistência
        } else if (err.code === 'unimplemented') {
          console.warn('O navegador não suporta persistência offline. Usando apenas modo online.');
          // Continuar sem persistência
        }
      });
      
    console.log('Firebase inicializado com sucesso');
  } catch (error) {
    console.error('Erro ao inicializar Firebase:', error);
    showToast('Erro de conexão com o Firebase. Tente recarregar a página.', 'error');
    // Inicializar um banco de dados falso para evitar erros
    db = {
      collection: () => ({
        get: () => Promise.resolve({ docs: [], empty: true }),
        doc: () => ({ 
          get: () => Promise.resolve({ exists: false, data: () => ({}) }),
          set: () => Promise.resolve(),
          update: () => Promise.resolve(),
          delete: () => Promise.resolve()
        }),
        add: () => Promise.resolve({ id: 'temp-id' })
      })
    };
  }

  // IDs únicos
  const generateId = () => {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
  };

  // Toast notifications
  const showToast = (message, type = 'success') => {
    const toastContainer = $('#toastContainer');
    if (!toastContainer) return; // Safety check
    
    const toast = document.createElement('div');
    toast.className = `toast toast-${type}`;
    
    let iconName = '';
    switch (type) {
      case 'success':
        iconName = 'icon-check';
        break;
      case 'error':
        iconName = 'icon-x';
        break;
      case 'warning':
        iconName = 'icon-alert';
        break;
      case 'info':
        iconName = 'icon-info';
        break;
    }
    
    toast.innerHTML = `
      <div class="toast-icon">
        <svg width="24" height="24">
          <use href="#${iconName}"></use>
        </svg>
      </div>
      <div class="toast-content">${message}</div>
      <span class="toast-close">
        <svg width="16" height="16">
          <use href="#icon-x"></use>
        </svg>
      </span>
    `;
    
    toastContainer.appendChild(toast);
    
    // Animação
    setTimeout(() => {
      toast.classList.add('show');
    }, 10);
    
    // Fechar toast ao clicar no X
    toast.querySelector('.toast-close').addEventListener('click', () => {
      toast.classList.remove('show');
      setTimeout(() => {
        if (toast.parentNode) {
          toast.remove();
        }
      }, 300);
    });
    
    // Auto fechar após 5 segundos
    setTimeout(() => {
      if (toast.parentNode) {
        toast.classList.remove('show');
        setTimeout(() => {
          if (toast.parentNode) {
            toast.remove();
          }
        }, 300);
      }
    }, 5000);
  };

  // Funções para manipulação de modais
  const openModal = modalId => {
    const modal = $(`#${modalId}`);
    if (!modal) return; // Safety check
    
    modal.classList.add('active');
    document.body.style.overflow = 'hidden';
  };

  const closeModal = modalId => {
    const modal = $(`#${modalId}`);
    if (!modal) return; // Safety check
    
    modal.classList.remove('active');
    document.body.style.overflow = '';
  };

  const closeAllModals = () => {
    $$('.modal-backdrop').forEach(modal => {
      modal.classList.remove('active');
    });
    document.body.style.overflow = '';
  };

  // Manipulação de date inputs
  const setDateInputValue = (inputId, date) => {
    const input = $(`#${inputId}`);
    if (!input) return; // Safety check

    // Garantir que estamos trabalhando com um objeto Date ou string ISO
    let dateObj;
    if (date instanceof Date) {
      dateObj = date;
    } else if (typeof date === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(date)) {
      dateObj = parseLocalDateString(date);
    } else {
      return; // Não suportado
    }

    // Formato YYYY-MM-DD para inputs de data
    const year = dateObj.getFullYear();
    const month = String(dateObj.getMonth() + 1).padStart(2, '0');
    const day = String(dateObj.getDate()).padStart(2, '0');

    input.value = `${year}-${month}-${day}`;
  };

  const getDateInputValue = inputId => {
    const input = $(`#${inputId}`);
    if (!input || !input.value) return null;

    // Converter o valor do input diretamente para Date
    // O input type="date" retorna YYYY-MM-DD
    return parseLocalDateString(input.value);
  };

  // Função para atualizar as opções de anos até 2030
  const updateYearOptions = () => {
    const yearSelect = $('#yearSelect');
    
    if (yearSelect) {
      yearSelect.innerHTML = '';
      
      for (let year = 2023; year <= 2030; year++) {
        const option = document.createElement('option');
        option.value = year;
        option.textContent = year;
        option.selected = year === state.year;
        yearSelect.appendChild(option);
      }
    }
  };

  // Função para calcular o melhor dia para compras
  const calcularMelhorDiaCompras = (cartao) => {
    if (!cartao || !cartao.closingDay) return null;
    
    // O melhor dia é sempre o dia seguinte ao fechamento
    let melhorDia = cartao.closingDay + 1;
    
    // Se o fechamento for no dia 31, o melhor dia é o dia 1
    if (melhorDia > 31) {
      melhorDia = 1;
    }
    
    return melhorDia;
  };

  // Função para calcular data de vencimento automático para cartões
  const calcularVencimentoReal = (dataCompra, cartao) => {
    // Garantir que temos um objeto Date
    const compra = dataCompra instanceof Date ? dataCompra : parseLocalDateString(dataCompra);
    if (!compra || !cartao) return null;
    
    // Calcular data de fechamento para o mês da compra
    const dataFechamento = new Date(
      compra.getFullYear(),
      compra.getMonth(),
      cartao.closingDay
    );
    
    // Se comprou APÓS o fechamento, pula para o próximo mês
    if (compra.getDate() > cartao.closingDay) {
      dataFechamento.setMonth(dataFechamento.getMonth() + 1);
    }
    
    // Calcular data de vencimento
    const dataVencimento = new Date(
      dataFechamento.getFullYear(),
      dataFechamento.getMonth(),
      cartao.dueDay
    );
    
    // Avançar para o mês seguinte se o dia de vencimento for menor que o de fechamento
    if (cartao.dueDay < cartao.closingDay) {
      dataVencimento.setMonth(dataVencimento.getMonth() + 1);
    }
    
    return dataVencimento;
  };

  // Função para calcular o mês de exibição de acordo com a regra de fechamento
  const calcularMesExibicao = (dataCompra, cartao) => {
    // Determinar o mês em que a fatura será paga (mês de exibição)
    const compra = dataCompra instanceof Date ? dataCompra : parseLocalDateString(dataCompra);
    if (!compra || !cartao) return compra.getMonth();
    
    // Data de vencimento
    const vencimento = calcularVencimentoReal(compra, cartao);
    if (!vencimento) return compra.getMonth();
    
    // Retornar o mês da data de vencimento
    return vencimento.getMonth();
  };

  // Função para carregar categorias, métodos de pagamento e pessoas
  const loadCategoriesAndPaymentMethods = async () => {
    try {
      // Carregar categorias
      const categoriesSnapshot = await db.collection('categories').get();
      
      if (!categoriesSnapshot.empty) {
        // Limpar categorias padrão
        state.categories.income = [];
        state.categories.expense = [];
        state.categories.investment = []; // Limpar categorias de investimento
        
        categoriesSnapshot.docs.forEach(doc => {
          const category = { id: doc.id, ...doc.data() };
          if (category.type === 'income') {
            state.categories.income.push(category);
          } else if (category.type === 'expense') {
            state.categories.expense.push(category);
          } else if (category.type === 'investment') {
            state.categories.investment.push(category);
          }
        });
      } else {
        // Se não houver categorias salvas, salvar as categorias padrão
        const batch = db.batch();
        
        // Salvar categorias de receita
        state.categories.income.forEach(category => {
          const docRef = db.collection('categories').doc(category.id);
          batch.set(docRef, { ...category, type: 'income' });
        });
        
        // Salvar categorias de despesa
        state.categories.expense.forEach(category => {
          const docRef = db.collection('categories').doc(category.id);
          batch.set(docRef, { ...category, type: 'expense' });
        });
        
        // Salvar categorias de investimento
        state.categories.investment.forEach(category => {
          const docRef = db.collection('categories').doc(category.id);
          batch.set(docRef, { ...category, type: 'investment' });
        });
        
        await batch.commit();
      }
      
      // Carregar métodos de pagamento
      const paymentMethodsSnapshot = await db.collection('paymentMethods').get();
      
      if (!paymentMethodsSnapshot.empty) {
        state.paymentMethods = [];
        paymentMethodsSnapshot.docs.forEach(doc => {
          state.paymentMethods.push({ id: doc.id, ...doc.data() });
        });
      } else {
        // Se não houver métodos de pagamento salvos, salvar os padrão
        const batch = db.batch();
        
        state.paymentMethods.forEach(method => {
          const docRef = db.collection('paymentMethods').doc(method.id);
          batch.set(docRef, method);
        });
        
        await batch.commit();
      }
      
      // Carregar pessoas
      const peopleSnapshot = await db.collection('people').get();
      
      if (!peopleSnapshot.empty) {
        state.people = [];
        peopleSnapshot.docs.forEach(doc => {
          state.people.push({ id: doc.id, ...doc.data() });
        });
      } else {
        // Se não houver pessoas salvas, salvar as padrão
        const batch = db.batch();
        
        state.people.forEach(person => {
          const docRef = db.collection('people').doc(person.id);
          batch.set(docRef, person);
        });
        
        await batch.commit();
      }
      
      updateCategorySelects();
      updatePaymentMethodSelects();
      updatePeopleSelects();
      
      // AJUSTE 9: Corrigir bug de categorias - carregar todas imediatamente
      renderCategoriesList();
      renderPaymentMethodsList();
      renderInvestmentCategoriesList();
      updatePeopleList();
      
    } catch (error) {
      console.error('Erro ao carregar categorias e métodos de pagamento:', error);
      showToast('Erro ao carregar categorias. Tente novamente.', 'error');
    }
  };

  // Atualizar selects de categorias
  const updateCategorySelects = () => {
    // Selects de categorias de receita
    const incomeSelects = [
      $('#incomeCategory'),
      $('#editCategory')
    ];
    
    incomeSelects.forEach(select => {
      if (select && select.id === 'editCategory' && select.dataset.type === 'expense') {
        return; // Pular se for select de edição para despesa
      }
      
      if (select) {
        select.innerHTML = '';
        
        state.categories.income.forEach(category => {
          const option = document.createElement('option');
          option.value = category.id;
          option.textContent = `${category.icon || ''} ${category.name}`;
          select.appendChild(option);
        });
      }
    });
    
    // Selects de categorias de despesa
    const expenseSelects = [
      $('#expenseCategory'),
      $('#editCategory')
    ];
    
    expenseSelects.forEach(select => {
      if (select && select.id === 'editCategory' && select.dataset.type === 'income') {
        return; // Pular se for select de edição para receita
      }
      
      if (select) {
        select.innerHTML = '';
        
        state.categories.expense.forEach(category => {
          const option = document.createElement('option');
          option.value = category.id;
          option.textContent = `${category.icon || ''} ${category.name}`;
          select.appendChild(option);
        });
      }
    });
    
    // Selects de categorias de investimento
    const investmentSelects = [
      $('#investmentCategory')
    ];
    
    investmentSelects.forEach(select => {
      if (select) {
        select.innerHTML = '';
        
        state.categories.investment.forEach(category => {
          const option = document.createElement('option');
          option.value = category.id;
          option.textContent = `${category.icon || ''} ${category.name}`;
          select.appendChild(option);
        });
      }
    });
  };

  // Atualizar selects de formas de pagamento
  const updatePaymentMethodSelects = () => {
    const paymentMethodSelects = [
      $('#incomePaymentMethod'),
      $('#expensePaymentMethod'),
      $('#editPaymentMethod')
    ];
    
    paymentMethodSelects.forEach(select => {
      if (select) {
        select.innerHTML = '';
        
        state.paymentMethods.forEach(method => {
          const option = document.createElement('option');
          option.value = method.id;
          option.textContent = `${method.icon || ''} ${method.name}`;
          select.appendChild(option);
        });
      }
    });
  };

  // Atualizar selects de pessoas
  const updatePeopleSelects = () => {
    const peopleSelects = [
      $('#expensePerson'),
      $('#editPerson')
    ];
    
    peopleSelects.forEach(select => {
      if (select) {
        select.innerHTML = '';
        
        // Adicionar opção padrão
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = 'Selecione...';
        select.appendChild(defaultOption);
        
        state.people.forEach(person => {
          const option = document.createElement('option');
          option.value = person.id;
          option.textContent = `${person.icon || ''} ${person.name}`;
          select.appendChild(option);
        });
      }
    });
  };

  // Função para carregar cartões
  const loadCards = async () => {
    try {
      const snapshot = await db.collection('cards').get();
      
      state.cards = [];
      
      if (!snapshot.empty) {
        snapshot.docs.forEach(doc => {
          const card = { id: doc.id, ...doc.data() };
          // Calcular limite disponível
          if (!card.availableLimit) {
            card.availableLimit = card.limit;
          }
          // Inicializar fatura atual se não existir
          if (!card.currentInvoice) {
            card.currentInvoice = 0;
          }
          state.cards.push(card);
        });
      }
      
      // Atualizar UI
      updateCardsList();
      updateCreditCardSelects();
      updateKPIs();
      
    } catch (error) {
      console.error('Erro ao carregar cartões:', error);
      showToast('Erro ao carregar cartões. Tente novamente.', 'error');
    }
  };

  // Função para adicionar cartão
  const addCard = async (cardData) => {
    try {
      // Criar objeto do cartão
      const card = {
        ...cardData,
        availableLimit: cardData.limit,
        currentInvoice: 0,
        createdAt: new Date().toISOString()
      };
      
      // Salvar no Firestore
      const docRef = await db.collection('cards').add(card);
      
      // Atualizar o ID
      card.id = docRef.id;
      
      // Adicionar ao estado local
      state.cards.push(card);
      
      // Atualizar UI
      updateCardsList();
      updateCreditCardSelects();
      
      showToast('Cartão adicionado com sucesso!', 'success');
      
    } catch (error) {
      console.error('Erro ao adicionar cartão:', error);
      showToast('Erro ao adicionar cartão. Tente novamente.', 'error');
    }
  };

  // Função para atualizar cartão
  const updateCard = async (cardId, updates) => {
    try {
      // Atualizar no Firestore
      await db.collection('cards').doc(cardId).update(updates);
      
      // Atualizar no estado local
      const index = state.cards.findIndex(c => c.id === cardId);
      
      if (index !== -1) {
        state.cards[index] = { ...state.cards[index], ...updates };
      }
      
      // Atualizar UI
      updateCardsList();
      updateCreditCardSelects();
      
      showToast('Cartão atualizado com sucesso!', 'success');
      
    } catch (error) {
      console.error('Erro ao atualizar cartão:', error);
      showToast('Erro ao atualizar cartão. Tente novamente.', 'error');
    }
  };

  // Função para excluir cartão
  const deleteCard = async (cardId) => {
    try {
      // Verificar se há transações vinculadas
      const transactionsWithCard = state.transactions.filter(t => 
        t.type === 'expense' && 
        t.paymentMethod === 'credito' && 
        t.creditCardId === cardId
      );
      
      if (transactionsWithCard.length > 0) {
        if (!confirm(`Este cartão possui ${transactionsWithCard.length} transações vinculadas. Deseja excluir mesmo assim?`)) {
          return;
        }
        
        // Atualizar as transações para remover a referência ao cartão
        const batch = db.batch();
        
        transactionsWithCard.forEach(transaction => {
          const docRef = db.collection('transactions').doc(transaction.id);
          batch.update(docRef, { 
            paymentMethod: 'outros',
            creditCardId: null,
            creditCardName: null
          });
          
          // Atualizar no estado local
          const index = state.transactions.findIndex(t => t.id === transaction.id);
          if (index !== -1) {
            state.transactions[index].paymentMethod = 'outros';
            state.transactions[index].creditCardId = null;
            state.transactions[index].creditCardName = null;
          }
        });
        
        await batch.commit();
      }
      
      // Excluir o cartão
      await db.collection('cards').doc(cardId).delete();
      
      // Remover do estado local
      state.cards = state.cards.filter(c => c.id !== cardId);
      
      // Atualizar UI
      updateCardsList();
      updateCreditCardSelects();
      filterTransactionsByMonth();
      updateKPIs();
      
      showToast('Cartão excluído com sucesso!', 'success');
      
    } catch (error) {
      console.error('Erro ao excluir cartão:', error);
      showToast('Erro ao excluir cartão. Tente novamente.', 'error');
    }
  };

  // Função para pagar fatura do cartão
  const payCardInvoice = async (cardId) => {
    try {
      const card = state.cards.find(c => c.id === cardId);
      
      if (!card) {
        showToast('Cartão não encontrado.', 'error');
        return;
      }
      
      // Encontrar todas as transações da fatura atual
      const today = new Date();
      let closingDate = new Date(today.getFullYear(), today.getMonth(), card.closingDay);
      
      // Se hoje é após o dia de fechamento, a data de fechamento será no próximo mês
      if (today.getDate() > card.closingDay) {
        closingDate.setMonth(closingDate.getMonth() + 1);
      }

      // Data de fechamento anterior
      const previousClosing = new Date(closingDate);
      previousClosing.setMonth(previousClosing.getMonth() - 1);
      
      // Buscar transações do período
      const invoiceTransactions = state.transactions.filter(t => 
        t.type === 'expense' && 
        t.paymentMethod === 'credito' && 
        t.creditCardId === card.id &&
        parseLocalDateString(t.date) >= previousClosing &&
        parseLocalDateString(t.date) < closingDate
      );
      
      if (invoiceTransactions.length === 0) {
        showToast('Não há despesas pendentes para esta fatura.', 'info');
        closeModal('payInvoiceConfirmModal');
        return;
      }
      
      // Marcar todas as transações como pagas
      const batch = db.batch();
      
      invoiceTransactions.forEach(transaction => {
        const docRef = db.collection('transactions').doc(transaction.id);
        batch.update(docRef, { status: 'paid' });
        
        // Atualizar no estado local
        const index = state.transactions.findIndex(t => t.id === transaction.id);
        if (index !== -1) {
          state.transactions[index].status = 'paid';
        }
      });
      
      // Resetar a fatura atual do cartão
      const cardRef = db.collection('cards').doc(cardId);
      batch.update(cardRef, { 
        currentInvoice: 0,
        availableLimit: card.limit // Restaurar o limite disponível
      });
      
      // Atualizar no estado local
      const cardIndex = state.cards.findIndex(c => c.id === cardId);
      if (cardIndex !== -1) {
        state.cards[cardIndex].currentInvoice = 0;
        state.cards[cardIndex].availableLimit = card.limit;
      }
      
      await batch.commit();
      
      // Atualizar UI
      updateCardsList();
      updateTransactionsTable();
      updateKPIs();
      updateCharts();
      
      closeModal('payInvoiceConfirmModal');
      showToast('Fatura paga com sucesso!', 'success');
      
    } catch (error) {
      console.error('Erro ao pagar fatura:', error);
      showToast('Erro ao pagar fatura. Tente novamente.', 'error');
    }
  };

  // Função para atualizar os selects de cartões de crédito
  const updateCreditCardSelects = () => {
    const cardSelects = [
      $('#expenseCreditCard'),
      $('#editCreditCard')
    ];
    
    cardSelects.forEach(select => {
      if (select) {
        select.innerHTML = '';
        
        if (state.cards.length === 0) {
          // Adicionar opção de placeholder se não houver cartões
          const option = document.createElement('option');
          option.value = '';
          option.textContent = 'Nenhum cartão cadastrado';
          option.disabled = true;
          option.selected = true;
          select.appendChild(option);
        } else {
          state.cards.forEach(card => {
            const option = document.createElement('option');
            option.value = card.id;
            option.textContent = `${card.name} (Disp: ${formatCurrency(card.availableLimit)})`;
            select.appendChild(option);
          });
        }
      }
    });
  };

  // AJUSTE 6: Funções para investimentos 
  const loadInvestments = async () => {
    try {
      // Carregar investimentos
      const investmentsSnapshot = await db.collection('investments').get();
      
      state.investments = [];
      
      if (!investmentsSnapshot.empty) {
        investmentsSnapshot.docs.forEach(doc => {
          const investment = { id: doc.id, ...doc.data() };
          state.investments.push(investment);
        });
      }
      
      // Carregar contribuições
      const contributionsSnapshot = await db.collection('investmentContributions').get();
      
      state.investmentContributions = [];
      
      if (!contributionsSnapshot.empty) {
        contributionsSnapshot.docs.forEach(doc => {
          const contribution = { id: doc.id, ...doc.data() };
          state.investmentContributions.push(contribution);
        });
      }
      
      // Renderizar cards de investimentos
      renderInvestmentCards();
      
    } catch (error) {
      console.error('Erro ao carregar investimentos:', error);
      showToast('Erro ao carregar investimentos. Tente novamente.', 'error');
    }
  };

  const renderInvestmentCards = () => {
    const grid = $('#investmentsGrid');
    if (!grid) return;
    
    grid.innerHTML = '';
    
    if (state.investments.length === 0) {
      grid.innerHTML = '<p style="text-align: center; padding: var(--spacing-xl);">Nenhum investimento cadastrado. Clique em "Novo Investimento" para começar.</p>';
      return;
    }
    
    state.investments.forEach(investment => {
      // Calcular valor total das contribuições
      const contributions = state.investmentContributions.filter(c => c.investmentId === investment.id);
      const totalContributed = contributions.reduce((sum, c) => sum + parseFloat(c.amount), 0) + parseFloat(investment.amount || 0);
      
      // Calcular progresso
      const hasGoal = investment.goal && parseFloat(investment.goal) > 0;
      const progress = hasGoal ? (totalContributed / parseFloat(investment.goal)) * 100 : 0;
      
      // Buscar categoria
      const category = state.categories.investment.find(c => c.id === investment.category);
      
      const card = document.createElement('div');
      card.className = 'investment-card';
      card.dataset.id = investment.id;
      
      card.innerHTML = `
        <div class="investment-card-header">
          <h3 class="investment-card-title">${investment.name}</h3>
          <div class="category-badge" style="background-color: var(--color-surface-variant); padding: var(--spacing-2xs) var(--spacing-xs); border-radius: var(--radius-full); font-size: var(--font-size-xs);">
            ${category ? `${category.icon} ${category.name}` : 'Categoria'}
          </div>
        </div>
        
        <div class="investment-card-body">
          <div style="margin-bottom: var(--spacing-xs);">
            <div>Guardado: <strong>${formatCurrency(totalContributed)}</strong></div>
            ${hasGoal ? `<div>Meta: <strong>${formatCurrency(investment.goal)}</strong></div>` : ''}
          </div>
          
          ${hasGoal ? `
          <div class="investment-progress">
            <div class="investment-progress-bar">
              <div class="investment-progress-fill" style="width: ${progress}%;"></div>
            </div>
            <div class="investment-progress-text">
              <span>Progresso: ${progress.toFixed(0)}%</span>
              ${investment.targetDate ? `<span>Até: ${formatDate(investment.targetDate)}</span>` : ''}
            </div>
          </div>
          ` : ''}
        </div>
        
        <div class="investment-card-footer">
          <div style="color: var(--color-on-surface-variant); font-size: var(--font-size-xs);">
            Criado em: ${formatDate(investment.createdAt || new Date())}
          </div>
          <div>
            <button class="btn btn-icon btn-outline edit-investment-btn">
              <svg width="16" height="16">
                <use href="#icon-edit"></use>
              </svg>
            </button>
            <button class="btn btn-icon btn-outline delete-investment-btn">
              <svg width="16" height="16">
                <use href="#icon-trash"></use>
              </svg>
            </button>
          </div>
        </div>
      `;
      
      grid.appendChild(card);
    });
    
    // Adicionar event listeners
    $$('.investment-card').forEach(card => {
      card.addEventListener('click', (e) => {
        // Ignorar cliques nos botões de edição e exclusão
        if (e.target.closest('.edit-investment-btn') || e.target.closest('.delete-investment-btn')) {
          return;
        }
        
        const id = card.dataset.id;
        openInvestmentDetail(id);
      });
    });
    
    $$('.edit-investment-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const card = e.target.closest('.investment-card');
        const id = card.dataset.id;
        openEditInvestmentModal(id);
      });
    });
    
    $$('.delete-investment-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const card = e.target.closest('.investment-card');
        const id = card.dataset.id;
        if (confirm('Deseja realmente excluir este investimento? Esta ação é irreversível.')) {
          deleteInvestment(id);
        }
      });
    });
  };

  const openInvestmentDetail = (investmentId) => {
    const investment = state.investments.find(i => i.id === investmentId);
    if (!investment) return;
    
    state.currentInvestment = investment;
    
    // Buscar categoria
    const category = state.categories.investment.find(c => c.id === investment.category);
    
    // Calcular valor total das contribuições
    const contributions = state.investmentContributions.filter(c => c.investmentId === investment.id);
    const totalContributed = contributions.reduce((sum, c) => sum + parseFloat(c.amount), 0) + parseFloat(investment.amount || 0);
    
    // Calcular progresso
    const hasGoal = investment.goal && parseFloat(investment.goal) > 0;
    const progress = hasGoal ? (totalContributed / parseFloat(investment.goal)) * 100 : 0;
    
    // Preencher detalhes do investimento
    $('#investmentDetailName').textContent = investment.name;
    $('#investmentDetailSaved').textContent = formatCurrency(totalContributed);
    $('#investmentDetailGoal').textContent = hasGoal ? formatCurrency(investment.goal) : 'Não definido';
    $('#investmentDetailProgress').textContent = hasGoal ? `${progress.toFixed(0)}%` : 'N/A';
    $('#investmentDetailCategory').textContent = category ? `${category.icon} ${category.name}` : 'Não definido';
    $('#investmentDetailCreatedAt').textContent = formatDate(investment.createdAt || new Date());
    $('#investmentDetailTarget').textContent = investment.targetDate ? formatDate(investment.targetDate) : 'Não definido';
    $('#investmentDetailNotes').textContent = investment.notes || 'Sem observações';
    
    // Renderizar histórico de aportes
    renderInvestmentContributions(investmentId);
    
    // Fechar modal principal de investimentos
    closeModal('investmentsModal');
    
    // Abrir modal de detalhes
    openModal('investmentDetailModal');
  };

  const renderInvestmentContributions = (investmentId) => {
    const tableBody = $('#investmentHistoryTableBody');
    if (!tableBody) return;
    
    tableBody.innerHTML = '';
    
    // Buscar contribuições
    const contributions = state.investmentContributions.filter(c => c.investmentId === investmentId);
    
    // Adicionar valor inicial como primeira "contribuição"
    const investment = state.investments.find(i => i.id === investmentId);
    if (investment && parseFloat(investment.amount) > 0) {
      const initialRow = document.createElement('tr');
      initialRow.innerHTML = `
        <td>${formatDate(investment.createdAt || new Date())}</td>
        <td>${formatCurrency(investment.amount)}</td>
        <td>Depósito inicial</td>
        <td>-</td>
      `;
      tableBody.appendChild(initialRow);
    }
    
    // Ordenar contribuições por data (mais recentes primeiro)
    contributions.sort((a, b) => {
      const dateA = parseLocalDateString(a.date);
      const dateB = parseLocalDateString(b.date);
      return dateB - dateA;
    });
    
    if (contributions.length === 0 && (!investment || parseFloat(investment.amount) <= 0)) {
      tableBody.innerHTML = '<tr><td colspan="4" style="text-align: center; padding: var(--spacing-md);">Nenhum aporte realizado.</td></tr>';
      return;
    }
    
    contributions.forEach(contribution => {
      const row = document.createElement('tr');
      row.dataset.id = contribution.id;
      
      row.innerHTML = `
        <td>${formatDate(contribution.date)}</td>
        <td>${formatCurrency(contribution.amount)}</td>
        <td>${contribution.description || '-'}</td>
        <td>
          <div class="actions-cell">
            <button class="btn btn-icon btn-outline edit-contribution-btn">
              <svg width="16" height="16">
                <use href="#icon-edit"></use>
              </svg>
            </button>
            <button class="btn btn-icon btn-outline delete-contribution-btn">
              <svg width="16" height="16">
                <use href="#icon-trash"></use>
              </svg>
            </button>
          </div>
        </td>
      `;
      
      tableBody.appendChild(row);
    });
    
    // Adicionar event listeners
    $$('.edit-contribution-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const row = e.target.closest('tr');
        const id = row.dataset.id;
        const contribution = state.investmentContributions.find(c => c.id === id);
        if (contribution) {
          openEditContributionModal(contribution);
        }
      });
    });
    
    $$('.delete-contribution-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const row = e.target.closest('tr');
        const id = row.dataset.id;
        if (confirm('Deseja realmente excluir este aporte? Esta ação é irreversível.')) {
          deleteContribution(id);
        }
      });
    });
  };

  const addInvestment = async (investmentData) => {
    try {
      // Criar objeto do investimento
      const investment = {
        ...investmentData,
        createdAt: localDateToISOString(new Date())
      };
      
      // Salvar no Firestore
      const docRef = await db.collection('investments').add(investment);
      
      // Atualizar o ID
      investment.id = docRef.id;
      
      // Adicionar ao estado local
      state.investments.push(investment);
      
      // Atualizar UI
      renderInvestmentCards();
      
      showToast('Investimento adicionado com sucesso!', 'success');
      
      return investment;
      
    } catch (error) {
      console.error('Erro ao adicionar investimento:', error);
      showToast('Erro ao adicionar investimento. Tente novamente.', 'error');
      return null;
    }
  };

  const updateInvestment = async (investmentId, updates) => {
    try {
      // Atualizar no Firestore
      await db.collection('investments').doc(investmentId).update(updates);
      
      // Atualizar no estado local
      const index = state.investments.findIndex(i => i.id === investmentId);
      
      if (index !== -1) {
        state.investments[index] = { ...state.investments[index], ...updates };
      }
      
      // Atualizar UI
      renderInvestmentCards();
      
      showToast('Investimento atualizado com sucesso!', 'success');
      
      return true;
      
    } catch (error) {
      console.error('Erro ao atualizar investimento:', error);
      showToast('Erro ao atualizar investimento. Tente novamente.', 'error');
      return false;
    }
  };

  const deleteInvestment = async (investmentId) => {
    try {
      // Verificar se há contribuições vinculadas
      const contributions = state.investmentContributions.filter(c => c.investmentId === investmentId);
      
      if (contributions.length > 0) {
        // Excluir contribuições
        const batch = db.batch();
        
        contributions.forEach(contribution => {
          const docRef = db.collection('investmentContributions').doc(contribution.id);
          batch.delete(docRef);
        });
        
        await batch.commit();
        
        // Remover do estado local
        state.investmentContributions = state.investmentContributions.filter(c => c.investmentId !== investmentId);
      }
      
      // Excluir o investimento
      await db.collection('investments').doc(investmentId).delete();
      
      // Remover do estado local
      state.investments = state.investments.filter(i => i.id !== investmentId);
      
      // Atualizar UI
      renderInvestmentCards();
      
      // Fechar modal de detalhes se estiver aberto
      if (state.currentInvestment && state.currentInvestment.id === investmentId) {
        closeModal('investmentDetailModal');
        openModal('investmentsModal');
      }
      
      showToast('Investimento excluído com sucesso!', 'success');
      
    } catch (error) {
      console.error('Erro ao excluir investimento:', error);
      showToast('Erro ao excluir investimento. Tente novamente.', 'error');
    }
  };

  const addContribution = async (contributionData) => {
    try {
      // Criar objeto da contribuição
      const contribution = {
        ...contributionData,
        createdAt: localDateToISOString(new Date())
      };
      
      // Salvar no Firestore
      const docRef = await db.collection('investmentContributions').add(contribution);
      
      // Atualizar o ID
      contribution.id = docRef.id;
      
      // Adicionar ao estado local
      state.investmentContributions.push(contribution);
      
      // Atualizar UI
      renderInvestmentContributions(contribution.investmentId);
      
      // Se um detalhe de investimento estiver aberto, atualizar a visualização
      if (state.currentInvestment && state.currentInvestment.id === contribution.investmentId) {
        openInvestmentDetail(contribution.investmentId);
      }
      
      showToast('Aporte adicionado com sucesso!', 'success');
      
      return contribution;
      
    } catch (error) {
      console.error('Erro ao adicionar aporte:', error);
      showToast('Erro ao adicionar aporte. Tente novamente.', 'error');
      return null;
    }
  };

  const updateContribution = async (contributionId, updates) => {
    try {
      // Atualizar no Firestore
      await db.collection('investmentContributions').doc(contributionId).update(updates);
      
      // Atualizar no estado local
      const index = state.investmentContributions.findIndex(c => c.id === contributionId);
      
      if (index !== -1) {
        state.investmentContributions[index] = { ...state.investmentContributions[index], ...updates };
      }
      
      // Atualizar UI
      if (state.currentInvestment) {
        renderInvestmentContributions(state.currentInvestment.id);
        openInvestmentDetail(state.currentInvestment.id);
      }
      
      showToast('Aporte atualizado com sucesso!', 'success');
      
      return true;
      
    } catch (error) {
      console.error('Erro ao atualizar aporte:', error);
      showToast('Erro ao atualizar aporte. Tente novamente.', 'error');
      return false;
    }
  };

  const deleteContribution = async (contributionId) => {
    try {
      const contribution = state.investmentContributions.find(c => c.id === contributionId);
      if (!contribution) return;
      
      // Excluir a contribuição
      await db.collection('investmentContributions').doc(contributionId).delete();
      
      // Remover do estado local
      state.investmentContributions = state.investmentContributions.filter(c => c.id !== contributionId);
      
      // Atualizar UI
      if (state.currentInvestment) {
        renderInvestmentContributions(state.currentInvestment.id);
        openInvestmentDetail(state.currentInvestment.id);
      }
      
      showToast('Aporte excluído com sucesso!', 'success');
      
    } catch (error) {
      console.error('Erro ao excluir aporte:', error);
      showToast('Erro ao excluir aporte. Tente novamente.', 'error');
    }
  };

  const openNewInvestmentModal = () => {
    // Resetar formulário
    $('#investmentForm').reset();
    
    // Definir data padrão (hoje)
    const today = new Date();
    setDateInputValue('investmentTargetDate', today);
    
    // Alterar título e botão
    $('.modal-title', $('#newInvestmentModal')).textContent = 'Novo Investimento';
    $('#saveInvestmentBtn').textContent = 'Salvar Investimento';
    
    // Configurar botão de salvar para adicionar
    $('#saveInvestmentBtn').dataset.action = 'add';
    $('#saveInvestmentBtn').removeAttribute('data-id');
    
    // Abrir modal
    closeModal('investmentsModal');
    openModal('newInvestmentModal');
  };

  const openEditInvestmentModal = (investmentId) => {
    const investment = state.investments.find(i => i.id === investmentId);
    if (!investment) return;
    
    state.currentInvestment = investment;
    
    // Preencher formulário
    $('#investmentName').value = investment.name;
    $('#investmentAmount').value = investment.amount || 0;
    $('#investmentGoal').value = investment.goal || '';
    $('#investmentCategory').value = investment.category || '';
    if (investment.targetDate) {
      setDateInputValue('investmentTargetDate', investment.targetDate);
    }
    $('#investmentNotes').value = investment.notes || '';
    
    // Alterar título e botão
    $('.modal-title', $('#newInvestmentModal')).textContent = 'Editar Investimento';
    $('#saveInvestmentBtn').textContent = 'Atualizar Investimento';
    
    // Configurar botão de salvar para atualizar
    $('#saveInvestmentBtn').dataset.action = 'update';
    $('#saveInvestmentBtn').dataset.id = investment.id;
    
    // Abrir modal
    closeModal('investmentDetailModal');
    openModal('newInvestmentModal');
  };

  const openNewContributionModal = () => {
    // Resetar formulário
    $('#contributionForm').reset();
    
    // Definir data padrão (hoje)
    const today = new Date();
    setDateInputValue('contributionDate', today);
    
    // Definir investimento atual
    $('#contributionInvestmentId').value = state.currentInvestment?.id || '';
    
    // Abrir modal
    openModal('newContributionModal');
  };

  const openEditContributionModal = (contribution) => {
    state.currentContribution = contribution;
    
    // Preencher formulário
    $('#contributionInvestmentId').value = contribution.investmentId;
    $('#contributionAmount').value = contribution.amount;
    $('#contributionDescription').value = contribution.description || '';
    setDateInputValue('contributionDate', contribution.date);
    
    // Alterar título e botão
    $('.modal-title', $('#newContributionModal')).textContent = 'Editar Aporte';
    $('#saveContributionBtn').textContent = 'Atualizar';
    $('#saveContributionBtn').dataset.action = 'update';
    $('#saveContributionBtn').dataset.id = contribution.id;
    
    // Abrir modal
    openModal('newContributionModal');
  };

  // Funções para transações
  const loadTransactions = async () => {
    try {
      const snapshot = await db.collection('transactions').get();
      
      state.transactions = [];
      
      if (!snapshot.empty) {
        snapshot.docs.forEach(doc => {
          const transaction = { id: doc.id, ...doc.data() };
          state.transactions.push(transaction);
        });
      }
      
      // Filtrar por mês atual
      filterTransactionsByMonth();
      
      // Atualizar UI
      updateTransactionsTable();
      updateKPIs();
      updateCharts();
      renderCommitments();
      generateInsights();
      
    } catch (error) {
      console.error('Erro ao carregar transações:', error);
      showToast('Erro ao carregar transações. Tente novamente.', 'error');
    }
  };

  // Filtrar transações por mês/ano corrigido para incluir regra do cartão 
  const filterTransactionsByMonth = () => {
    state.filteredTransactions = state.transactions.filter(transaction => {
      const date = parseLocalDateString(transaction.date);
      if (!date) return false;
      
      // Para transações comuns, verificar apenas mês e ano
      if (transaction.type !== 'expense' || transaction.paymentMethod !== 'credito' || !transaction.creditCardId) {
        return date.getMonth() === state.month && date.getFullYear() === state.year;
      }
      
      // Para despesas de cartão de crédito, usar a regra de fechamento para determinar o mês de exibição
      const card = state.cards.find(c => c.id === transaction.creditCardId);
      if (!card) return date.getMonth() === state.month && date.getFullYear() === state.year;
      
      // Calcular a data de vencimento real baseada no cartão
      const vencimento = calcularVencimentoReal(date, card);
      if (!vencimento) return date.getMonth() === state.month && date.getFullYear() === state.year;
      
      // Exibir a transação no mês do vencimento
      return vencimento.getMonth() === state.month && vencimento.getFullYear() === state.year;
    });

    // Ordenar por data (mais recentes primeiro)
    state.filteredTransactions.sort((a, b) => {
      const dateA = parseLocalDateString(a.date);
      const dateB = parseLocalDateString(b.date);
      return dateB - dateA;
    });

    // Atualizar a UI
    updateTransactionsTable();
    updateKPIs();
    updateCharts();
  };

  // Atualizar título do mês/ano
  const updateMonthYearTitle = () => {
    const monthNames = [
      'Janeiro', 'Fevereiro', 'Março', 'Abril',
      'Maio', 'Junho', 'Julho', 'Agosto',
      'Setembro', 'Outubro', 'Novembro', 'Dezembro'
    ];

    // Se houver um elemento para o título
    const titleElement = $('#monthYearTitle');
    if (titleElement) {
      titleElement.textContent = `${monthNames[state.month]} de ${state.year}`;
    }
  };

  // Atualizar KPIs (indicadores chave)
  const updateKPIs = () => {
    // Cálculos para o mês atual filtrado
    const totalIncome = state.filteredTransactions
      .filter(t => t.type === 'income')
      .reduce((sum, t) => sum + parseFloat(t.amount), 0);

    const totalExpense = state.filteredTransactions
      .filter(t => t.type === 'expense')
      .reduce((sum, t) => sum + parseFloat(t.amount), 0);

    const incomeReceived = state.filteredTransactions
      .filter(t => t.type === 'income' && t.status === 'received')
      .reduce((sum, t) => sum + parseFloat(t.amount), 0);

    const incomePending = state.filteredTransactions
      .filter(t => t.type === 'income' && t.status !== 'received')
      .reduce((sum, t) => sum + parseFloat(t.amount), 0);

    const expensePaid = state.filteredTransactions
      .filter(t => t.type === 'expense' && t.status === 'paid')
      .reduce((sum, t) => sum + parseFloat(t.amount), 0);

    const expensePending = state.filteredTransactions
      .filter(t => t.type === 'expense' && t.status !== 'paid')
      .reduce((sum, t) => sum + parseFloat(t.amount), 0);

    // Calcular saldo real e saldo comprometido
    const saldoReal = incomeReceived - expensePaid;
    const saldoComprometido = (totalIncome - totalExpense);

    // Atualizar elementos da UI
    if ($('#incomeValue')) $('#incomeValue').textContent = formatCurrency(totalIncome);
    if ($('#expenseValue')) $('#expenseValue').textContent = formatCurrency(totalExpense);

    // Atualizar o título do KPI
    if ($('#balanceValue')) {
      $('#balanceValue').textContent = formatCurrency(saldoReal);
      const kpiTitle = $('.kpi-balance .kpi-title');
      if (kpiTitle) {
        kpiTitle.textContent = 'Saldo Real (Caixa)';
      }
      
      // Adicionar tooltip para saldo comprometido
      const kpiSubtitle = $('.kpi-balance .kpi-subtitle');
      if (kpiSubtitle) {
        kpiSubtitle.innerHTML = `
          <svg width="16" height="16">
            <use href="#icon-info"></use>
          </svg>
          <span>Saldo comprometido: ${formatCurrency(saldoComprometido)}</span>
        `;
      }
    }
    
    if ($('#incomeReceivedValue')) $('#incomeReceivedValue').textContent = `${formatCurrency(incomeReceived)} recebidos`;
    if ($('#incomePendingValue')) $('#incomePendingValue').textContent = `${formatCurrency(incomePending)} pendentes`;
    
    if ($('#expensePaidValue')) $('#expensePaidValue').textContent = `${formatCurrency(expensePaid)} pagos`;
    if ($('#expensePendingValue')) $('#expensePendingValue').textContent = `${formatCurrency(expensePending)} pendentes`;
    
    // Calcular o total de faturas de cartão de crédito para o mês selecionado
    let monthlyInvoiceTotal = 0;
    const targetYear = state.year;
    const targetMonth = state.month;

    if (state.cards.length > 0) {
      // Filtrar transações do mês atual que são despesas de cartão de crédito
      const creditCardExpenses = state.filteredTransactions.filter(t => 
        t.type === 'expense' && 
        t.paymentMethod === 'credito' && 
        t.status !== 'paid'
      );
      
      // Somar o valor dessas despesas
      monthlyInvoiceTotal = creditCardExpenses.reduce((total, t) => total + parseFloat(t.amount), 0);
      
      // Obter o primeiro cartão para a data de vencimento (ou poderíamos pegar o mais próximo)
      if (state.cards.length > 0) {
        const firstCard = state.cards[0];
        const dueDate = new Date(targetYear, targetMonth, firstCard.dueDay);
        
        if ($('#invoiceDueDate')) {
          $('#invoiceDueDate').textContent = formatDate(dueDate);
        }
      }
    }

    // Atualizar o KPI da Fatura do Mês
    if ($('#invoiceValue')) {
      $('#invoiceValue').textContent = formatCurrency(monthlyInvoiceTotal);
    }
  };

  // Atualizar a lista de cartões
  const updateCardsList = () => {
    const cardsList = $('#cardsList');
    if (!cardsList) return;

    cardsList.innerHTML = '';

    if (state.cards.length === 0) {
      cardsList.innerHTML = '<p style="text-align: center; padding: var(--spacing-md);">Nenhum cartão cadastrado.</p>';
      return;
    }

    // Adicionar sumário de todos os cartões se houver mais de um
    if (state.cards.length > 1) {
      const totalLimit = state.cards.reduce((sum, card) => sum + card.limit, 0);
      const totalAvailable = state.cards.reduce((sum, card) => sum + card.availableLimit, 0);
      const totalInvoice = state.cards.reduce((sum, card) => sum + (card.currentInvoice || 0), 0);
      const limitPercentage = totalLimit > 0 ? ((totalLimit - totalAvailable) / totalLimit) * 100 : 0;

      const summaryElement = document.createElement('div');
      summaryElement.className = 'card';
      summaryElement.style.marginBottom = 'var(--spacing-xl)';
      summaryElement.style.backgroundColor = 'var(--color-surface-variant)';
      summaryElement.style.borderLeft = '4px solid var(--color-primary)';

      summaryElement.innerHTML = `
        <h3 style="margin-bottom: var(--spacing-md);">Resumo de Todos os Cartões</h3>
        
        <div style="margin-bottom: var(--spacing-xs);">
          <div style="display: flex; justify-content: space-between;">
            <span>Limite Total:</span>
            <strong>${formatCurrency(totalLimit)}</strong>
          </div>
          <div style="display: flex; justify-content: space-between;">
            <span>Limite Disponível:</span>
            <strong>${formatCurrency(totalAvailable)}</strong>
          </div>
          <div style="display: flex; justify-content: space-between; margin-top: var(--spacing-xs);">
            <span>Fatura Total:</span>
            <strong>${formatCurrency(totalInvoice)}</strong>
          </div>
        </div>
        
        <div class="commitment-progress" style="margin-top: var(--spacing-md);">
          <div class="commitment-progress-bar" style="width: ${limitPercentage}%; background-color: ${limitPercentage > 70 ? 'var(--color-error)' : 'var(--color-primary)'}"></div>
        </div>
      `;

      cardsList.appendChild(summaryElement);
    }

    state.cards.forEach(card => {
      const cardElement = document.createElement('div');
      cardElement.className = 'card';
      cardElement.style.marginBottom = 'var(--spacing-md)';

      // Calcular datas de fechamento e vencimento
      const today = new Date();
      let closingDate = new Date(today.getFullYear(), today.getMonth(), card.closingDay);

      // Se hoje é após o dia de fechamento, a data de fechamento será no próximo mês
      if (today.getDate() > card.closingDay) {
        closingDate.setMonth(closingDate.getMonth() + 1);
      }

      let dueDate = new Date(today.getFullYear(), today.getMonth(), card.dueDay);

      // Se hoje é após o dia de vencimento, a data de vencimento será no próximo mês
      if (today.getDate() > card.dueDay) {
        dueDate.setMonth(dueDate.getMonth() + 1);
      }

      // Calcular a porcentagem do limite utilizado
      const limitPercentage = card.limit > 0 ? ((card.limit - card.availableLimit) / card.limit) * 100 : 0;

      // Melhor dia para compras simplificado e correto
      const melhorDiaCompras = calcularMelhorDiaCompras(card);

      cardElement.innerHTML = `
        <div style="display: flex; justify-content: space-between; margin-bottom: var(--spacing-md);">
          <h3>${card.name}</h3>
          <div style="display: flex; gap: var(--spacing-xs);">
            <button class="btn btn-icon btn-outline edit-card-btn" data-id="${card.id}">
              <svg width="16" height="16">
                <use href="#icon-edit"></use>
              </svg>
            </button>
            <button class="btn btn-icon btn-outline delete-card-btn" data-id="${card.id}">
              <svg width="16" height="16">
                <use href="#icon-trash"></use>
              </svg>
            </button>
          </div>
        </div>
        
        <div style="margin-bottom: var(--spacing-xs);">
          <div style="display: flex; justify-content: space-between;">
            <span>Limite Total:</span>
            <strong>${formatCurrency(card.limit)}</strong>
          </div>
          <div style="display: flex; justify-content: space-between;">
            <span>Limite Disponível:</span>
            <strong>${formatCurrency(card.availableLimit)}</strong>
          </div>
        </div>
        
        <div class="commitment-progress" style="margin-bottom: var(--spacing-md);">
          <div class="commitment-progress-bar" style="width: ${limitPercentage}%; background-color: ${limitPercentage > 70 ? 'var(--color-error)' : 'var(--color-primary)'}"></div>
        </div>
        
        <div style="display: flex; justify-content: space-between; margin-bottom: var(--spacing-md);">
          <div>
            <small>Fechamento:</small>
            <div>${card.closingDay} (${formatDate(closingDate)})</div>
          </div>
          <div>
            <small>Vencimento:</small>
            <div>${card.dueDay} (${formatDate(dueDate)})</div>
          </div>
        </div>
        
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <div>
            <small>Fatura Atual:</small>
            <div>${formatCurrency(card.currentInvoice || 0)}</div>
          </div>
          <button class="btn btn-primary view-invoice-btn" data-id="${card.id}">Ver Fatura</button>
        </div>
        
        <div style="margin-top: var(--spacing-md); font-size: var(--font-size-xs); color: var(--color-info);">
          <strong>Dica:</strong> Melhor dia para compras: dia ${melhorDiaCompras}
        </div>
      `;

      cardsList.appendChild(cardElement);
    });

    // Adicionar event listeners
    $$('.edit-card-btn').forEach(btn => {
      btn.addEventListener('click', e => {
        const id = e.currentTarget.dataset.id;
        const card = state.cards.find(c => c.id === id);
        
        if (card) {
          openEditCardModal(card);
        }
      });
    });

    $$('.delete-card-btn').forEach(btn => {
      btn.addEventListener('click', e => {
        const id = e.currentTarget.dataset.id;
        deleteCard(id);
      });
    });

    $$('.view-invoice-btn').forEach(btn => {
      btn.addEventListener('click', e => {
        const id = e.currentTarget.dataset.id;
        openCardInvoice(id);
      });
    });
  };

  // Abrir o modal de fatura do cartão
  const openCardInvoice = cardId => {
    const card = state.cards.find(c => c.id === cardId);
    if (!card) return;

    state.currentCard = card;

    // Calcular período da fatura
    const today = new Date();
    let closingDate = new Date(today.getFullYear(), today.getMonth(), card.closingDay);

    // Se hoje é após o dia de fechamento, a data de fechamento será no próximo mês
    if (today.getDate() > card.closingDay) {
      closingDate.setMonth(closingDate.getMonth() + 1);
    }

    // Data de fechamento anterior
    const previousClosing = new Date(closingDate);
    previousClosing.setMonth(previousClosing.getMonth() - 1);

    // Data de vencimento
    let dueDate = new Date(closingDate);
    dueDate.setDate(card.dueDay);

    // Título do modal
    $('#cardInvoiceTitle').textContent = `Fatura do Cartão - ${card.name}`;

    // Detalhes da fatura
    $('#cardInvoiceDetails').innerHTML = `
      <div style="display: flex; justify-content: space-between; margin-bottom: var(--spacing-xs);">
        <div>
          <strong>Período:</strong> ${formatDate(previousClosing)} - ${formatDate(closingDate)}
        </div>
        <div>
          <strong>Vencimento:</strong> ${formatDate(dueDate)}
        </div>
      </div>
      <div style="display: flex; justify-content: space-between;">
        <div>
          <strong>Limite Total:</strong> ${formatCurrency(card.limit)}
        </div>
        <div>
          <strong>Limite Disponível:</strong> ${formatCurrency(card.availableLimit)}
        </div>
      </div>
      <div style="margin-top: var(--spacing-xs);">
        <strong>Valor da Fatura:</strong> ${formatCurrency(card.currentInvoice || 0)}
      </div>
    `;

    // Buscar transações do período
    const invoiceTransactions = state.transactions.filter(t => 
      t.type === 'expense' && 
      t.paymentMethod === 'credito' && 
      t.creditCardId === card.id &&
      parseLocalDateString(t.date) >= previousClosing &&
      parseLocalDateString(t.date) < closingDate
    );

    // Ordenar por data
    invoiceTransactions.sort((a, b) => {
      const dateA = parseLocalDateString(a.date);
      const dateB = parseLocalDateString(b.date);
      return dateB - dateA;
    });

    // Renderizar tabela
    const tableBody = $('#cardInvoiceTableBody');
    tableBody.innerHTML = '';

    if (invoiceTransactions.length === 0) {
      tableBody.innerHTML = `
        <tr>
          <td colspan="5" style="text-align: center; padding: var(--spacing-xl);">
            Nenhuma despesa para esta fatura.
          </td>
        </tr>
      `;
    } else {
      invoiceTransactions.forEach(transaction => {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>
            <div class="transaction-icon" style="background-color: rgba(255, 59, 48, 0.1); color: var(--color-expense);">
              ${transaction.categoryIcon || '📦'}
            </div>
          </td>
          <td>${transaction.name}</td>
          <td>${formatDate(transaction.date)}</td>
          <td>${formatCurrency(transaction.amount)}</td>
          <td>
            <div class="checkbox-wrapper">
              <input type="checkbox" class="checkbox invoice-paid-checkbox" id="invoice-paid-${transaction.id}" 
                    ${transaction.status === 'paid' ? 'checked' : ''}
                    data-id="${transaction.id}">
              <label class="checkbox-label" for="invoice-paid-${transaction.id}"></label>
            </div>
          </td>
        `;
        
        tableBody.appendChild(row);
      });

      // Adicionar event listeners para os checkboxes de pagamento
      $$('.invoice-paid-checkbox').forEach(checkbox => {
        checkbox.addEventListener('change', e => {
          const id = e.target.dataset.id;
          const isChecked = e.target.checked;
          
          updateTransaction(id, { status: isChecked ? 'paid' : 'pending' });
        });
      });
    }

    // Configurar o botão de pagar fatura
    $('#invoiceConfirmAmount').textContent = formatCurrency(card.currentInvoice || 0);

    // Exibir o modal
    closeModal('cardsListModal');
    openModal('cardInvoiceModal');
  };

  // Variáveis globais para gráficos
  let pieChart = null;
  let barChart = null;
  let areaChart = null;
  let fixedVsVariableChart = null; // Gráfico de despesas fixas vs variáveis
  let personAnalysisChart = null; // Gráfico de despesas por pessoa

  // AJUSTE 18: Função para criar gráficos aprimorados
  const createCharts = () => {
    // Configurações de cores baseadas no tema atual
    const isDarkTheme = document.documentElement.getAttribute('data-theme') === 'dark';

    const textColor = isDarkTheme ? '#f5f5f7' : '#1d1d1f';
    const gridColor = isDarkTheme ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';

    // AJUSTE 22: Cores da paleta da Apple para gráficos
    const appleColors = [
      '#007AFF', // azul
      '#34C759', // verde
      '#FF9500', // laranja
      '#FF3B30', // vermelho
      '#AF52DE', // roxo
      '#5E5CE6', // azul índigo
      '#FF2D55', // rosa
      '#FF9F0A', // amarelo
      '#64D2FF', // azul claro
      '#30B0C7'  // azul esverdeado
    ];

    // Configurações comuns para todos os gráficos
    Chart.defaults.color = textColor;
    Chart.defaults.borderColor = gridColor;
    Chart.defaults.font.family = "'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif";

    // Configurar tema para tooltips
    Chart.defaults.plugins.tooltip.backgroundColor = isDarkTheme ? 'rgba(28, 28, 30, 0.95)' : 'rgba(255, 255, 255, 0.95)';
    Chart.defaults.plugins.tooltip.titleColor = textColor;
    Chart.defaults.plugins.tooltip.bodyColor = textColor;
    Chart.defaults.plugins.tooltip.borderColor = isDarkTheme ? 'rgba(255, 255, 255, 0.2)' : 'rgba(0, 0, 0, 0.1)';
    Chart.defaults.plugins.tooltip.borderWidth = 1;
    Chart.defaults.plugins.tooltip.padding = 10;
    Chart.defaults.plugins.tooltip.cornerRadius = 6;
    Chart.defaults.plugins.tooltip.boxPadding = 6;

    try {
      // AJUSTE 9: Aumentar o tamanho dos gráficos para evitar texto cortado
      // AJUSTE 18: Gráfico de pizza aprimorado - Despesas por Categoria
      const pieCtx = document.getElementById('catPie');
      if (pieCtx) {
        pieChart = new Chart(pieCtx.getContext('2d'), {
          type: 'doughnut',
          data: {
            labels: [],
            datasets: [{
              data: [],
              backgroundColor: appleColors,
              borderColor: isDarkTheme ? '#000000' : '#ffffff',
              borderWidth: 2,
              hoverOffset: 16,
              borderRadius: 5
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            cutout: '65%',
            plugins: {
              legend: {
                position: 'bottom',
                labels: {
                  padding: 20,
                  usePointStyle: true,
                  pointStyle: 'circle',
                  color: textColor,
                  font: {
                    size: 12
                  }
                }
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const value = context.parsed;
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = Math.round((value / total) * 100);
                    return `${formatCurrency(value)} (${percentage}%)`;
                  }
                },
                titleColor: textColor,
                bodyColor: textColor
              }
            },
            layout: {
              padding: 15
            }
          }
        });
      }

      // AJUSTE 18: Gráfico de barras aprimorado - Receitas x Despesas (12 meses)
      const barCtx = document.getElementById('annualBars');
      if (barCtx) {
        barChart = new Chart(barCtx.getContext('2d'), {
          type: 'bar',
          data: {
            labels: [],
            datasets: [
              {
                label: 'Receitas',
                data: [],
                backgroundColor: appleColors[1], // verde
                borderColor: appleColors[1],
                borderWidth: 1,
                borderRadius: 6,
                barPercentage: 0.7,
                categoryPercentage: 0.8
              },
              {
                label: 'Despesas',
                data: [],
                backgroundColor: appleColors[3], // vermelho
                borderColor: appleColors[3],
                borderWidth: 1,
                borderRadius: 6,
                barPercentage: 0.7,
                categoryPercentage: 0.8
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
              mode: 'index',
              intersect: false
            },
            scales: {
              x: {
                grid: {
                  display: false,
                  color: gridColor
                },
                ticks: {
                  color: textColor,
                  font: {
                    size: 12
                  }
                }
              },
              y: {
                beginAtZero: true,
                grid: {
                  color: gridColor
                },
                ticks: {
                  color: textColor,
                  font: {
                    size: 12
                  },
                  callback: function(value) {
                    return formatCurrency(value);
                  }
                }
              }
            },
            plugins: {
              legend: {
                labels: {
                  usePointStyle: true,
                  pointStyle: 'circle',
                  color: textColor,
                  font: {
                    size: 12
                  }
                }
              },
              tooltip: {
                titleColor: textColor,
                bodyColor: textColor,
                callbacks: {
                  label: function(context) {
                    return context.dataset.label + ': ' + formatCurrency(context.parsed.y);
                  }
                }
              }
            },
            layout: {
              padding: 10
            }
          }
        });
      }

      // AJUSTE 18: Gráfico de área aprimorado - Limite do Cartão
      const areaCtx = document.getElementById('cardArea');
      if (areaCtx) {
        areaChart = new Chart(areaCtx.getContext('2d'), {
          type: 'line',
          data: {
            labels: [],
            datasets: [
              {
                label: 'Limite Utilizado',
                data: [],
                fill: true,
                backgroundColor: 'rgba(255, 59, 48, 0.2)',
                borderColor: appleColors[3], // vermelho
                borderWidth: 2,
                tension: 0.4,
                pointRadius: 0
              },
              {
                label: 'Limite Total',
                data: [],
                fill: false,
                borderColor: appleColors[0], // azul
                borderWidth: 2,
                borderDash: [5, 5],
                pointRadius: 0
              },
              {
                label: 'Limite Disponível',
                data: [],
                fill: false,
                borderColor: appleColors[1], // verde
                borderWidth: 2,
                pointRadius: 0
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
              mode: 'nearest',
              intersect: false,
              axis: 'x'
            },
            scales: {
              x: {
                grid: {
                  display: false,
                  color: gridColor
                },
                ticks: {
                  color: textColor,
                  font: {
                    size: 12
                  },
                  maxRotation: 0,
                  autoSkip: true,
                  maxTicksLimit: 10
                }
              },
              y: {
                beginAtZero: true,
                grid: {
                  color: gridColor
                },
                ticks: {
                  color: textColor,
                  font: {
                    size: 12
                  },
                  callback: function(value) {
                    return formatCurrency(value);
                  }
                }
              }
            },
            plugins: {
              legend: {
                labels: {
                  usePointStyle: true,
                  pointStyle: 'circle',
                  color: textColor,
                  font: {
                    size: 12
                  }
                }
              },
              tooltip: {
                titleColor: textColor,
                bodyColor: textColor,
                callbacks: {
                  label: function(context) {
                    return context.dataset.label + ': ' + formatCurrency(context.parsed.y);
                  }
                }
              }
            },
            layout: {
              padding: 10
            }
          }
        });
      }

      // AJUSTE 17: Gráfico aprimorado - Despesas Fixas vs Variáveis
      const fixedVsVariableCtx = document.getElementById('fixedVsVariableChart');
      if (fixedVsVariableCtx) {
        fixedVsVariableChart = new Chart(fixedVsVariableCtx.getContext('2d'), {
          type: 'pie',
          data: {
            labels: ['Despesas Fixas', 'Despesas Variáveis'],
            datasets: [{
              data: [0, 0],
              backgroundColor: [
                appleColors[0], // azul
                appleColors[2]  // laranja
              ],
              borderColor: isDarkTheme ? '#000000' : '#ffffff',
              borderWidth: 2,
              hoverOffset: 16,
              borderRadius: 5
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'bottom',
                labels: {
                  padding: 20,
                  usePointStyle: true,
                  pointStyle: 'circle',
                  color: textColor,
                  font: {
                    size: 12
                  }
                }
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const value = context.parsed;
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = Math.round((value / total) * 100);
                    return `${formatCurrency(value)} (${percentage}%)`;
                  }
                },
                titleColor: textColor,
                bodyColor: textColor
              }
            },
            layout: {
              padding: 15
            }
          }
        });
      }

      // AJUSTE 20: Gráfico aprimorado - Despesas por Pessoa
      const personAnalysisCtx = document.getElementById('personAnalysisChart');
      if (personAnalysisCtx) {
        personAnalysisChart = new Chart(personAnalysisCtx.getContext('2d'), {
          type: 'pie',
          data: {
            labels: [],
            datasets: [{
              data: [],
              backgroundColor: appleColors,
              borderColor: isDarkTheme ? '#000000' : '#ffffff',
              borderWidth: 2,
              hoverOffset: 16,
              borderRadius: 5
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'bottom',
                labels: {
                  padding: 20,
                  usePointStyle: true,
                  pointStyle: 'circle',
                  color: textColor,
                  font: {
                    size: 12
                  }
                }
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const value = context.parsed;
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = Math.round((value / total) * 100);
                    return `${formatCurrency(value)} (${percentage}%)`;
                  }
                },
                titleColor: textColor,
                bodyColor: textColor
              }
            },
            layout: {
              padding: 15
            }
          }
        });
      }
    } catch (error) {
      console.error('Erro ao criar gráficos:', error);
    }
  };

  // Atualizar os gráficos com dados recentes
  const updateCharts = () => {
    try {
      // Se os gráficos ainda não foram criados, criar agora
      if (!pieChart || !barChart || !areaChart || !fixedVsVariableChart || !personAnalysisChart) {
        createCharts();
      }

      if (!pieChart || !barChart || !areaChart) {
        console.error('Não foi possível inicializar os gráficos');
        return;
      }

      // Atualizar cores se o tema mudou
      updateChartColors();

      // 1. Atualizar gráfico de pizza - Despesas por categoria
      const categoryTotals = state.filteredTransactions
        .filter(t => t.type === 'expense')
        .reduce((acc, t) => {
          const categoryName = t.categoryName || t.category;
          if (!acc[categoryName]) {
            acc[categoryName] = 0;
          }
          acc[categoryName] += parseFloat(t.amount);
          return acc;
        }, {});

      // Converter para arrays para o gráfico
      const categories = Object.keys(categoryTotals);
      const categoryValues = categories.map(c => categoryTotals[c]);

      // Atualizar dados do gráfico de pizza
      pieChart.data.labels = categories;
      pieChart.data.datasets[0].data = categoryValues;
      pieChart.update();

      // 2. Atualizar gráfico de barras - Receitas x Despesas (12 meses)
      const months = [];
      const incomeData = [];
      const expenseData = [];

      // Obter os últimos 12 meses
      const today = new Date();
      for (let i = 11; i >= 0; i--) {
        const date = new Date(today.getFullYear(), today.getMonth() - i, 1);
        const monthName = date.toLocaleString('pt-BR', { month: 'short' });
        const year = date.getFullYear();
        const monthYear = `${monthName}/${year.toString().substr(2, 2)}`;
        
        months.push(monthYear);
        
        // Filtrar transações para este mês
        const monthTransactions = state.transactions.filter(t => {
          const tDate = parseLocalDateString(t.date);
          return tDate && tDate.getMonth() === date.getMonth() && tDate.getFullYear() === date.getFullYear();
        });
        
        // Calcular totais
        const monthlyIncome = monthTransactions
          .filter(t => t.type === 'income')
          .reduce((sum, t) => sum + parseFloat(t.amount), 0);
        
        const monthlyExpense = monthTransactions
          .filter(t => t.type === 'expense')
          .reduce((sum, t) => sum + parseFloat(t.amount), 0);
        
        incomeData.push(monthlyIncome);
        expenseData.push(monthlyExpense);
      }

      // Atualizar dados do gráfico de barras
      barChart.data.labels = months;
      barChart.data.datasets[0].data = incomeData;
      barChart.data.datasets[1].data = expenseData;
      barChart.update();

      // 3. Atualizar gráfico de área - Limite do Cartão
      // Se não houver cartões, mostrar mensagem
      if (state.cards.length === 0) {
        areaChart.data.labels = ['Nenhum cartão cadastrado'];
        areaChart.data.datasets[0].data = [0];
        areaChart.data.datasets[1].data = [0];
        areaChart.data.datasets[2].data = [0];
        areaChart.update();
        return;
      }

      // Calcular o total do limite disponível e utilizado de todos os cartões
      const combinedLimit = state.cards.reduce((sum, card) => sum + card.limit, 0);
      const combinedAvailable = state.cards.reduce((sum, card) => sum + card.availableLimit, 0);
      const combinedUsed = combinedLimit - combinedAvailable;

      // Obter os dias do mês atual
      const daysInMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0).getDate();
      const daysLabels = Array.from({ length: daysInMonth }, (_, i) => i + 1);

      // Criar dados para o gráfico
      const limitUsedLine = daysLabels.map(() => combinedUsed);
      const limitTotalLine = daysLabels.map(() => combinedLimit);
      const limitAvailableLine = daysLabels.map(() => combinedAvailable);

      // Atualizar dados do gráfico de área
      areaChart.data.labels = daysLabels;
      areaChart.data.datasets[0].data = limitUsedLine;
      areaChart.data.datasets[1].data = limitTotalLine;
      areaChart.data.datasets[2].data = limitAvailableLine;
      areaChart.update();

      // AJUSTE 17: Atualizar o gráfico de despesas fixas vs variáveis
      if (fixedVsVariableChart) {
        // Calcular despesas fixas e variáveis
        const fixedExpenses = state.filteredTransactions
          .filter(t => t.type === 'expense' && t.isFixed === 'fixed')
          .reduce((sum, t) => sum + parseFloat(t.amount), 0);
        
        const variableExpenses = state.filteredTransactions
          .filter(t => t.type === 'expense' && t.isFixed === 'variable')
          .reduce((sum, t) => sum + parseFloat(t.amount), 0);
        
        // Atualizar dados do gráfico
        fixedVsVariableChart.data.datasets[0].data = [fixedExpenses, variableExpenses];
        fixedVsVariableChart.update();
      }

      // AJUSTE 20: Atualizar o gráfico de despesas por pessoa
      if (personAnalysisChart) {
        // Calcular despesas por pessoa
        const expensesByPerson = {};
        
        // Inicializar com pessoas existentes
        state.people.forEach(person => {
          expensesByPerson[person.id] = 0;
        });
        
        // Adicionar categoria para transações sem pessoa associada
        expensesByPerson['sem_pessoa'] = 0;
        
        // Calcular total de gastos por pessoa
        state.filteredTransactions
          .filter(t => t.type === 'expense')
          .forEach(transaction => {
            const personId = transaction.person || 'sem_pessoa';
            expensesByPerson[personId] = (expensesByPerson[personId] || 0) + parseFloat(transaction.amount);
          });
        
        // Preparar dados para o gráfico
        const personLabels = [];
        const personValues = [];
        
        for (const [personId, total] of Object.entries(expensesByPerson)) {
          // Pular se não tiver gastos
          if (total === 0) continue;
          
          // Encontrar nome da pessoa
          let personName = 'Não categorizado';
          
          if (personId !== 'sem_pessoa') {
            const person = state.people.find(p => p.id === personId);
            if (person) {
              personName = person.name;
            }
          }
          
          personLabels.push(personName);
          personValues.push(total);
        }
        
        // Atualizar dados do gráfico
        personAnalysisChart.data.labels = personLabels;
        personAnalysisChart.data.datasets[0].data = personValues;
        personAnalysisChart.update();
      }
    } catch (error) {
      console.error('Erro ao atualizar gráficos:', error);
    }
  };

  // AJUSTE 14: Função para toggle de compromissos melhorada
  const toggleCommitments = () => {
    const content = $('#commitmentsContent');
    const header = $('#commitmentsHeader');

    if (!content || !header) return;

    if (header.classList.contains('active')) {
      // Fechar
      header.classList.remove('active');
      content.style.maxHeight = '0px';
    } else {
      // Abrir
      header.classList.add('active');
      content.style.maxHeight = content.scrollHeight + 'px';
    }
  };

  // Gerar insights para o usuário
  const generateInsights = () => {
    state.insights = [];

    const today = new Date();

    // Verificar transações vencidas e não pagas
    const overdueTransactions = state.transactions.filter(t => 
      t.type === 'expense' && 
      t.status !== 'paid' && 
      t.dueDate && parseLocalDateString(t.dueDate) < today
    );

    // Corrigir texto de contas vencidas e adicionar modal com detalhes
    if (overdueTransactions.length > 0) {
      // Texto gramaticalmente correto
      const message = overdueTransactions.length === 1 
        ? "Você tem 1 conta vencida." 
        : `Você tem ${overdueTransactions.length} contas vencidas.`;
        
      state.insights.push({
        id: 'overdue',
        level: 'danger',
        icon: 'icon-alert',
        message: message,
        actionText: 'Ver Detalhes',
        action: () => {
          // Abrir um modal com lista detalhada de contas vencidas
          openOverdueDetailsModal(overdueTransactions);
        }
      });
    }

    // Verificar transações a vencer nos próximos 5 dias
    const nextDueDate = new Date(today);
    nextDueDate.setDate(today.getDate() + 5);

    const upcomingTransactions = state.transactions.filter(t => 
      t.type === 'expense' && 
      t.status !== 'paid' && 
      t.dueDate && parseLocalDateString(t.dueDate) > today && 
      parseLocalDateString(t.dueDate) <= nextDueDate
    );

    if (upcomingTransactions.length > 0) {
      state.insights.push({
        id: 'upcoming',
        level: 'warning',
        icon: 'icon-calendar',
        message: `Você tem ${upcomingTransactions.length} contas a vencer nos próximos 5 dias.`,
        actionText: 'Ver Detalhes',
        action: () => {
          alert(`Você tem ${upcomingTransactions.length} contas a vencer nos próximos 5 dias. Verifique a tabela de transações.`);
        }
      });
    }

    // Verificar se há cartão com limite quase atingido
    const cardsWithLowLimit = state.cards.filter(card => 
      card.availableLimit < (card.limit * 0.2)
    );

    if (cardsWithLowLimit.length > 0) {
      state.insights.push({
        id: 'low-limit',
        level: 'warning',
        icon: 'icon-credit-card',
        message: `Você está com limite baixo no cartão ${cardsWithLowLimit[0].name}.`,
        actionText: 'Ver Cartão',
        action: () => {
          openCardInvoice(cardsWithLowLimit[0].id);
        }
      });
    }

    // Mostrar insights na UI
    renderInsights();
  };

  // Modal para detalhes de contas vencidas
  const openOverdueDetailsModal = (overdueTransactions) => {
    const tableBody = $('#overdueTransactionsTableBody');
    if (!tableBody) return;
    
    tableBody.innerHTML = '';
    
    if (overdueTransactions.length === 0) {
      tableBody.innerHTML = `
        <tr>
          <td colspan="6" style="text-align: center; padding: var(--spacing-xl);">
            Nenhuma conta vencida encontrada.
          </td>
        </tr>
      `;
    } else {
      // Ordenar por data de vencimento (mais antigas primeiro)
      const sortedTransactions = [...overdueTransactions].sort((a, b) => {
        const dateA = parseLocalDateString(a.dueDate);
        const dateB = parseLocalDateString(b.dueDate);
        return dateA - dateB;
      });
      
      sortedTransactions.forEach(transaction => {
        const row = document.createElement('tr');
        const vencimentoDate = parseLocalDateString(transaction.dueDate);
        const today = new Date();
        const diasAtraso = Math.floor((today - vencimentoDate) / (1000 * 60 * 60 * 24));
        
        row.innerHTML = `
          <td>
            <div class="transaction-icon" style="background-color: rgba(255, 59, 48, 0.1); color: var(--color-expense);">
              ${transaction.categoryIcon || '📦'}
            </div>
          </td>
          <td>${transaction.name}</td>
          <td>${transaction.categoryName || transaction.category}</td>
          <td>${formatDate(transaction.dueDate)} <small>(${diasAtraso} dias atraso)</small></td>
          <td>${formatCurrency(transaction.amount)}</td>
          <td>
            <button class="btn btn-success mark-paid-btn" data-id="${transaction.id}">
              Marcar Pago
            </button>
          </td>
        `;
        
        tableBody.appendChild(row);
      });
      
      // Adicionar event listeners para os botões de pagamento
      $$('.mark-paid-btn').forEach(btn => {
        btn.addEventListener('click', e => {
          const id = e.currentTarget.dataset.id;
          updateTransactionStatus(id, 'paid');
          e.currentTarget.closest('tr').remove();
          
          // Se não houver mais contas vencidas, fechar o modal
          if (tableBody.children.length === 0) {
            closeModal('overdueDetailsModal');
            generateInsights();
          }
        });
      });
    }
    
    // Configurar botão para pagar todas
    const payAllBtn = $('#payAllOverdueBtn');
    if (payAllBtn) {
      payAllBtn.addEventListener('click', async () => {
        try {
          // Marcar todas as transações como pagas
          const batch = db.batch();
          
          overdueTransactions.forEach(transaction => {
            const docRef = db.collection('transactions').doc(transaction.id);
            batch.update(docRef, { status: 'paid' });
            
            // Atualizar no estado local
            const index = state.transactions.findIndex(t => t.id === transaction.id);
            if (index !== -1) {
              state.transactions[index].status = 'paid';
            }
          });
          
          await batch.commit();
          
          // Atualizar UI
          updateTransactionsTable();
          updateKPIs();
          updateCharts();
          generateInsights();
          
          closeModal('overdueDetailsModal');
          showToast('Todas as contas foram marcadas como pagas!', 'success');
        } catch (error) {
          console.error('Erro ao pagar todas as contas:', error);
          showToast('Erro ao pagar contas. Tente novamente.', 'error');
        }
      });
    }
    
    // Abrir o modal
    openModal('overdueDetailsModal');
  };

  // Renderizar insights na UI
  const renderInsights = () => {
    const container = $('#insightsBanner');
    if (!container) return;

    container.innerHTML = '';

    if (state.insights.length === 0) {
      return;
    }

    state.insights.forEach(insight => {
      const insightElement = document.createElement('div');
      insightElement.className = `insight-banner insight-${insight.level}`;

      insightElement.innerHTML = `
        <div class="insight-icon">
          <svg width="24" height="24">
            <use href="#${insight.icon}"></use>
          </svg>
        </div>
        <div class="insight-content">
          <div class="insight-title">${insight.message}</div>
        </div>
        <button class="btn btn-outline insight-action" data-id="${insight.id}">
          ${insight.actionText}
        </button>
      `;

      container.appendChild(insightElement);
    });

    // Adicionar event listeners
    $$('.insight-action').forEach(btn => {
      btn.addEventListener('click', e => {
        const id = e.currentTarget.dataset.id;
        const insight = state.insights.find(i => i.id === id);
        
        if (insight && insight.action) {
          insight.action();
        }
      });
    });
  };

  // AJUSTE 14: Renderizar compromissos de longo prazo com barras de progresso
  const renderCommitments = () => {
    const content = $('#commitmentsContent');
    if (!content) return;

    content.innerHTML = '';

    // Filtrar transações recorrentes
    const recurrentTransactions = state.transactions.filter(t => 
      t.isRecurrent && 
      t.installments && 
      t.installmentNumber && 
      t.installments > t.installmentNumber
    );

    if (recurrentTransactions.length === 0) {
      content.innerHTML = '<p style="text-align: center; padding: var(--spacing-md);">Nenhum compromisso de longo prazo.</p>';
      return;
    }

    // Agrupar por ID de recorrência
    const groupedByRecurrence = recurrentTransactions.reduce((acc, t) => {
      const key = t.recurrenceId || t.id;

      if (!acc[key]) {
        acc[key] = {
          id: key,
          name: t.name,
          category: t.category,
          categoryName: t.categoryName,
          categoryIcon: t.categoryIcon,
          amount: parseFloat(t.amount),
          installments: t.installments,
          currentInstallment: Math.min(...recurrentTransactions
            .filter(rt => (rt.recurrenceId || rt.id) === key)
            .map(rt => rt.installmentNumber)),
          type: t.type
        };
      }

      return acc;
    }, {});

    // Converter para array e ordenar por progresso
    const commitments = Object.values(groupedByRecurrence)
      .sort((a, b) => (a.currentInstallment / a.installments) - (b.currentInstallment / b.installments));

    // Renderizar cada compromisso
    commitments.forEach(commitment => {
      const progress = (commitment.currentInstallment / commitment.installments) * 100;
      const color = commitment.type === 'income' ? 'var(--color-income)' : 'var(--color-expense)';

      const commitmentElement = document.createElement('div');
      commitmentElement.className = 'commitment-item';

      commitmentElement.innerHTML = `
        <div class="transaction-icon" style="background-color: ${commitment.type === 'income' ? 'rgba(52, 199, 89, 0.1)' : 'rgba(255, 59, 48, 0.1)'}; color: ${color};">
          ${commitment.categoryIcon || (commitment.type === 'income' ? '💰' : '📦')}
        </div>
        <div style="flex: 1;">
          <div style="display: flex; justify-content: space-between;">
            <div>${commitment.name}</div>
            <div>${formatCurrency(commitment.amount)}</div>
          </div>
          <div style="display: flex; justify-content: space-between; font-size: var(--font-size-xs); color: var(--color-on-surface-variant);">
            <div>${commitment.categoryName || commitment.category}</div>
            <div>${commitment.currentInstallment}/${commitment.installments}</div>
          </div>
          <div class="commitment-progress" style="margin-top: var(--spacing-xs);">
            <div class="commitment-progress-bar" style="width: ${progress}%; background-color: ${color};"></div>
          </div>
        </div>
      `;

      content.appendChild(commitmentElement);
    });
  };

  // Função para criar filtros de transações personalizados
  const createTransactionFilters = () => {
    const filtersContainer = $('#transaction-filters');
    if (!filtersContainer) return;

    // Limpar filtros existentes
    filtersContainer.innerHTML = '';

    // Filtro de categoria
    const categorySelect = document.createElement('div');
    categorySelect.className = 'select-wrapper';
    categorySelect.innerHTML = `
      <select id="filter-category" class="select">
        <option value="">Todas as categorias</option>
        <optgroup label="Receitas">
          ${state.categories.income.map(cat => `<option value="${cat.id}">${cat.icon || ''} ${cat.name}</option>`).join('')}
        </optgroup>
        <optgroup label="Despesas">
          ${state.categories.expense.map(cat => `<option value="${cat.id}">${cat.icon || ''} ${cat.name}</option>`).join('')}
        </optgroup>
      </select>
      <svg class="select-icon" width="16" height="16">
        <use href="#icon-chevron-down"></use>
      </svg>
    `;

    // Filtro de status
    const statusSelect = document.createElement('div');
    statusSelect.className = 'select-wrapper';
    statusSelect.innerHTML = `
      <select id="filter-status" class="select">
        <option value="">Todos os status</option>
        <option value="paid">Pagos</option>
        <option value="pending">Pendentes</option>
        <option value="scheduled">Agendados</option>
        <option value="received">Recebidos</option>
      </select>
      <svg class="select-icon" width="16" height="16">
        <use href="#icon-chevron-down"></use>
      </svg>
    `;

    // Filtro de forma de pagamento
    const paymentMethodSelect = document.createElement('div');
    paymentMethodSelect.className = 'select-wrapper';
    paymentMethodSelect.innerHTML = `
      <select id="filter-payment-method" class="select">
        <option value="">Todas as formas de pagamento</option>
        ${state.paymentMethods.map(method => `<option value="${method.id}">${method.icon || ''} ${method.name}</option>`).join('')}
      </select>
      <svg class="select-icon" width="16" height="16">
        <use href="#icon-chevron-down"></use>
      </svg>
    `;

    // AJUSTE 7: Filtro de pessoa
    const personSelect = document.createElement('div');
    personSelect.className = 'select-wrapper';
    personSelect.innerHTML = `
      <select id="filter-person" class="select">
        <option value="">Todas as pessoas</option>
        ${state.people.map(person => `<option value="${person.id}">${person.icon || ''} ${person.name}</option>`).join('')}
      </select>
      <svg class="select-icon" width="16" height="16">
        <use href="#icon-chevron-down"></use>
      </svg>
    `;

    // Adicionar filtros ao container
    filtersContainer.appendChild(categorySelect);
    filtersContainer.appendChild(statusSelect);
    filtersContainer.appendChild(paymentMethodSelect);
    filtersContainer.appendChild(personSelect);

    // Atualizar ao mudar os filtros
    $('#filter-category').addEventListener('change', e => {
      state.filters.category = e.target.value;
      updateTransactionsTable();
    });

    $('#filter-status').addEventListener('change', e => {
      state.filters.status = e.target.value;
      updateTransactionsTable();
    });

    $('#filter-payment-method').addEventListener('change', e => {
      state.filters.paymentMethod = e.target.value;
      updateTransactionsTable();
    });

    $('#filter-person').addEventListener('change', e => {
      state.filters.person = e.target.value;
      updateTransactionsTable();
    });
  };

  // AJUSTE 11: Adicionar ordenação aos cabeçalhos da tabela sem setas
  const setupSortableColumns = () => {
    const headers = $$('.sortable');
    
    headers.forEach(header => {
      header.addEventListener('click', () => {
        const column = header.dataset.sort;
        
        // Se já está selecionada, inverter a direção
        if (column === state.sortColumn) {
          state.sortDirection = state.sortDirection === 'asc' ? 'desc' : 'asc';
        } else {
          state.sortColumn = column;
          state.sortDirection = 'asc';
        }
        
        // Destacar visual da coluna ordenada
        $$('.sortable').forEach(h => {
          h.classList.remove('sorted-asc', 'sorted-desc');
        });
        
        header.classList.add(`sorted-${state.sortDirection}`);
        
        // Atualizar a tabela
        updateTransactionsTable();
      });
    });
  };

  // AJUSTE 11, 15: Atualizar a tabela de transações com coluna de pessoas
  const updateTransactionsTable = () => {
    const tableBody = $('#transactionsTableBody');
    if (!tableBody) return;

    // Criar filtros se ainda não existirem
    if (!$('#filter-category')) {
      createTransactionFilters();
    }

    // Configurar colunas ordenáveis se ainda não estiverem
    if (!$('.sortable')?.classList.contains('has-listener')) {
      setupSortableColumns();
      // Adicionar classe para evitar reinicialização
      $$('.sortable').forEach(header => header.classList.add('has-listener'));
    }

    tableBody.innerHTML = '';

    // Aplicar filtros
    let transactions = [...state.filteredTransactions];

    if (state.filters.category) {
      transactions = transactions.filter(t => t.category === state.filters.category);
    }

    if (state.filters.status) {
      transactions = transactions.filter(t => t.status === state.filters.status);
    }

    if (state.filters.paymentMethod) {
      transactions = transactions.filter(t => t.paymentMethod === state.filters.paymentMethod);
    }

    // AJUSTE 7: Filtrar por pessoa
    if (state.filters.person) {
      transactions = transactions.filter(t => t.person === state.filters.person);
    }

    // Ordenar transações
    transactions.sort((a, b) => {
      let valueA, valueB;

      // Determinar os valores a comparar com base na coluna
      switch(state.sortColumn) {
        case 'name':
          valueA = a.name.toLowerCase();
          valueB = b.name.toLowerCase();
          break;
        case 'category':
          valueA = (a.categoryName || a.category || '').toLowerCase();
          valueB = (b.categoryName || b.category || '').toLowerCase();
          break;
        case 'person':
          valueA = a.person || '';
          valueB = b.person || '';
          break;
        case 'date':
          valueA = parseLocalDateString(a.date);
          valueB = parseLocalDateString(b.date);
          break;
        case 'dueDate':
          // Se não houver data de vencimento, usar uma data muito antiga ou muito recente
          valueA = a.dueDate ? parseLocalDateString(a.dueDate) : new Date(0);
          valueB = b.dueDate ? parseLocalDateString(b.dueDate) : new Date(0);
          break;
        case 'amount':
          valueA = parseFloat(a.amount);
          valueB = parseFloat(b.amount);
          break;
        case 'status':
          valueA = a.status;
          valueB = b.status;
          break;
        case 'paymentMethod':
          valueA = (a.paymentMethodName || a.paymentMethod || '').toLowerCase();
          valueB = (b.paymentMethodName || b.paymentMethod || '').toLowerCase();
          break;
        case 'isFixed':
          valueA = a.isFixed || '';
          valueB = b.isFixed || '';
          break;
        default:
          valueA = parseLocalDateString(a.date);
          valueB = parseLocalDateString(b.date);
      }

      // Comparar os valores
      let comparison = 0;
      if (valueA < valueB) {
        comparison = -1;
      } else if (valueA > valueB) {
        comparison = 1;
      }

      // Inverter se a direção for descendente
      return state.sortDirection === 'desc' ? -comparison : comparison;
    });

    if (transactions.length === 0) {
      const emptyRow = document.createElement('tr');
      emptyRow.innerHTML = `
        <td colspan="12" style="text-align: center; padding: var(--spacing-xl);">
          Nenhuma transação para este período ou filtro.
        </td>
      `;
      tableBody.appendChild(emptyRow);
      return;
    }

    transactions.forEach(transaction => {
      const row = document.createElement('tr');

      // Determinar cor do ícone
      const iconBgColor = transaction.type === 'income' 
        ? 'rgba(52, 199, 89, 0.1)'
        : 'rgba(255, 59, 48, 0.1)';

      const iconColor = transaction.type === 'income'
        ? 'var(--color-income)'
        : 'var(--color-expense)';

      // Obter nome da categoria
      const categoryName = transaction.categoryName || transaction.category || '-';

      // Formatar status
      let statusText = '';
      let statusClass = '';

      if (transaction.type === 'income') {
        if (transaction.status === 'received') {
          statusText = 'Recebido';
          statusClass = 'badge-success';
        } else {
          statusText = 'A Receber';
          statusClass = 'badge-warning';
        }
      } else {
        if (transaction.status === 'paid') {
          statusText = 'Pago';
          statusClass = 'badge-success';
        } else if (transaction.status === 'scheduled') {
          statusText = 'Agendado';
          statusClass = 'badge-info';
        } else {
          statusText = 'Pendente';
          statusClass = 'badge-warning';
        }
      }

      // Instalamentos, se aplicável
      let installmentText = '';
      if (transaction.isRecurrent && transaction.installments > 1) {
        installmentText = ` (${transaction.installmentNumber || 1}/${transaction.installments})`;
      }

      // AJUSTE 15: Pessoa associada, se houver
      const personInfo = transaction.person ? 
        state.people.find(p => p.id === transaction.person) : null;

      // AJUSTE 16: Tipo de despesa (fixa/variável)
      let typeText = '';
      if (transaction.type === 'expense') {
        typeText = transaction.isFixed === 'fixed' ? 'Fixa' : 'Variável';
      }

      row.innerHTML = `
        <td>
          <div class="transaction-icon" style="background-color: ${iconBgColor}; color: ${iconColor};">
            ${transaction.categoryIcon || (transaction.type === 'income' ? '💰' : '📦')}
          </div>
        </td>
        <td>${transaction.name}${installmentText}</td>
        <td>${categoryName}</td>
        <!-- AJUSTE 15: Coluna de Pessoa -->
        <td>${personInfo ? `${personInfo.icon || ''} ${personInfo.name}` : '-'}</td>
        <td>${formatDate(transaction.date)}</td>
        <td>${transaction.dueDate ? formatDate(transaction.dueDate) : '-'}</td>
        <td>${formatCurrency(transaction.amount)}</td>
        <td><span class="badge ${statusClass}">${statusText}</span></td>
        <td>${transaction.paymentMethodName || transaction.paymentMethod || '-'}</td>
        <!-- AJUSTE 16: Coluna de Tipo (Fixa/Variável) -->
        <td>${typeText}</td>
        <td>
          <div class="checkbox-wrapper">
            <input type="checkbox" class="checkbox transaction-paid-checkbox" id="paid-${transaction.id}" 
                  ${transaction.status === (transaction.type === 'income' ? 'received' : 'paid') ? 'checked' : ''}
                  data-id="${transaction.id}"
                  data-type="${transaction.type}">
            <label class="checkbox-label" for="paid-${transaction.id}"></label>
          </div>
        </td>
        <td class="actions-cell">
          <button class="btn btn-icon btn-outline edit-transaction-btn" data-id="${transaction.id}">
            <svg width="16" height="16">
              <use href="#icon-edit"></use>
            </svg>
          </button>
          <button class="btn btn-icon btn-outline delete-transaction-btn" data-id="${transaction.id}">
            <svg width="16" height="16">
              <use href="#icon-trash"></use>
            </svg>
          </button>
        </td>
      `;

      tableBody.appendChild(row);
    });

    // Adicionar event listeners
    $$('.transaction-paid-checkbox').forEach(checkbox => {
      checkbox.addEventListener('change', e => {
        const id = e.target.dataset.id;
        const type = e.target.dataset.type;
        const isChecked = e.target.checked;
        
        const status = isChecked 
          ? (type === 'income' ? 'received' : 'paid')
          : (type === 'income' ? 'pending' : 'pending');
        
        updateTransactionStatus(id, status);
      });
    });

    $$('.edit-transaction-btn').forEach(btn => {
      btn.addEventListener('click', e => {
        const id = e.currentTarget.dataset.id;
        const transaction = state.transactions.find(t => t.id === id);
        
        if (transaction) {
          openEditModal(transaction);
        }
      });
    });

    $$('.delete-transaction-btn').forEach(btn => {
      btn.addEventListener('click', e => {
        const id = e.currentTarget.dataset.id;
        const transaction = state.transactions.find(t => t.id === id);
        
        if (transaction) {
          openDeleteConfirmModal(transaction);
        }
      });
    });
  };

  // Função para atualizar o status de uma transação
  const updateTransactionStatus = async (id, status) => {
    try {
      // Buscar a transação
      const transaction = state.transactions.find(t => t.id === id);
      if (!transaction) return;
      
      // Atualizar no Firestore
      await db.collection('transactions').doc(id).update({ status });
      
      // Atualizar no estado local
      transaction.status = status;
      
      // Atualizar UI
      updateKPIs();
      updateCharts();
      generateInsights();
      
      showToast(`Transação ${status === 'paid' || status === 'received' ? 'paga' : 'atualizada'} com sucesso!`, 'success');
      
    } catch (error) {
      console.error('Erro ao atualizar status da transação:', error);
      showToast('Erro ao atualizar transação. Tente novamente.', 'error');
    }
  };

  // Função para adicionar transação
  const addTransaction = async (transaction) => {
    try {
      // Adicionar campos auxiliares
      transaction.createdAt = new Date().toISOString();
      
      // Obter nome da categoria
      if (transaction.type === 'income') {
        const category = state.categories.income.find(c => c.id === transaction.category);
        if (category) {
          transaction.categoryName = category.name;
          transaction.categoryIcon = category.icon;
        }
      } else {
        const category = state.categories.expense.find(c => c.id === transaction.category);
        if (category) {
          transaction.categoryName = category.name;
          transaction.categoryIcon = category.icon;
        }
      }
      
      // Obter nome do método de pagamento
      const paymentMethod = state.paymentMethods.find(m => m.id === transaction.paymentMethod);
      if (paymentMethod) {
        transaction.paymentMethodName = paymentMethod.name;
        transaction.paymentMethodIcon = paymentMethod.icon;
      }
      
      // Se for cartão de crédito, adicionar informações do cartão
      if (transaction.paymentMethod === 'credito' && transaction.creditCardId) {
        const card = state.cards.find(c => c.id === transaction.creditCardId);
        if (card) {
          transaction.creditCardName = card.name;
          
          // Atualizar limite disponível do cartão
          const newAvailableLimit = card.availableLimit - parseFloat(transaction.amount);
          const newCurrentInvoice = (card.currentInvoice || 0) + parseFloat(transaction.amount);
          
          // Atualizar no Firestore
          await db.collection('cards').doc(card.id).update({
            availableLimit: newAvailableLimit,
            currentInvoice: newCurrentInvoice
          });
          
          // Atualizar no estado local
          card.availableLimit = newAvailableLimit;
          card.currentInvoice = newCurrentInvoice;
        }
      }
      
      // Adicionar nome da pessoa, se aplicável
      if (transaction.person) {
        const person = state.people.find(p => p.id === transaction.person);
        if (person) {
          transaction.personName = person.name;
          transaction.personIcon = person.icon;
        }
      }

      // Converter datas para string de data local
      if (transaction.date instanceof Date) {
        transaction.date = localDateToISOString(transaction.date);
      }
      
      if (transaction.dueDate instanceof Date) {
        transaction.dueDate = localDateToISOString(transaction.dueDate);
      }
      
      if (transaction.scheduledDate instanceof Date) {
        transaction.scheduledDate = localDateToISOString(transaction.scheduledDate);
      }
      
      // Adicionar ao Firestore
      const docRef = await db.collection('transactions').add(transaction);
      
      // Atualizar o ID
      transaction.id = docRef.id;
      
      // Adicionar ao estado local
      state.transactions.push(transaction);
      
      // Atualizar UI
      filterTransactionsByMonth();
      showToast(`${transaction.type === 'income' ? 'Receita' : 'Despesa'} adicionada com sucesso!`, 'success');
      
      return transaction;
    } catch (error) {
      console.error('Erro ao adicionar transação:', error);
      showToast('Erro ao adicionar transação. Tente novamente.', 'error');
      return null;
    }
  };

  // Função para adicionar transações recorrentes (parcelamento)
  const addRecurrentTransactions = async (transaction, installments) => {
    try {
      const recurrenceId = generateId();
      const batch = db.batch();
      const transactionsToAdd = [];
      
      // Data base para calcular as datas futuras
      const baseDate = new Date(transaction.date);
      
      // Adicionar cada parcela
      for (let i = 1; i <= installments; i++) {
        // Calcular nova data (um mês depois para cada parcela)
        const installmentDate = new Date(baseDate);
        installmentDate.setMonth(installmentDate.getMonth() + (i - 1));
        
        // Calcular nova data de vencimento, se existir
        let installmentDueDate = null;
        if (transaction.dueDate) {
          const baseDueDate = parseLocalDateString(transaction.dueDate);
          installmentDueDate = new Date(baseDueDate);
          installmentDueDate.setMonth(installmentDueDate.getMonth() + (i - 1));
        }
        
        // Criar objeto da transação
        const installmentTransaction = {
          ...transaction,
          date: localDateToISOString(installmentDate),
          dueDate: installmentDueDate ? localDateToISOString(installmentDueDate) : null,
          recurrenceId: recurrenceId,
          installmentNumber: i,
          isRecurrent: true,
          installments: installments
        };
        delete installmentTransaction.id; // Remover ID para que um novo seja gerado
        
        // Adicionar ao Firestore
        const docRef = db.collection('transactions').doc();
        batch.set(docRef, installmentTransaction);
        
        // Preparar para adicionar ao estado local
        installmentTransaction.id = docRef.id;
        transactionsToAdd.push(installmentTransaction);
      }
      
      // Commits do lote
      await batch.commit();
      
      // Adicionar todas as transações ao estado local
      state.transactions = [...state.transactions, ...transactionsToAdd];
      
      // Atualizar UI
      filterTransactionsByMonth();
      showToast(`${transaction.type === 'income' ? 'Receita' : 'Despesa'} parcelada adicionada com sucesso!`, 'success');
      
      return transactionsToAdd;
    } catch (error) {
      console.error('Erro ao adicionar transações recorrentes:', error);
      showToast('Erro ao adicionar parcelas. Tente novamente.', 'error');
      return null;
    }
  };

  // Função para atualizar transação
  const updateTransaction = async (id, updates) => {
    try {
      // Buscar a transação no estado local
      const transaction = state.transactions.find(t => t.id === id);
      if (!transaction) return;
      
      // Atualizações de categoria
      if (updates.category) {
        if (transaction.type === 'income') {
          const category = state.categories.income.find(c => c.id === updates.category);
          if (category) {
            updates.categoryName = category.name;
            updates.categoryIcon = category.icon;
          }
        } else {
          const category = state.categories.expense.find(c => c.id === updates.category);
          if (category) {
            updates.categoryName = category.name;
            updates.categoryIcon = category.icon;
          }
        }
      }
      
      // Atualizações de método de pagamento
      if (updates.paymentMethod) {
        const paymentMethod = state.paymentMethods.find(m => m.id === updates.paymentMethod);
        if (paymentMethod) {
          updates.paymentMethodName = paymentMethod.name;
          updates.paymentMethodIcon = paymentMethod.icon;
        }
        
        // Se mudou de cartão de crédito para outro método, atualizar limite do cartão antigo
        if (transaction.paymentMethod === 'credito' && updates.paymentMethod !== 'credito' && transaction.creditCardId) {
          const oldCard = state.cards.find(c => c.id === transaction.creditCardId);
          if (oldCard) {
            const newAvailableLimit = oldCard.availableLimit + parseFloat(transaction.amount);
            const newCurrentInvoice = (oldCard.currentInvoice || 0) - parseFloat(transaction.amount);
            
            await db.collection('cards').doc(oldCard.id).update({
              availableLimit: newAvailableLimit,
              currentInvoice: Math.max(0, newCurrentInvoice)
            });
            
            oldCard.availableLimit = newAvailableLimit;
            oldCard.currentInvoice = Math.max(0, newCurrentInvoice);
          }
        }
        
        // Se mudou para cartão de crédito, atualizar limite do novo cartão
        if (updates.paymentMethod === 'credito' && updates.creditCardId) {
          const newCard = state.cards.find(c => c.id === updates.creditCardId);
          if (newCard) {
            const amount = updates.amount || transaction.amount;
            const newAvailableLimit = newCard.availableLimit - parseFloat(amount);
            const newCurrentInvoice = (newCard.currentInvoice || 0) + parseFloat(amount);
            
            await db.collection('cards').doc(newCard.id).update({
              availableLimit: newAvailableLimit,
              currentInvoice: newCurrentInvoice
            });
            
            newCard.availableLimit = newAvailableLimit;
            newCard.currentInvoice = newCurrentInvoice;
            
            updates.creditCardName = newCard.name;
          }
        }
      }
      
      // Atualização de valor com cartão de crédito
      if (updates.amount && transaction.paymentMethod === 'credito' && transaction.creditCardId) {
        const card = state.cards.find(c => c.id === transaction.creditCardId);
        if (card) {
          const amountDiff = parseFloat(updates.amount) - parseFloat(transaction.amount);
          const newAvailableLimit = card.availableLimit - amountDiff;
          const newCurrentInvoice = (card.currentInvoice || 0) + amountDiff;
          
          await db.collection('cards').doc(card.id).update({
            availableLimit: newAvailableLimit,
            currentInvoice: newCurrentInvoice
          });
          
          card.availableLimit = newAvailableLimit;
          card.currentInvoice = newCurrentInvoice;
        }
      }
      
      // Atualizações de pessoa
      if (updates.person) {
        const person = state.people.find(p => p.id === updates.person);
        if (person) {
          updates.personName = person.name;
          updates.personIcon = person.icon;
        }
      }
      
      // Converter datas para string de data local
      if (updates.date instanceof Date) {
        updates.date = localDateToISOString(updates.date);
      }
      
      if (updates.dueDate instanceof Date) {
        updates.dueDate = localDateToISOString(updates.dueDate);
      }
      
      if (updates.scheduledDate instanceof Date) {
        updates.scheduledDate = localDateToISOString(updates.scheduledDate);
      }
      
      // Atualizar no Firestore
      await db.collection('transactions').doc(id).update(updates);
      
      // Atualizar no estado local
      Object.assign(transaction, updates);
      
      // Atualizar UI
      filterTransactionsByMonth();
      
      showToast('Transação atualizada com sucesso!', 'success');
      
      return transaction;
    } catch (error) {
      console.error('Erro ao atualizar transação:', error);
      showToast('Erro ao atualizar transação. Tente novamente.', 'error');
      return null;
    }
  };

  // Função para excluir transação
  const deleteTransaction = async (id, options = {}) => {
    try {
      // Buscar a transação
      const transaction = state.transactions.find(t => t.id === id);
      if (!transaction) return;
      
      // Verificar se é parte de uma recorrência
      const isRecurrent = transaction.isRecurrent && transaction.recurrenceId;
      
      if (isRecurrent && options.deleteOption === 'future') {
        // Excluir todas as parcelas futuras (a partir desta)
        const futureParcels = state.transactions.filter(t => 
          t.recurrenceId === transaction.recurrenceId && 
          t.installmentNumber >= transaction.installmentNumber
        );
        
        const batch = db.batch();
        
        // Se for cartão de crédito, atualizar limite
        const updateCreditCardPromises = [];
        for (const parcel of futureParcels) {
          if (parcel.paymentMethod === 'credito' && parcel.creditCardId) {
            const card = state.cards.find(c => c.id === parcel.creditCardId);
            if (card) {
              const newAvailableLimit = card.availableLimit + parseFloat(parcel.amount);
              const newCurrentInvoice = (card.currentInvoice || 0) - parseFloat(parcel.amount);
              
              updateCreditCardPromises.push(
                db.collection('cards').doc(card.id).update({
                  availableLimit: newAvailableLimit,
                  currentInvoice: Math.max(0, newCurrentInvoice)
                })
              );
              
              card.availableLimit = newAvailableLimit;
              card.currentInvoice = Math.max(0, newCurrentInvoice);
            }
          }
          
          batch.delete(db.collection('transactions').doc(parcel.id));
        }
        
        // Esperar atualizações dos cartões
        if (updateCreditCardPromises.length > 0) {
          await Promise.all(updateCreditCardPromises);
        }
        
        // Executar batch
        await batch.commit();
        
        // Atualizar estado local
        state.transactions = state.transactions.filter(t => 
          !(t.recurrenceId === transaction.recurrenceId && t.installmentNumber >= transaction.installmentNumber)
        );
        
      } else {
        // Excluir apenas uma transação
        
        // Se for cartão de crédito, atualizar limite
        if (transaction.paymentMethod === 'credito' && transaction.creditCardId) {
          const card = state.cards.find(c => c.id === transaction.creditCardId);
          if (card) {
            const newAvailableLimit = card.availableLimit + parseFloat(transaction.amount);
            const newCurrentInvoice = (card.currentInvoice || 0) - parseFloat(transaction.amount);
            
            await db.collection('cards').doc(card.id).update({
              availableLimit: newAvailableLimit,
              currentInvoice: Math.max(0, newCurrentInvoice)
            });
            
            card.availableLimit = newAvailableLimit;
            card.currentInvoice = Math.max(0, newCurrentInvoice);
          }
        }
        
        // Excluir no Firestore
        await db.collection('transactions').doc(id).delete();
        
        // Remover do estado local
        state.transactions = state.transactions.filter(t => t.id !== id);
      }
      
      // Atualizar UI
      filterTransactionsByMonth();
      updateKPIs();
      updateCharts();
      
      showToast('Transação excluída com sucesso!', 'success');
      
      return true;
    } catch (error) {
      console.error('Erro ao excluir transação:', error);
      showToast('Erro ao excluir transação. Tente novamente.', 'error');
      return false;
    }
  };

  // Função para abrir o modal de edição
  const openEditModal = (transaction) => {
    state.currentTransaction = transaction;
    
    // Preencher o formulário de edição
    $('#editTransactionId').value = transaction.id;
    $('#editTransactionType').value = transaction.type;
    $('#editName').value = transaction.name;
    $('#editAmount').value = transaction.amount;
    
    // Definir o tipo da transação para o select de categoria
    $('#editCategory').dataset.type = transaction.type;
    
    // Preencher select de categoria
    updateCategorySelects();
    $('#editCategory').value = transaction.category;
    
    // Configurar campo de pessoa
    if ($('#editPerson')) {
      $('#editPerson').value = transaction.person || '';
    }
    
    // Configurar campos de tipo de despesa (fixa/variável)
    if (transaction.type === 'expense') {
      $('#editExpenseTypeGroup').style.display = 'block';
      if (transaction.isFixed === 'fixed') {
        $('#editExpenseTypeFixed').checked = true;
      } else {
        $('#editExpenseTypeVariable').checked = true;
      }
    } else {
      $('#editExpenseTypeGroup').style.display = 'none';
    }
    
    // Datas
    if (transaction.date) {
      setDateInputValue('editDate', transaction.date);
    }
    
    if (transaction.dueDate) {
      $('#editDueDateGroup').style.display = 'block';
      setDateInputValue('editDueDate', transaction.dueDate);
    } else {
      $('#editDueDateGroup').style.display = 'none';
    }
    
    // Forma de pagamento
    $('#editPaymentMethod').value = transaction.paymentMethod;
    
    // Se for cartão de crédito, mostrar select de cartões
    if (transaction.paymentMethod === 'credito') {
      $('#editCreditCardGroup').style.display = 'block';
      $('#editCreditCard').value = transaction.creditCardId || '';
    } else {
      $('#editCreditCardGroup').style.display = 'none';
    }
    
    // Recorrência
    $('#editIsRecurrent').checked = transaction.isRecurrent;
    if (transaction.isRecurrent) {
      $('#editRecurrenceGroup').style.display = 'block';
      $('#editInstallments').value = transaction.installments || 2;
    } else {
      $('#editRecurrenceGroup').style.display = 'none';
    }
    
    // Status
    const statusGroup = $('#editStatusGroup');
    statusGroup.innerHTML = '';
    
    if (transaction.type === 'income') {
      // Status para receitas: recebida ou pendente
      statusGroup.innerHTML = `
        <div class="radio-wrapper">
          <input type="radio" class="radio" id="editStatusReceived" name="editStatus" value="received"
                ${transaction.status === 'received' ? 'checked' : ''}>
          <label class="radio-label" for="editStatusReceived">
            <span class="radio-circle"></span>
            Recebido
          </label>
        </div>
        
        <div class="radio-wrapper">
          <input type="radio" class="radio" id="editStatusPending" name="editStatus" value="pending"
                ${transaction.status === 'pending' ? 'checked' : ''}>
          <label class="radio-label" for="editStatusPending">
            <span class="radio-circle"></span>
            A Receber
          </label>
        </div>
      `;
    } else {
      // Status para despesas: paga, pendente ou agendada
      statusGroup.innerHTML = `
        <div class="radio-wrapper">
          <input type="radio" class="radio" id="editStatusPaid" name="editStatus" value="paid"
                ${transaction.status === 'paid' ? 'checked' : ''}>
          <label class="radio-label" for="editStatusPaid">
            <span class="radio-circle"></span>
            Pago
          </label>
        </div>
        
        <div class="radio-wrapper">
          <input type="radio" class="radio" id="editStatusPending" name="editStatus" value="pending"
                ${transaction.status === 'pending' ? 'checked' : ''}>
          <label class="radio-label" for="editStatusPending">
            <span class="radio-circle"></span>
            Pendente
          </label>
        </div>
        
        <div class="radio-wrapper">
          <input type="radio" class="radio" id="editStatusScheduled" name="editStatus" value="scheduled"
                ${transaction.status === 'scheduled' ? 'checked' : ''}>
          <label class="radio-label" for="editStatusScheduled">
            <span class="radio-circle"></span>
            Agendado
          </label>
        </div>
      `;
    }
    
    // Configurar campo de data de agendamento
    if (transaction.status === 'scheduled') {
      $('#editScheduledDateGroup').style.display = 'block';
      if (transaction.scheduledDate) {
        setDateInputValue('editScheduledDate', transaction.scheduledDate);
      }
    } else {
      $('#editScheduledDateGroup').style.display = 'none';
    }
    
    // Preencher campo de observações
    $('#editNotes').value = transaction.notes || '';
    
    // Event listeners para campos que dependem de outros
    $('#editPaymentMethod').addEventListener('change', e => {
      if (e.target.value === 'credito') {
        $('#editCreditCardGroup').style.display = 'block';
      } else {
        $('#editCreditCardGroup').style.display = 'none';
      }
    });
    
    $('#editIsRecurrent').addEventListener('change', e => {
      if (e.target.checked) {
        $('#editRecurrenceGroup').style.display = 'block';
      } else {
        $('#editRecurrenceGroup').style.display = 'none';
      }
    });
    
    // Adicionar listener para o status de agendamento
    $$('input[name="editStatus"]').forEach(radio => {
      radio.addEventListener('change', e => {
        if (e.target.value === 'scheduled') {
          $('#editScheduledDateGroup').style.display = 'block';
          
          // Se não houver data de agendamento, definir para hoje
          if (!$('#editScheduledDate').value) {
            setDateInputValue('editScheduledDate', new Date());
          }
        } else {
          $('#editScheduledDateGroup').style.display = 'none';
        }
      });
    });
    
    // Configurar o título e botão
    $('#editModalTitle').textContent = transaction.type === 'income' ? 'Editar Receita' : 'Editar Despesa';
    $('#saveEditBtn').textContent = 'Salvar Alterações';
    
    // Abrir o modal
    openModal('editModal');
  };

  // Função para abrir o modal de confirmação de exclusão
  const openDeleteConfirmModal = (transaction) => {
    state.currentTransaction = transaction;
    
    // Verificar se é uma transação recorrente com parcelas futuras
    const isRecurrent = transaction.isRecurrent && transaction.recurrenceId;
    const hasFutureParcels = isRecurrent && state.transactions.some(t => 
      t.recurrenceId === transaction.recurrenceId && 
      t.installmentNumber > transaction.installmentNumber
    );
    
    // Mostrar ou esconder opções de exclusão de recorrência
    $('#recurrenceDeleteOptions').style.display = hasFutureParcels ? 'block' : 'none';
    
    // Garantir que a opção padrão esteja selecionada
    $('#deleteSingle').checked = true;
    
    // Abrir o modal
    openModal('deleteConfirmModal');
  };

  // Função para abrir o modal de edição de cartão
  const openEditCardModal = (card) => {
    state.currentCard = card;
    
    // Preencher o formulário
    $('#cardName').value = card.name;
    $('#cardLimit').value = card.limit;
    $('#cardClosingDay').value = card.closingDay;
    $('#cardDueDay').value = card.dueDay;
    
    // Alterar título do modal e texto do botão
    $('.modal-title', $('#newCardModal')).textContent = 'Editar Cartão';
    $('#saveCardBtn').textContent = 'Salvar Alterações';
    
    // Adicionar ID do cartão ao botão de salvar
    $('#saveCardBtn').dataset.id = card.id;
    
    // Abrir o modal
    closeModal('cardsListModal');
    openModal('newCardModal');
  };

  // Funções para manipular categorias
  // Função para renderizar lista de categorias de receita
  const renderCategoriesList = () => {
    // Renderizar categorias de receita
    const incomeList = $('#incomeCategoriesList');
    if (incomeList) {
      incomeList.innerHTML = '';
      
      state.categories.income.forEach(category => {
        const item = document.createElement('div');
        item.className = 'category-item';
        item.dataset.id = category.id;
        item.dataset.type = 'income';
        
        item.innerHTML = `
          <div class="category-item-content">
            <div class="category-item-icon">${category.icon || ''}</div>
            <div>${category.name}</div>
          </div>
          <div class="category-item-actions">
            <button class="btn btn-icon btn-outline edit-category-btn">
              <svg width="16" height="16">
                <use href="#icon-edit"></use>
              </svg>
            </button>
            <button class="btn btn-icon btn-outline delete-category-btn">
              <svg width="16" height="16">
                <use href="#icon-trash"></use>
              </svg>
            </button>
          </div>
        `;
        
        incomeList.appendChild(item);
      });
    }
    
    // Renderizar categorias de despesa
    const expenseList = $('#expenseCategoriesList');
    if (expenseList) {
      expenseList.innerHTML = '';
      
      state.categories.expense.forEach(category => {
        const item = document.createElement('div');
        item.className = 'category-item';
        item.dataset.id = category.id;
        item.dataset.type = 'expense';
        
        item.innerHTML = `
          <div class="category-item-content">
            <div class="category-item-icon">${category.icon || ''}</div>
            <div>${category.name}</div>
          </div>
          <div class="category-item-actions">
            <button class="btn btn-icon btn-outline edit-category-btn">
              <svg width="16" height="16">
                <use href="#icon-edit"></use>
              </svg>
            </button>
            <button class="btn btn-icon btn-outline delete-category-btn">
              <svg width="16" height="16">
                <use href="#icon-trash"></use>
              </svg>
            </button>
          </div>
        `;
        
        expenseList.appendChild(item);
      });
    }
    
    // Adicionar event listeners
    $$('.edit-category-btn').forEach(btn => {
      btn.addEventListener('click', e => {
        const item = e.target.closest('.category-item');
        const id = item.dataset.id;
        const type = item.dataset.type;
        
        const categories = type === 'income' ? state.categories.income : state.categories.expense;
        const category = categories.find(c => c.id === id);
        
        if (category) {
          openEditCategoryModal(category, type);
        }
      });
    });
    
    $$('.delete-category-btn').forEach(btn => {
      btn.addEventListener('click', e => {
        const item = e.target.closest('.category-item');
        const id = item.dataset.id;
        const type = item.dataset.type;
        
        deleteCategory(id, type);
      });
    });
  };

  // AJUSTE 6: Função para renderizar lista de categorias de investimento
  const renderInvestmentCategoriesList = () => {
    const investmentList = $('#investmentCategoriesList');
    if (!investmentList) return;
    
    investmentList.innerHTML = '';
    
    state.categories.investment.forEach(category => {
      const item = document.createElement('div');
      item.className = 'category-item';
      item.dataset.id = category.id;
      item.dataset.type = 'investment';
      
      item.innerHTML = `
        <div class="category-item-content">
          <div class="category-item-icon">${category.icon || ''}</div>
          <div>${category.name}</div>
        </div>
        <div class="category-item-actions">
          <button class="btn btn-icon btn-outline edit-category-btn">
            <svg width="16" height="16">
              <use href="#icon-edit"></use>
            </svg>
          </button>
          <button class="btn btn-icon btn-outline delete-category-btn">
            <svg width="16" height="16">
              <use href="#icon-trash"></use>
            </svg>
          </button>
        </div>
      `;
      
      investmentList.appendChild(item);
    });
    
    // Adicionar event listeners
    $$('#investmentCategoriesList .edit-category-btn').forEach(btn => {
      btn.addEventListener('click', e => {
        const item = e.target.closest('.category-item');
        const id = item.dataset.id;
        
        const category = state.categories.investment.find(c => c.id === id);
        
        if (category) {
          openEditCategoryModal(category, 'investment');
        }
      });
    });
    
    $$('#investmentCategoriesList .delete-category-btn').forEach(btn => {
      btn.addEventListener('click', e => {
        const item = e.target.closest('.category-item');
        const id = item.dataset.id;
        
        deleteCategory(id, 'investment');
      });
    });
  };

  // Função para renderizar lista de métodos de pagamento
  const renderPaymentMethodsList = () => {
    const methodsList = $('#paymentMethodsList');
    if (!methodsList) return;
    
    methodsList.innerHTML = '';
    
    state.paymentMethods.forEach(method => {
      const item = document.createElement('div');
      item.className = 'category-item';
      item.dataset.id = method.id;
      
      item.innerHTML = `
        <div class="category-item-content">
          <div class="category-item-icon">${method.icon || ''}</div>
          <div>${method.name}</div>
        </div>
        <div class="category-item-actions">
          <button class="btn btn-icon btn-outline edit-payment-method-btn">
            <svg width="16" height="16">
              <use href="#icon-edit"></use>
            </svg>
          </button>
          <button class="btn btn-icon btn-outline delete-payment-method-btn">
            <svg width="16" height="16">
              <use href="#icon-trash"></use>
            </svg>
          </button>
        </div>
      `;
      
      methodsList.appendChild(item);
    });
    
    // Adicionar event listeners
    $$('.edit-payment-method-btn').forEach(btn => {
      btn.addEventListener('click', e => {
        const item = e.target.closest('.category-item');
        const id = item.dataset.id;
        
        const method = state.paymentMethods.find(m => m.id === id);
        
        if (method) {
          openEditCategoryModal(method, 'paymentMethod');
        }
      });
    });
    
    $$('.delete-payment-method-btn').forEach(btn => {
      btn.addEventListener('click', e => {
        const item = e.target.closest('.category-item');
        const id = item.dataset.id;
        
        deletePaymentMethod(id);
      });
    });
  };

  // Função para renderizar lista de pessoas
  const updatePeopleList = () => {
    const peopleList = $('#peopleList');
    if (!peopleList) return;
    
    peopleList.innerHTML = '';
    
    state.people.forEach(person => {
      const item = document.createElement('div');
      item.className = 'category-item';
      item.dataset.id = person.id;
      
      item.innerHTML = `
        <div class="category-item-content">
          <div class="category-item-icon">${person.icon || ''}</div>
          <div>${person.name}</div>
        </div>
        <div class="category-item-actions">
          <button class="btn btn-icon btn-outline edit-person-btn">
            <svg width="16" height="16">
              <use href="#icon-edit"></use>
            </svg>
          </button>
          <button class="btn btn-icon btn-outline delete-person-btn">
            <svg width="16" height="16">
              <use href="#icon-trash"></use>
            </svg>
          </button>
        </div>
      `;
      
      peopleList.appendChild(item);
    });
    
    // Adicionar event listeners
    $$('.edit-person-btn').forEach(btn => {
      btn.addEventListener('click', e => {
        const item = e.target.closest('.category-item');
        const id = item.dataset.id;
        
        const person = state.people.find(p => p.id === id);
        
        if (person) {
          openEditCategoryModal(person, 'person');
        }
      });
    });
    
    $$('.delete-person-btn').forEach(btn => {
      btn.addEventListener('click', e => {
        const item = e.target.closest('.category-item');
        const id = item.dataset.id;
        
        deletePerson(id);
      });
    });
  };

  // Função para abrir modal de edição de categoria
  const openEditCategoryModal = (category, type) => {
    state.currentCategory = category;
    
    // Preencher o formulário
    $('#editCategoryId').value = category.id;
    $('#editCategoryType').value = type;
    $('#editCategoryName').value = category.name;
    $('#editCategoryIconInput').value = category.icon || '';
    
    // Atualizar a prévia do ícone
    $('#editCategoryIconPreview').innerHTML = category.icon || `
      <svg width="24" height="24">
        <use href="#icon-default"></use>
      </svg>
    `;
    
    // Alterar título do modal
    const titles = {
      'income': 'Editar Categoria de Receita',
      'expense': 'Editar Categoria de Despesa',
      'investment': 'Editar Categoria de Investimento',
      'paymentMethod': 'Editar Forma de Pagamento',
      'person': 'Editar Pessoa'
    };
    
    $('#editCategoryTitle').textContent = titles[type] || 'Editar';
    
    // Abrir o modal
    openModal('editCategoryModal');
  };

  // Função para adicionar categoria
  const addCategory = async (name, icon, type) => {
    try {
      // Validar
      if (!name.trim()) {
        showToast('O nome da categoria não pode ficar em branco.', 'error');
        return null;
      }
      
      // Criar ID seguro para URL
      const id = `${name.toLowerCase().replace(/[^a-z0-9]/g, '_')}_${generateId()}`;
      
      // Criar objeto da categoria
      const category = { id, name, icon, type };
      
      // Adicionar ao Firestore
      await db.collection('categories').doc(id).set(category);
      
      // Adicionar ao estado local
      if (type === 'income') {
        state.categories.income.push(category);
      } else if (type === 'expense') {
        state.categories.expense.push(category);
      } else if (type === 'investment') {
        state.categories.investment.push(category);
      }
      
      // Atualizar UI
      renderCategoriesList();
      renderInvestmentCategoriesList();
      updateCategorySelects();
      
      showToast('Categoria adicionada com sucesso!', 'success');
      
      return category;
    } catch (error) {
      console.error('Erro ao adicionar categoria:', error);
      showToast('Erro ao adicionar categoria. Tente novamente.', 'error');
      return null;
    }
  };

  // Função para adicionar forma de pagamento
  const addPaymentMethod = async (name, icon) => {
    try {
      // Validar
      if (!name.trim()) {
        showToast('O nome da forma de pagamento não pode ficar em branco.', 'error');
        return null;
      }
      
      // Criar ID seguro para URL
      const id = `${name.toLowerCase().replace(/[^a-z0-9]/g, '_')}_${generateId()}`;
      
      // Criar objeto do método de pagamento
      const method = { id, name, icon };
      
      // Adicionar ao Firestore
      await db.collection('paymentMethods').doc(id).set(method);
      
      // Adicionar ao estado local
      state.paymentMethods.push(method);
      
      // Atualizar UI
      renderPaymentMethodsList();
      updatePaymentMethodSelects();
      
      showToast('Forma de pagamento adicionada com sucesso!', 'success');
      
      return method;
    } catch (error) {
      console.error('Erro ao adicionar forma de pagamento:', error);
      showToast('Erro ao adicionar forma de pagamento. Tente novamente.', 'error');
      return null;
    }
  };

  // Função para adicionar pessoa
  const addPerson = async (name, icon) => {
    try {
      // Validar
      if (!name.trim()) {
        showToast('O nome da pessoa não pode ficar em branco.', 'error');
        return null;
      }
      
      // Criar ID seguro para URL
      const id = `${name.toLowerCase().replace(/[^a-z0-9]/g, '_')}_${generateId()}`;
      
      // Criar objeto da pessoa
      const person = { id, name, icon };
      
      // Adicionar ao Firestore
      await db.collection('people').doc(id).set(person);
      
      // Adicionar ao estado local
      state.people.push(person);
      
      // Atualizar UI
      updatePeopleList();
      updatePeopleSelects();
      
      showToast('Pessoa adicionada com sucesso!', 'success');
      
      return person;
    } catch (error) {
      console.error('Erro ao adicionar pessoa:', error);
      showToast('Erro ao adicionar pessoa. Tente novamente.', 'error');
      return null;
    }
  };

  // Função para atualizar categoria
  const updateCategory = async (id, updates, type) => {
    try {
      // Atualizar no Firestore
      await db.collection('categories').doc(id).update(updates);
      
      // Atualizar no estado local
      if (type === 'income') {
        const index = state.categories.income.findIndex(c => c.id === id);
        if (index !== -1) {
          state.categories.income[index] = { ...state.categories.income[index], ...updates };
        }
      } else if (type === 'expense') {
        const index = state.categories.expense.findIndex(c => c.id === id);
        if (index !== -1) {
          state.categories.expense[index] = { ...state.categories.expense[index], ...updates };
        }
      } else if (type === 'investment') {
        const index = state.categories.investment.findIndex(c => c.id === id);
        if (index !== -1) {
          state.categories.investment[index] = { ...state.categories.investment[index], ...updates };
        }
      }
      
      // Atualizar UI
      renderCategoriesList();
      renderInvestmentCategoriesList();
      updateCategorySelects();
      
      // Atualizar transações que usam esta categoria
      if (type === 'income' || type === 'expense') {
        const batch = db.batch();
        
        state.transactions.forEach(transaction => {
          if (transaction.category === id) {
            const docRef = db.collection('transactions').doc(transaction.id);
            batch.update(docRef, {
              categoryName: updates.name,
              categoryIcon: updates.icon
            });
            
            // Atualizar no estado local
            transaction.categoryName = updates.name;
            transaction.categoryIcon = updates.icon;
          }
        });
        
        await batch.commit();
        
        // Atualizar UI
        updateTransactionsTable();
      }
      
      showToast('Categoria atualizada com sucesso!', 'success');
      
      return true;
    } catch (error) {
      console.error('Erro ao atualizar categoria:', error);
      showToast('Erro ao atualizar categoria. Tente novamente.', 'error');
      return false;
    }
  };

  // Função para atualizar forma de pagamento
  const updatePaymentMethod = async (id, updates) => {
    try {
      // Atualizar no Firestore
      await db.collection('paymentMethods').doc(id).update(updates);
      
      // Atualizar no estado local
      const index = state.paymentMethods.findIndex(m => m.id === id);
      if (index !== -1) {
        state.paymentMethods[index] = { ...state.paymentMethods[index], ...updates };
      }
      
      // Atualizar UI
      renderPaymentMethodsList();
      updatePaymentMethodSelects();
      
      // Atualizar transações que usam este método
      const batch = db.batch();
      
      state.transactions.forEach(transaction => {
        if (transaction.paymentMethod === id) {
          const docRef = db.collection('transactions').doc(transaction.id);
          batch.update(docRef, {
            paymentMethodName: updates.name,
            paymentMethodIcon: updates.icon
          });
          
          // Atualizar no estado local
          transaction.paymentMethodName = updates.name;
          transaction.paymentMethodIcon = updates.icon;
        }
      });
      
      await batch.commit();
      
      // Atualizar UI
      updateTransactionsTable();
      
      showToast('Forma de pagamento atualizada com sucesso!', 'success');
      
      return true;
    } catch (error) {
      console.error('Erro ao atualizar forma de pagamento:', error);
      showToast('Erro ao atualizar forma de pagamento. Tente novamente.', 'error');
      return false;
    }
  };

  // Função para atualizar pessoa
  const updatePerson = async (id, updates) => {
    try {
      // Atualizar no Firestore
      await db.collection('people').doc(id).update(updates);
      
      // Atualizar no estado local
      const index = state.people.findIndex(p => p.id === id);
      if (index !== -1) {
        state.people[index] = { ...state.people[index], ...updates };
      }
      
      // Atualizar UI
      updatePeopleList();
      updatePeopleSelects();
      
      // Atualizar transações que usam esta pessoa
      const batch = db.batch();
      
      state.transactions.forEach(transaction => {
        if (transaction.person === id) {
          const docRef = db.collection('transactions').doc(transaction.id);
          batch.update(docRef, {
            personName: updates.name,
            personIcon: updates.icon
          });
          
          // Atualizar no estado local
          transaction.personName = updates.name;
          transaction.personIcon = updates.icon;
        }
      });
      
      await batch.commit();
      
      // Atualizar UI
      updateTransactionsTable();
      updateCharts();
      
      showToast('Pessoa atualizada com sucesso!', 'success');
      
      return true;
    } catch (error) {
      console.error('Erro ao atualizar pessoa:', error);
      showToast('Erro ao atualizar pessoa. Tente novamente.', 'error');
      return false;
    }
  };

  // Função para excluir categoria
  const deleteCategory = async (id, type) => {
    try {
      // Verificar se há transações usando esta categoria
      const transactionsWithCategory = state.transactions.filter(t => t.category === id);
      
      if (transactionsWithCategory.length > 0) {
        if (!confirm(`Esta categoria possui ${transactionsWithCategory.length} transações vinculadas. Deseja excluir mesmo assim?`)) {
          return false;
        }
        
        // Perguntar se deseja mover para outra categoria
        const moveToAnotherCategory = confirm('Deseja mover as transações para outra categoria?');
        
        if (moveToAnotherCategory) {
          // Obter categorias disponíveis
          const availableCategories = type === 'income' ? state.categories.income : state.categories.expense;
          
          // Remover a categoria que será excluída
          const otherCategories = availableCategories.filter(c => c.id !== id);
          
          if (otherCategories.length === 0) {
            alert('Não há outras categorias disponíveis. Crie outra categoria primeiro.');
            return false;
          }
          
          // Criar lista de opções
          const categoryOptions = otherCategories.map(c => `${c.name}`).join('\n');
          
          // Pedir ao usuário para selecionar uma categoria
          const selectedCategory = prompt(`Selecione a categoria para mover as transações:\n${categoryOptions}`);
          
          if (!selectedCategory) {
            return false;
          }
          
          // Encontrar a categoria selecionada
          const targetCategory = otherCategories.find(c => c.name === selectedCategory);
          
          if (!targetCategory) {
            alert('Categoria não encontrada.');
            return false;
          }
          
          // Atualizar transações
          const batch = db.batch();
          
          transactionsWithCategory.forEach(transaction => {
            const docRef = db.collection('transactions').doc(transaction.id);
            batch.update(docRef, {
              category: targetCategory.id,
              categoryName: targetCategory.name,
              categoryIcon: targetCategory.icon
            });
            
            // Atualizar no estado local
            transaction.category = targetCategory.id;
            transaction.categoryName = targetCategory.name;
            transaction.categoryIcon = targetCategory.icon;
          });
          
          await batch.commit();
        }
      }
      
      // Excluir a categoria
      await db.collection('categories').doc(id).delete();
      
      // Remover do estado local
      if (type === 'income') {
        state.categories.income = state.categories.income.filter(c => c.id !== id);
      } else if (type === 'expense') {
        state.categories.expense = state.categories.expense.filter(c => c.id !== id);
      } else if (type === 'investment') {
        state.categories.investment = state.categories.investment.filter(c => c.id !== id);
      }
      
      // Atualizar UI
      renderCategoriesList();
      renderInvestmentCategoriesList();
      updateCategorySelects();
      updateTransactionsTable();
      updateCharts();
      
      showToast('Categoria excluída com sucesso!', 'success');
      
      return true;
    } catch (error) {
      console.error('Erro ao excluir categoria:', error);
      showToast('Erro ao excluir categoria. Tente novamente.', 'error');
      return false;
    }
  };

  // Função para excluir forma de pagamento
  const deletePaymentMethod = async (id) => {
    try {
      // Verificar se há transações usando este método
      const transactionsWithMethod = state.transactions.filter(t => t.paymentMethod === id);
      
      if (transactionsWithMethod.length > 0) {
        if (!confirm(`Esta forma de pagamento possui ${transactionsWithMethod.length} transações vinculadas. Deseja excluir mesmo assim?`)) {
          return false;
        }
        
        // Perguntar se deseja mover para outra forma de pagamento
        const moveToAnotherMethod = confirm('Deseja mover as transações para outra forma de pagamento?');
        
        if (moveToAnotherMethod) {
          // Obter métodos disponíveis
          const otherMethods = state.paymentMethods.filter(m => m.id !== id);
          
          if (otherMethods.length === 0) {
            alert('Não há outras formas de pagamento disponíveis. Crie outra forma de pagamento primeiro.');
            return false;
          }
          
          // Criar lista de opções
          const methodOptions = otherMethods.map(m => `${m.name}`).join('\n');
          
          // Pedir ao usuário para selecionar um método
          const selectedMethod = prompt(`Selecione a forma de pagamento para mover as transações:\n${methodOptions}`);
          
          if (!selectedMethod) {
            return false;
          }
          
          // Encontrar o método selecionado
          const targetMethod = otherMethods.find(m => m.name === selectedMethod);
          
          if (!targetMethod) {
            alert('Forma de pagamento não encontrada.');
            return false;
          }
          
          // Atualizar transações
          const batch = db.batch();
          
          transactionsWithMethod.forEach(transaction => {
            const docRef = db.collection('transactions').doc(transaction.id);
            batch.update(docRef, {
              paymentMethod: targetMethod.id,
              paymentMethodName: targetMethod.name,
              paymentMethodIcon: targetMethod.icon
            });
            
            // Atualizar no estado local
            transaction.paymentMethod = targetMethod.id;
            transaction.paymentMethodName = targetMethod.name;
            transaction.paymentMethodIcon = targetMethod.icon;
          });
          
          await batch.commit();
        }
      }
      
      // Excluir a forma de pagamento
      await db.collection('paymentMethods').doc(id).delete();
      
      // Remover do estado local
      state.paymentMethods = state.paymentMethods.filter(m => m.id !== id);
      
      // Atualizar UI
      renderPaymentMethodsList();
      updatePaymentMethodSelects();
      updateTransactionsTable();
      
      showToast('Forma de pagamento excluída com sucesso!', 'success');
      
      return true;
    } catch (error) {
      console.error('Erro ao excluir forma de pagamento:', error);
      showToast('Erro ao excluir forma de pagamento. Tente novamente.', 'error');
      return false;
    }
  };

  // Função para excluir pessoa
  const deletePerson = async (id) => {
    try {
      // Verificar se há transações usando esta pessoa
      const transactionsWithPerson = state.transactions.filter(t => t.person === id);
      
      if (transactionsWithPerson.length > 0) {
        if (!confirm(`Esta pessoa possui ${transactionsWithPerson.length} transações vinculadas. Deseja excluir mesmo assim?`)) {
          return false;
        }
        
        // Perguntar se deseja mover para outra pessoa
        const moveToAnotherPerson = confirm('Deseja mover as transações para outra pessoa?');
        
        if (moveToAnotherPerson) {
          // Obter pessoas disponíveis
          const otherPeople = state.people.filter(p => p.id !== id);
          
          if (otherPeople.length === 0) {
            alert('Não há outras pessoas disponíveis. Crie outra pessoa primeiro.');
            return false;
          }
          
          // Criar lista de opções
          const personOptions = otherPeople.map(p => `${p.name}`).join('\n');
          
          // Pedir ao usuário para selecionar uma pessoa
          const selectedPerson = prompt(`Selecione a pessoa para mover as transações:\n${personOptions}`);
          
          if (!selectedPerson) {
            return false;
          }
          
          // Encontrar a pessoa selecionada
          const targetPerson = otherPeople.find(p => p.name === selectedPerson);
          
          if (!targetPerson) {
            alert('Pessoa não encontrada.');
            return false;
          }
          
          // Atualizar transações
          const batch = db.batch();
          
          transactionsWithPerson.forEach(transaction => {
            const docRef = db.collection('transactions').doc(transaction.id);
            batch.update(docRef, {
              person: targetPerson.id,
              personName: targetPerson.name,
              personIcon: targetPerson.icon
            });
            
            // Atualizar no estado local
            transaction.person = targetPerson.id;
            transaction.personName = targetPerson.name;
            transaction.personIcon = targetPerson.icon;
          });
          
          await batch.commit();
        } else {
          // Remover a pessoa das transações
          const batch = db.batch();
          
          transactionsWithPerson.forEach(transaction => {
            const docRef = db.collection('transactions').doc(transaction.id);
            batch.update(docRef, {
              person: null,
              personName: null,
              personIcon: null
            });
            
            // Atualizar no estado local
            transaction.person = null;
            transaction.personName = null;
            transaction.personIcon = null;
          });
          
          await batch.commit();
        }
      }
      
      // Excluir a pessoa
      await db.collection('people').doc(id).delete();
      
      // Remover do estado local
      state.people = state.people.filter(p => p.id !== id);
      
      // Atualizar UI
      updatePeopleList();
      updatePeopleSelects();
      updateTransactionsTable();
      updateCharts();
      
      showToast('Pessoa excluída com sucesso!', 'success');
      
      return true;
    } catch (error) {
      console.error('Erro ao excluir pessoa:', error);
      showToast('Erro ao excluir pessoa. Tente novamente.', 'error');
      return false;
    }
  };

  // Event Listeners
  // Inicialização de abas
  const initTabs = () => {
    $$('[data-toggle="tab"]').forEach(tab => {
      tab.addEventListener('click', e => {
        e.preventDefault();
        
        // Remover classe ativa de todas as abas
        $$('.nav-link').forEach(link => link.classList.remove('active'));
        
        // Adicionar classe ativa à aba clicada
        e.currentTarget.classList.add('active');
        
        // Esconder todos os painéis de conteúdo
        $$('.tab-pane').forEach(pane => {
          pane.classList.remove('active', 'show');
        });
        
        // Mostrar o painel de conteúdo correspondente
        const targetId = e.currentTarget.getAttribute('href').substring(1);
        const targetPane = $(`#${targetId}`);
        
        if (targetPane) {
          targetPane.classList.add('active');
          setTimeout(() => {
            targetPane.classList.add('show');
          }, 10);
        }
      });
    });
  };

  // Inicializar event listeners
  const initEventListeners = () => {
    // Selects de mês/ano
    $('#yearSelect')?.addEventListener('change', e => {
      state.year = parseInt(e.target.value);
      filterTransactionsByMonth();
      updateMonthYearTitle();
    });
    
    $('#monthSelect')?.addEventListener('change', e => {
      state.month = parseInt(e.target.value);
      filterTransactionsByMonth();
      updateMonthYearTitle();
    });
    
    // Botões de nova receita/despesa
    $('#newIncomeBtn')?.addEventListener('click', () => {
      // Resetar formulário
      $('#incomeForm').reset();
      
      // Definir data padrão (hoje)
      const today = new Date();
      setDateInputValue('incomeDate', today);
      
      // Abrir modal
      openModal('incomeModal');
    });
    
    $('#newExpenseBtn')?.addEventListener('click', () => {
      // Resetar formulário
      $('#expenseForm').reset();
      
      // Definir data padrão (hoje)
      const today = new Date();
      setDateInputValue('expenseDate', today);
      setDateInputValue('expenseDueDate', today);
      
      // Abrir modal
      openModal('expenseModal');
    });
    
    // AJUSTE 4: Remover botão "Nova Transação"
    // Não é necessário, já que o botão será removido do HTML
    
    // Botão de cartões
    $('#cardsBtn')?.addEventListener('click', () => {
      updateCardsList();
      openModal('cardsListModal');
    });
    
    // AJUSTE 5: Botão de tema claro/escuro já está configurado na função initTheme()
    
    // Botão de categorias
    $('#categoriesBtn')?.addEventListener('click', () => {
      renderCategoriesList();
      renderPaymentMethodsList();
      renderInvestmentCategoriesList();
      updatePeopleList();
      openModal('categoriesModal');
    });
    
    // AJUSTE 6: Botão de investimentos
    $('#investmentsBtn')?.addEventListener('click', () => {
      loadInvestments();
      openModal('investmentsModal');
    });
    
    // Fechar modais
    $$('.modal-close').forEach(close => {
      close.addEventListener('click', () => {
        const modal = close.closest('.modal-backdrop');
        if (modal) {
          closeModal(modal.id);
        }
      });
    });
    
    // Clicar fora do modal para fechar
    $$('.modal-backdrop').forEach(backdrop => {
      backdrop.addEventListener('click', e => {
        if (e.target === backdrop) {
          closeModal(backdrop.id);
        }
      });
    });
    
    // Botões de cancelar
    $('#cancelIncomeBtn')?.addEventListener('click', () => {
      closeModal('incomeModal');
    });
    
    $('#cancelExpenseBtn')?.addEventListener('click', () => {
      closeModal('expenseModal');
    });
    
    $('#cancelEditBtn')?.addEventListener('click', () => {
      closeModal('editModal');
    });
    
    $('#cancelDeleteBtn')?.addEventListener('click', () => {
      closeModal('deleteConfirmModal');
    });
    
    $('#cancelCardBtn')?.addEventListener('click', () => {
      closeModal('newCardModal');
    });
    
    $('#backToCardsBtn')?.addEventListener('click', () => {
      closeModal('cardInvoiceModal');
      openModal('cardsListModal');
    });
    
    $('#closeOverdueDetailsBtn')?.addEventListener('click', () => {
      closeModal('overdueDetailsModal');
    });
    
    // Botões de fechar no modal de categorias
    $('#closeCategoriesBtn')?.addEventListener('click', () => {
      closeModal('categoriesModal');
    });
    
    $('#closeCategoriesModal')?.addEventListener('click', () => {
      closeModal('categoriesModal');
    });
    
    $('#closeEditCategoryBtn')?.addEventListener('click', () => {
      closeModal('editCategoryModal');
    });
    
    $('#cancelEditCategoryBtn')?.addEventListener('click', () => {
      closeModal('editCategoryModal');
    });
    
    // Botões de investimentos
    $('#closeInvestmentsBtn')?.addEventListener('click', () => {
      closeModal('investmentsModal');
    });
    
    $('#closeInvestmentsModal')?.addEventListener('click', () => {
      closeModal('investmentsModal');
    });
    
    $('#backToInvestmentsBtn')?.addEventListener('click', () => {
      closeModal('investmentDetailModal');
      openModal('investmentsModal');
    });
    
    $('#closeInvestmentDetailModal')?.addEventListener('click', () => {
      closeModal('investmentDetailModal');
    });
    
    $('#closeNewInvestmentModal')?.addEventListener('click', () => {
      closeModal('newInvestmentModal');
    });
    
    $('#cancelInvestmentBtn')?.addEventListener('click', () => {
      closeModal('newInvestmentModal');
    });
    
    $('#newInvestmentBtn')?.addEventListener('click', () => {
      openNewInvestmentModal();
    });
    
    $('#addInvestmentContributionBtn')?.addEventListener('click', () => {
      openNewContributionModal();
    });
    
    $('#closeNewContributionModal')?.addEventListener('click', () => {
      closeModal('newContributionModal');
    });
    
    $('#cancelContributionBtn')?.addEventListener('click', () => {
      closeModal('newContributionModal');
    });
    
    $('#editInvestmentBtn')?.addEventListener('click', () => {
      if (state.currentInvestment) {
        openEditInvestmentModal(state.currentInvestment.id);
      }
    });
    
    $('#deleteInvestmentBtn')?.addEventListener('click', () => {
      if (state.currentInvestment && confirm('Deseja realmente excluir este investimento? Esta ação é irreversível.')) {
        deleteInvestment(state.currentInvestment.id);
      }
    });
    
    // Event listener para o botão de toggle de compromissos
    $('#commitmentsHeader')?.addEventListener('click', toggleCommitments);
    
    // Event listeners para forms
    // Form de nova receita
    $('#saveIncomeBtn')?.addEventListener('click', async () => {
      // Validar
      const nameInput = $('#incomeName');
      const amountInput = $('#incomeAmount');
      
      if (!nameInput.value.trim()) {
        showToast('O nome da receita não pode ficar em branco.', 'error');
        nameInput.focus();
        return;
      }
      
      if (!amountInput.value || parseFloat(amountInput.value) <= 0) {
        showToast('O valor da receita deve ser maior que zero.', 'error');
        amountInput.focus();
        return;
      }
      
      // Obter valores do formulário
      const formData = {
        type: 'income',
        name: nameInput.value.trim(),
        amount: parseFloat(amountInput.value),
        category: $('#incomeCategory').value,
        date: getDateInputValue('incomeDate'),
        paymentMethod: $('#incomePaymentMethod').value,
        status: $('input[name="incomeStatus"]:checked').value,
        notes: $('#incomeNotes').value.trim(),
        isRecurrent: $('#incomeIsRecurrent').checked
      };
      
      // Converter datas para string
      if (formData.date) {
        formData.date = localDateToISOString(formData.date);
      }
      
      // Verificar se é recorrente
      if (formData.isRecurrent) {
        const installments = parseInt($('#incomeInstallments').value);
        
        if (installments >= 2) {
          // Adicionar transações recorrentes
          await addRecurrentTransactions(formData, installments);
        } else {
          // Adicionar uma única transação
          await addTransaction(formData);
        }
      } else {
        // Adicionar uma única transação
        await addTransaction(formData);
      }
      
      // Fechar modal
      closeModal('incomeModal');
    });
    
    // AJUSTE 16, 13: Form de nova despesa com campo obrigatório de tipo (fixa/variável)
    $('#saveExpenseBtn')?.addEventListener('click', async () => {
      // Validar
      const nameInput = $('#expenseName');
      const amountInput = $('#expenseAmount');
      
      if (!nameInput.value.trim()) {
        showToast('O nome da despesa não pode ficar em branco.', 'error');
        nameInput.focus();
        return;
      }
      
      if (!amountInput.value || parseFloat(amountInput.value) <= 0) {
        showToast('O valor da despesa deve ser maior que zero.', 'error');
        amountInput.focus();
        return;
      }
      
      // AJUSTE 16: Validar campo obrigatório de tipo (fixa/variável)
      const isFixedElement = $('input[name="expenseType"]:checked');
      if (!isFixedElement) {
        showToast('Você deve escolher se a despesa é fixa ou variável.', 'error');
        return;
      }
      
      // Obter valores do formulário
      const formData = {
        type: 'expense',
        name: nameInput.value.trim(),
        amount: parseFloat(amountInput.value),
        category: $('#expenseCategory').value,
        paymentMethod: $('#expensePaymentMethod').value,
        date: getDateInputValue('expenseDate'),
        dueDate: getDateInputValue('expenseDueDate'),
        status: $('input[name="expenseStatus"]:checked').value,
        notes: $('#expenseNotes').value.trim(),
        isRecurrent: $('#expenseIsRecurrent').checked,
        // AJUSTE 16: Adicionar campo de tipo (fixa/variável)
        isFixed: isFixedElement ? isFixedElement.value : 'variable',
        person: $('#expensePerson').value
      };
      
      // Verificar se é cartão de crédito
      if (formData.paymentMethod === 'credito') {
        formData.creditCardId = $('#expenseCreditCard').value;
        
        if (!formData.creditCardId) {
          showToast('Você deve selecionar um cartão de crédito.', 'error');
          $('#expenseCreditCard').focus();
          return;
        }
      }
      
      // Verificar se é agendado
      if (formData.status === 'scheduled') {
        formData.scheduledDate = getDateInputValue('expenseScheduledDate');
        
        if (!formData.scheduledDate) {
          showToast('Você deve informar a data de agendamento.', 'error');
          $('#expenseScheduledDate').focus();
          return;
        }
        
        // Converter data para string
        formData.scheduledDate = localDateToISOString(formData.scheduledDate);
      }
      
      // Converter datas para string
      if (formData.date) {
        formData.date = localDateToISOString(formData.date);
      }
      
      if (formData.dueDate) {
        formData.dueDate = localDateToISOString(formData.dueDate);
      }
      
      // Verificar se é recorrente
      if (formData.isRecurrent) {
        const installments = parseInt($('#expenseInstallments').value);
        
        if (installments >= 2) {
          // Adicionar transações recorrentes
          await addRecurrentTransactions(formData, installments);
        } else {
          // Adicionar uma única transação
          await addTransaction(formData);
        }
      } else {
        // Adicionar uma única transação
        await addTransaction(formData);
      }
      
      // Fechar modal
      closeModal('expenseModal');
    });
    
    // Form de edição de transação
    $('#saveEditBtn')?.addEventListener('click', async () => {
      const id = $('#editTransactionId').value;
      const type = $('#editTransactionType').value;
      
      // Validar
      const nameInput = $('#editName');
      const amountInput = $('#editAmount');
      
      if (!nameInput.value.trim()) {
        showToast('O nome não pode ficar em branco.', 'error');
        nameInput.focus();
        return;
      }
      
      if (!amountInput.value || parseFloat(amountInput.value) <= 0) {
        showToast('O valor deve ser maior que zero.', 'error');
        amountInput.focus();
        return;
      }
      
      // Obter valores do formulário
      const updates = {
        name: nameInput.value.trim(),
        amount: parseFloat(amountInput.value),
        category: $('#editCategory').value,
        date: getDateInputValue('editDate'),
        paymentMethod: $('#editPaymentMethod').value,
        notes: $('#editNotes').value.trim(),
        isRecurrent: $('#editIsRecurrent').checked,
        person: $('#editPerson').value
      };
      
      // AJUSTE 16: Atualizar campo de tipo (fixa/variável) para despesas
      if (type === 'expense') {
        const isFixedElement = $('input[name="editExpenseType"]:checked');
        if (isFixedElement) {
          updates.isFixed = isFixedElement.value;
        }
      }
      
      // Verificar tipo específico
      if (type === 'income') {
        // Atualizar status
        updates.status = $('input[name="editStatus"]:checked').value;
      } else {
        // Data de vencimento para despesas
        updates.dueDate = getDateInputValue('editDueDate');
        
        // Status
        updates.status = $('input[name="editStatus"]:checked').value;
        
        // Data de agendamento para status agendado
        if (updates.status === 'scheduled') {
          updates.scheduledDate = getDateInputValue('editScheduledDate');
          
          if (!updates.scheduledDate) {
            showToast('Você deve informar a data de agendamento.', 'error');
            $('#editScheduledDate').focus();
            return;
          }
        }
        
        // Cartão de crédito
        if (updates.paymentMethod === 'credito') {
          updates.creditCardId = $('#editCreditCard').value;
          
          if (!updates.creditCardId) {
            showToast('Você deve selecionar um cartão de crédito.', 'error');
            $('#editCreditCard').focus();
            return;
          }
        }
      }
      
      // Atualizar transação
      await updateTransaction(id, updates);
      
      // Fechar modal
      closeModal('editModal');
    });
    
    // Confirmação de exclusão de transação
    $('#confirmDeleteBtn')?.addEventListener('click', async () => {
      const id = state.currentTransaction.id;
      
      // Verificar se é recorrente e escolher opção
      const isRecurrent = state.currentTransaction.isRecurrent && state.currentTransaction.recurrenceId;
      
      if (isRecurrent && $('#deleteAllFuture').checked) {
        await deleteTransaction(id, { deleteOption: 'future' });
      } else {
        await deleteTransaction(id, { deleteOption: 'single' });
      }
      
      // Fechar modal
      closeModal('deleteConfirmModal');
    });
    
    // Form de cartão de crédito
    $('#saveCardBtn')?.addEventListener('click', async () => {
      // Validar
      const nameInput = $('#cardName');
      const limitInput = $('#cardLimit');
      const closingDayInput = $('#cardClosingDay');
      const dueDayInput = $('#cardDueDay');
      
      if (!nameInput.value.trim()) {
        showToast('O nome do cartão não pode ficar em branco.', 'error');
        nameInput.focus();
        return;
      }
      
      if (!limitInput.value || parseFloat(limitInput.value) <= 0) {
        showToast('O limite total deve ser maior que zero.', 'error');
        limitInput.focus();
        return;
      }
      
      const closingDay = parseInt(closingDayInput.value);
      if (!closingDayInput.value || closingDay < 1 || closingDay > 31) {
        showToast('O dia de fechamento deve estar entre 1 e 31.', 'error');
        closingDayInput.focus();
        return;
      }
      
      const dueDay = parseInt(dueDayInput.value);
      if (!dueDayInput.value || dueDay < 1 || dueDay > 31) {
        showToast('O dia de vencimento deve estar entre 1 e 31.', 'error');
        dueDayInput.focus();
        return;
      }
      
      // Criar objeto do cartão
      const cardData = {
        name: nameInput.value.trim(),
        limit: parseFloat(limitInput.value),
        closingDay: closingDay,
        dueDay: dueDay
      };
      
      // Verificar se é edição ou novo cartão
      if ($('#saveCardBtn').dataset.id) {
        // Editar
        await updateCard($('#saveCardBtn').dataset.id, cardData);
      } else {
        // Novo
        await addCard(cardData);
      }
      
      // Fechar modal
      closeModal('newCardModal');
    });
    
    // Form de confirmação de pagamento de fatura
    $('#confirmPayInvoiceBtn')?.addEventListener('click', async () => {
      if (state.currentCard) {
        await payCardInvoice(state.currentCard.id);
      }
    });
    
    // Cancelar pagamento de fatura
    $('#cancelPayInvoiceBtn')?.addEventListener('click', () => {
      closeModal('payInvoiceConfirmModal');
    });
    
    $('#closePayInvoiceConfirmModal')?.addEventListener('click', () => {
      closeModal('payInvoiceConfirmModal');
    });
    
    // Botão para abrir modal de pagamento de fatura
    $('#payInvoiceBtn')?.addEventListener('click', () => {
      if (state.currentCard) {
        $('#invoiceConfirmAmount').textContent = formatCurrency(state.currentCard.currentInvoice || 0);
        openModal('payInvoiceConfirmModal');
      }
    });
    
    // Formulários para categorias
    $('#addIncomeCategoryBtn')?.addEventListener('click', async () => {
      const name = $('#newIncomeCategoryInput').value.trim();
      const icon = $('#newIncomeCategoryIconInput').value.trim();
      
      if (name) {
        await addCategory(name, icon, 'income');
        $('#newIncomeCategoryInput').value = '';
        $('#newIncomeCategoryIconInput').value = '';
        $('#newIncomeCategoryIconPreview').innerHTML = `
          <svg width="24" height="24">
            <use href="#icon-money"></use>
          </svg>
        `;
      }
    });
    
    $('#addExpenseCategoryBtn')?.addEventListener('click', async () => {
      const name = $('#newExpenseCategoryInput').value.trim();
      const icon = $('#newExpenseCategoryIconInput').value.trim();
      
      if (name) {
        await addCategory(name, icon, 'expense');
        $('#newExpenseCategoryInput').value = '';
        $('#newExpenseCategoryIconInput').value = '';
        $('#newExpenseCategoryIconPreview').innerHTML = `
          <svg width="24" height="24">
            <use href="#icon-shopping"></use>
          </svg>
        `;
      }
    });
    
    // AJUSTE 2: Formulário para categorias de investimento
    $('#addInvestmentCategoryBtn')?.addEventListener('click', async () => {
      const name = $('#newInvestmentCategoryInput').value.trim();
      const icon = $('#newInvestmentCategoryIconInput').value.trim();
      
      if (name) {
        await addCategory(name, icon, 'investment');
        $('#newInvestmentCategoryInput').value = '';
        $('#newInvestmentCategoryIconInput').value = '';
        $('#newInvestmentCategoryIconPreview').innerHTML = `
          <svg width="24" height="24">
            <use href="#icon-chart"></use>
          </svg>
        `;
      }
    });
    
    $('#addPaymentMethodBtn')?.addEventListener('click', async () => {
      const name = $('#newPaymentMethodInput').value.trim();
      const icon = $('#newPaymentMethodIconInput').value.trim();
      
      if (name) {
        await addPaymentMethod(name, icon);
        $('#newPaymentMethodInput').value = '';
        $('#newPaymentMethodIconInput').value = '';
        $('#newPaymentMethodIconPreview').innerHTML = `
          <svg width="24" height="24">
            <use href="#icon-money"></use>
          </svg>
        `;
      }
    });
    
    $('#addPersonBtn')?.addEventListener('click', async () => {
      const name = $('#newPersonInput').value.trim();
      const icon = $('#newPersonIconInput').value.trim();
      
      if (name) {
        await addPerson(name, icon);
        $('#newPersonInput').value = '';
        $('#newPersonIconInput').value = '';
        $('#newPersonIconPreview').innerHTML = `
          <svg width="24" height="24">
            <use href="#icon-default"></use>
          </svg>
        `;
      }
    });
    
    // Salvar alterações de categoria
    $('#saveEditCategoryBtn')?.addEventListener('click', async () => {
      const id = $('#editCategoryId').value;
      const type = $('#editCategoryType').value;
      const name = $('#editCategoryName').value.trim();
      const icon = $('#editCategoryIconInput').value.trim();
      
      if (!name) {
        showToast('O nome não pode ficar em branco.', 'error');
        $('#editCategoryName').focus();
        return;
      }
      
      const updates = { name, icon };
      
      if (type === 'income' || type === 'expense' || type === 'investment') {
        await updateCategory(id, updates, type);
      } else if (type === 'paymentMethod') {
        await updatePaymentMethod(id, updates);
      } else if (type === 'person') {
        await updatePerson(id, updates);
      }
      
      closeModal('editCategoryModal');
    });
    
    // Event listeners para ícones personalizados
    const setupIconPreview = (inputId, previewId, defaultIcon) => {
      const input = $(`#${inputId}`);
      const preview = $(`#${previewId}`);
      
      if (!input || !preview) return;
      
      input.addEventListener('input', e => {
        const value = e.target.value.trim();
        
        if (value) {
          preview.innerHTML = value;
        } else {
          preview.innerHTML = defaultIcon;
        }
      });
    };
    
    setupIconPreview('newIncomeCategoryIconInput', 'newIncomeCategoryIconPreview', '<svg width="24" height="24"><use href="#icon-money"></use></svg>');
    setupIconPreview('newExpenseCategoryIconInput', 'newExpenseCategoryIconPreview', '<svg width="24" height="24"><use href="#icon-shopping"></use></svg>');
    setupIconPreview('newInvestmentCategoryIconInput', 'newInvestmentCategoryIconPreview', '<svg width="24" height="24"><use href="#icon-chart"></use></svg>');
    setupIconPreview('newPaymentMethodIconInput', 'newPaymentMethodIconPreview', '<svg width="24" height="24"><use href="#icon-money"></use></svg>');
    setupIconPreview('newPersonIconInput', 'newPersonIconPreview', '<svg width="24" height="24"><use href="#icon-default"></use></svg>');
    setupIconPreview('editCategoryIconInput', 'editCategoryIconPreview', '<svg width="24" height="24"><use href="#icon-default"></use></svg>');
    
    // AJUSTE 13: Mostrar ou esconder campo de cartão de crédito com base na forma de pagamento
    $('#expensePaymentMethod')?.addEventListener('change', e => {
      if (e.target.value === 'credito') {
        $('#creditCardGroup').style.display = 'block';
      } else {
        $('#creditCardGroup').style.display = 'none';
      }
    });
    
    // Botão para novo cartão
    $('#newCardBtn')?.addEventListener('click', () => {
      // Resetar formulário
      $('#cardForm').reset();
      
      // Alterar título do modal e texto do botão
      $('.modal-title', $('#newCardModal')).textContent = 'Novo Cartão';
      $('#saveCardBtn').textContent = 'Salvar Cartão';
      
      // Remover ID do cartão do botão de salvar
      $('#saveCardBtn').removeAttribute('data-id');
      
      // Abrir modal
      closeModal('cardsListModal');
      openModal('newCardModal');
    });
    
    // Campos de recorrência
    $('#incomeIsRecurrent')?.addEventListener('change', e => {
      if (e.target.checked) {
        $('#incomeRecurrenceGroup').style.display = 'block';
      } else {
        $('#incomeRecurrenceGroup').style.display = 'none';
      }
    });
    
    $('#expenseIsRecurrent')?.addEventListener('change', e => {
      if (e.target.checked) {
        $('#expenseRecurrenceGroup').style.display = 'block';
      } else {
        $('#expenseRecurrenceGroup').style.display = 'none';
      }
    });
    
    // Campo de data de agendamento
    $$('input[name="expenseStatus"]').forEach(radio => {
      radio.addEventListener('change', e => {
        if (e.target.value === 'scheduled') {
          $('#scheduledDateGroup').style.display = 'block';
          
          // Se não houver data de agendamento, definir para hoje
          if (!$('#expenseScheduledDate').value) {
            setDateInputValue('expenseScheduledDate', new Date());
          }
        } else {
          $('#scheduledDateGroup').style.display = 'none';
        }
      });
    });
    
    // Formulários de investimento
    $('#saveInvestmentBtn')?.addEventListener('click', async () => {
      const nameInput = $('#investmentName');
      const amountInput = $('#investmentAmount');
      
      if (!nameInput.value.trim()) {
        showToast('O nome do investimento não pode ficar em branco.', 'error');
        nameInput.focus();
        return;
      }
      
      if (!amountInput.value || parseFloat(amountInput.value) < 0) {
        showToast('O valor inicial não pode ser negativo.', 'error');
        amountInput.focus();
        return;
      }
      
      // Obter valores
      const formData = {
        name: nameInput.value.trim(),
        amount: parseFloat(amountInput.value),
        goal: $('#investmentGoal').value ? parseFloat($('#investmentGoal').value) : null,
        category: $('#investmentCategory').value,
        targetDate: getDateInputValue('investmentTargetDate'),
        notes: $('#investmentNotes').value.trim()
      };
      
      // Converter datas
      if (formData.targetDate) {
        formData.targetDate = localDateToISOString(formData.targetDate);
      }
      
      // Verificar se é edição ou novo
      if ($('#saveInvestmentBtn').dataset.action === 'update') {
        const id = $('#saveInvestmentBtn').dataset.id;
        await updateInvestment(id, formData);
        
        // Se for o investimento atual, atualizar detalhes
        if (state.currentInvestment && state.currentInvestment.id === id) {
          openInvestmentDetail(id);
        }
      } else {
        // Novo investimento
        const investment = await addInvestment(formData);
        
        if (investment) {
          // Abrir detalhes do novo investimento
          state.currentInvestment = investment;
          openInvestmentDetail(investment.id);
        }
      }
      
      // Fechar modal
      closeModal('newInvestmentModal');
    });
    
    // Formulários de contribuição
    $('#saveContributionBtn')?.addEventListener('click', async () => {
      const amountInput = $('#contributionAmount');
      const dateInput = $('#contributionDate');
      
      if (!amountInput.value || parseFloat(amountInput.value) <= 0) {
        showToast('O valor deve ser maior que zero.', 'error');
        amountInput.focus();
        return;
      }
      
      if (!dateInput.value) {
        showToast('A data não pode ficar em branco.', 'error');
        dateInput.focus();
        return;
      }
      
      // Obter valores
      const formData = {
        investmentId: $('#contributionInvestmentId').value,
        amount: parseFloat(amountInput.value),
        date: getDateInputValue('contributionDate'),
        description: $('#contributionDescription').value.trim()
      };
      
      // Converter datas
      if (formData.date) {
        formData.date = localDateToISOString(formData.date);
      }
      
      // Verificar se é edição ou nova
      if ($('#saveContributionBtn').dataset.action === 'update') {
        const id = $('#saveContributionBtn').dataset.id;
        await updateContribution(id, formData);
      } else {
        // Nova contribuição
        await addContribution(formData);
      }
      
      // Fechar modal
      closeModal('newContributionModal');
    });
  };

  // Inicialização da aplicação
  const initApp = async () => {
    try {
      // Inicializar preferência de tema
      initTheme();
      
      // Inicializar abas
      initTabs();
      
      // Definir data atual nos selects
      const today = new Date();
      state.year = today.getFullYear();
      state.month = today.getMonth();
      
      updateYearOptions();
      
      $('#yearSelect').value = state.year;
      $('#monthSelect').value = state.month;
      
      // Carregar dados
      await loadCategoriesAndPaymentMethods();
      await loadCards();
      await loadTransactions();
      
      // Inicializar event listeners
      initEventListeners();
      
      // Mostrar mensagem de boas-vindas
      showToast('Bem-vindo(a) ao Gestão Financeira da Família!', 'success');
      
    } catch (error) {
      console.error('Erro ao inicializar aplicação:', error);
      showToast('Erro ao inicializar aplicação. Tente recarregar a página.', 'error');
    }
  };

  // Iniciar a aplicação quando o DOM estiver carregado
  document.addEventListener('DOMContentLoaded', initApp);
</script>
</body>
</html>
