<!DOCTYPE html>
<html lang="pt-BR" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calculadora Financeira Familiar Premium</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.4/moment.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.4/locale/pt-br.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/uuid/8.3.2/uuid.min.js"></script>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.10.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.10.0/firebase-firestore-compat.js"></script>

    <style>
    /* ===== Variáveis e Temas (Estilo Apple/Google) ===== */
    :root {
      --font-sans: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      --radius-sm: 0.75rem; /* 12px */
      --radius: 1.125rem; /* 18px */
      --radius-lg: 1.5rem; /* 24px */
      --shadow: 0 4px 12px rgba(0,0,0,0.07), 0 1px 3px rgba(0,0,0,0.05);
      --shadow-hover: 0 6px 16px rgba(0,0,0,0.09), 0 2px 6px rgba(0,0,0,0.07);
      --shadow-dropdown: 0 5px 20px rgba(0,0,0,0.12);
      --transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);

      /* Cores Light */
      --bg: #F9F9FB; /* Slightly off-white */
      --card-bg: #FFFFFF;
      --input-bg: rgba(118, 118, 128, 0.12); /* System Gray 5 (0.12 alpha) */
      --text: #1C1C1E; /* Almost Black */
      --text-secondary: #8A8A8E; /* System Gray */
      --primary: #007AFF; /* Blue */
      --primary-light: #5856D6; /* Indigo for accents if needed */
      --success: #34C759; /* Green */
      --warning: #FF9500; /* Orange */
      --danger: #FF3B30; /* Red */
      --info: #5AC8FA; /* Teal */
      --border: rgba(60, 60, 67, 0.20); /* Separator Light */
      --chart-grid: rgba(60, 60, 67, 0.10);
      --menu-bg: rgba(255, 255, 255, 0.85); /* Translucent */
      --insight-bg: rgba(0, 122, 255, 0.08); /* Light Blue BG */
      --importance-extrema: #FF3B30; /* Red */
      --importance-urgente: #FF9500; /* Orange */
      --importance-importante: #FFCC00; /* Yellow */
    }

    [data-theme="dark"] {
      /* Cores Dark */
      --bg: #000000; /* True Black for OLED */
      --card-bg: #1C1C1E; /* Gray 6 */
      --input-bg: rgba(118, 118, 128, 0.24); /* System Gray 5 (0.24 alpha) */
      --text: #FFFFFF;
      --text-secondary: #8E8E93; /* Gray */
      --primary: #0A84FF; /* Blue */
      --primary-light: #5E5CE6; /* Indigo */
      --success: #30D158; /* Green */
      --warning: #FF9F0A; /* Orange */
      --danger: #FF453A; /* Red */
      --info: #64D2FF; /* Teal */
      --border: rgba(84, 84, 88, 0.4); /* Separator Dark */
      --chart-grid: rgba(84, 84, 88, 0.2);
      --menu-bg: rgba(28, 28, 30, 0.85); /* Translucent */
      --insight-bg: rgba(10, 132, 255, 0.15); /* Light Blue BG */
      --importance-extrema: #FF453A; /* Red */
      --importance-urgente: #FF9F0A; /* Orange */
      --importance-importante: #FFD60A; /* Yellow */
    }

    /* ===== Reset e Configurações Base ===== */
    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    html, body {
      font-family: var(--font-sans);
      background: var(--bg);
      color: var(--text);
      transition: background 0.3s ease, color 0.3s ease;
      font-size: 16px;
      line-height: 1.5;
      width: 100%;
      overflow-x: hidden;
    }

    /* ===== Layout e Componentes ===== */
    .container {
      max-width: 1320px; /* Slightly wider */
      margin: 0 auto;
      padding: 2rem;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 2rem;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .header-title {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    h1 {
      font-size: 1.875rem; /* 30px */
      font-weight: 700;
      margin: 0;
      letter-spacing: -0.03em;
    }

    .header-right {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    /* Tabs */
    .tabs {
      display: flex;
      border-bottom: 1px solid var(--border);
      margin-bottom: 2rem;
      overflow-x: auto;
      scrollbar-width: none; /* Firefox */
      -ms-overflow-style: none; /* IE */
    }
    .tabs::-webkit-scrollbar { display: none; /* Chrome/Safari */ }

    .tab {
      padding: 0.875rem 1.5rem; /* Slightly taller */
      font-weight: 600; /* Bolder */
      font-size: 0.9375rem; /* 15px */
      color: var(--text-secondary);
      cursor: pointer;
      white-space: nowrap;
      border-bottom: 3px solid transparent;
      transition: var(--transition);
      margin-bottom: -1px; /* Overlap border */
    }

    .tab:hover {
      color: var(--text);
      background-color: var(--input-bg);
    }

    .tab.active {
      color: var(--primary);
      border-color: var(--primary);
    }

    .tab-content {
        display: none; /* Hide all by default */
        animation: fadeIn 0.5s ease-out;
    }

    .tab-content.active {
        display: block; /* Show active */
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }


    /* KPIs Card */
     .kpis {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 1.25rem;
      margin-bottom: 2rem;
    }

    .card {
      background: var(--card-bg);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 1.5rem;
      transition: var(--transition);
      overflow: hidden;
      position: relative;
    }

    .card:hover {
      transform: translateY(-3px);
      box-shadow: var(--shadow-hover);
    }

    .kpi-card {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .kpi-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.25rem;
    }

    .kpi-title {
      font-size: 0.9375rem; /* 15px */
      font-weight: 500;
      color: var(--text-secondary);
    }

    .kpi-icon {
        color: var(--text-secondary);
        opacity: 0.7;
    }

    .kpi-value {
      font-size: 1.75rem; /* 28px */
      font-weight: 700;
      letter-spacing: -0.02em;
      line-height: 1.2;
    }

    .kpi-footer {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.75rem;
      font-size: 0.8125rem; /* 13px */
      color: var(--text-secondary);
    }

    .kpi-trend {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      font-weight: 500;
    }

    .kpi-trend.up { color: var(--success); }
    .kpi-trend.down { color: var(--danger); }
    .kpi-trend.neutral { color: var(--text-secondary); }

    .kpi-trend svg {
      width: 0.875rem; /* 14px */
      height: 0.875rem;
      stroke-width: 2.5;
    }

    .progress-container {
      width: 100%;
      height: 0.5rem; /* 8px */
      background-color: var(--input-bg);
      border-radius: 1rem;
      overflow: hidden;
      margin-top: 0.25rem;
    }

    .progress-bar {
      height: 100%;
      border-radius: 1rem;
      transition: width 0.5s ease;
      background-color: var(--primary); /* Default to primary */
    }
    .progress-bar.success { background-color: var(--success); }
    .progress-bar.warning { background-color: var(--warning); }
    .progress-bar.danger { background-color: var(--danger); }


    /* Gráficos */
    .charts-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(min(100%, 450px), 1fr));
      gap: 1.5rem;
      margin-bottom: 2rem;
    }

     .chart-container {
      position: relative;
      margin-top: 1rem;
      height: 280px; /* Increased height */
    }

    .chart-title {
      font-size: 1.125rem; /* 18px */
      font-weight: 600;
      letter-spacing: -0.01em;
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem; /* Reduced margin */
    }

    .chart-title-actions {
      display: flex;
      gap: 0.75rem;
    }

    .full-width {
      grid-column: 1 / -1;
    }
    .full-width .chart-container {
      height: 320px;
    }


    /* Análise Mensal */
    .analysis-header {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        align-items: center;
        margin-bottom: 1.5rem;
        padding-bottom: 1.5rem;
        border-bottom: 1px solid var(--border);
    }

    .filters {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        align-items: center;
    }

    .category-filter-group {
        display: flex;
        gap: 0.5rem;
        align-items: center;
    }

    .btn-icon-small {
        padding: 0.5rem;
        min-width: auto;
        height: auto;
        background: var(--input-bg);
        color: var(--text);
        border: none;
        border-radius: var(--radius-sm);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: var(--transition);
    }

    .btn-icon-small:hover {
        background-color: rgba(142, 142, 147, 0.2);
    }

    .btn-icon-small svg {
        width: 1rem; /* 16px */
        height: 1rem;
    }

    .btn-delete-category {
        color: var(--danger);
    }

    .analysis-indicators {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 1rem;
        margin-bottom: 2rem;
    }

     .indicator-card {
        background-color: var(--card-bg);
        border-radius: var(--radius-sm);
        padding: 1.25rem;
        text-align: center;
        box-shadow: 0 2px 6px rgba(0,0,0,0.05);
        transition: var(--transition);
    }
    .indicator-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 10px rgba(0,0,0,0.07);
    }

    .indicator-title {
        font-size: 0.875rem; /* 14px */
        color: var(--text-secondary);
        margin-bottom: 0.5rem;
    }

    .indicator-value {
        font-size: 1.5rem; /* 24px */
        font-weight: 600;
        letter-spacing: -0.01em;
        line-height: 1.2;
    }
    .indicator-value.positive { color: var(--success); }
    .indicator-value.negative { color: var(--danger); }
    .indicator-value.neutral { color: var(--text); } /* Or var(--primary) */

    .indicator-comparison {
        font-size: 0.75rem; /* 12px */
        color: var(--text-secondary);
        margin-top: 0.5rem;
    }

    .analysis-content {
        display: grid;
        grid-template-columns: 1fr 320px; /* Main content and sidebar */
        gap: 2rem;
    }

    .analysis-main {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
    }

    .analysis-sidebar {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
    }

    .insights-feed {
        background: var(--card-bg);
        border-radius: var(--radius);
        padding: 1.5rem;
        box-shadow: var(--shadow);
    }

    .insights-title {
        font-size: 1.125rem;
        font-weight: 600;
        margin-bottom: 1rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        color: var(--primary);
    }

    .insights-list {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        max-height: 400px; /* Limit height */
        overflow-y: auto;
        padding-right: 0.5rem; /* Space for scrollbar */
    }

    .insight-item {
        display: flex;
        gap: 0.75rem;
        padding: 0.75rem 1rem;
        background-color: var(--insight-bg);
        border-radius: var(--radius-sm);
        font-size: 0.875rem; /* 14px */
        align-items: flex-start;
        line-height: 1.4;
    }

    .insight-icon {
        flex-shrink: 0;
        margin-top: 2px;
        font-size: 1rem;
    }

    .insight-item.alert { color: var(--danger); background-color: rgba(255, 59, 48, 0.08); }
    .insight-item.warning { color: var(--warning); background-color: rgba(255, 149, 0, 0.08); }
    .insight-item.success { color: var(--success); background-color: rgba(52, 199, 89, 0.08); }
    .insight-item.info { color: var(--primary); background-color: rgba(0, 122, 255, 0.08); }
    .insight-item.neutral { color: var(--text-secondary); background-color: var(--input-bg); }

    /* Simple Transaction List (Análise Mensal) */
    .transaction-list-container {
      background: var(--card-bg);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 0 1.5rem 1.5rem 1.5rem; /* No top padding */
    }

    .transaction-list-title {
        font-size: 1.125rem;
        font-weight: 600;
        padding: 1.5rem 0 1rem 0;
    }

    .transaction-list {
        display: flex;
        flex-direction: column;
        gap: 0px; /* No gap, dividers handle spacing */
        max-height: 500px; /* Limit height */
        overflow-y: auto;
    }

    .transaction-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1rem 0;
        border-bottom: 1px solid var(--border);
        transition: background-color 0.15s ease;
        cursor: pointer;
    }

    .transaction-item:last-child {
        border-bottom: none;
    }

    .transaction-item:hover {
        background-color: var(--input-bg);
        margin: 0 -1.5rem; /* Extend hover background */
        padding: 1rem 1.5rem;
        border-radius: var(--radius-sm);
    }

    .transaction-item-left {
        display: flex;
        align-items: center;
        gap: 1rem;
    }

    .transaction-icon {
        width: 2.25rem; /* 36px */
        height: 2.25rem;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1rem;
        flex-shrink: 0;
        color: #fff; /* Icon color */
    }

    .transaction-info {
        display: flex;
        flex-direction: column;
    }

    .transaction-description {
        font-weight: 500;
        font-size: 0.9375rem; /* 15px */
    }

    .transaction-category {
        font-size: 0.8125rem; /* 13px */
        color: var(--text-secondary);
    }

     .transaction-item-right {
        text-align: right;
    }

    .transaction-amount {
        font-weight: 600;
        font-size: 0.9375rem;
    }
    .transaction-amount.income { color: var(--success); }
    .transaction-amount.expense { color: var(--danger); }

    .transaction-date {
        font-size: 0.8125rem; /* 13px */
        color: var(--text-secondary);
    }

    .transaction-importance {
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        margin-left: 5px;
        vertical-align: middle;
    }
    .transaction-importance.extrema { background-color: var(--importance-extrema); }
    .transaction-importance.urgente { background-color: var(--importance-urgente); }
    .transaction-importance.importante { background-color: var(--importance-importante); }


    /* Botões */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      padding: 0.75rem 1.5rem; /* More padding */
      border-radius: var(--radius-sm);
      font-weight: 600; /* Bolder */
      font-size: 0.9375rem; /* 15px */
      cursor: pointer;
      transition: var(--transition);
      border: none;
      color: #fff;
      background-color: var(--primary);
      text-decoration: none; /* For potential <a> tags */
      white-space: nowrap;
    }

    .btn:hover {
      opacity: 0.85;
      transform: translateY(-1px);
    }
    .btn:active {
        transform: translateY(0);
        opacity: 0.75;
    }

    .btn-primary { background-color: var(--primary); }
    .btn-success { background-color: var(--success); }
    .btn-warning { background-color: var(--warning); color: var(--text); } /* Ensure text contrast */
    .btn-danger { background-color: var(--danger); }
    .btn-secondary {
        background-color: var(--input-bg);
        color: var(--text);
        border: 1px solid var(--border);
    }
     .btn-secondary:hover {
        background-color: rgba(142, 142, 147, 0.2);
    }

    .btn svg {
        width: 1rem; /* 16px */
        height: 1rem;
    }

    /* Botão toggle theme */
    .theme-toggle {
      background: var(--input-bg);
      border: none;
      border-radius: 50%;
      width: 2.75rem; /* 44px */
      height: 2.75rem;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: var(--text);
      transition: var(--transition);
    }

    .theme-toggle:hover {
      background-color: rgba(142, 142, 147, 0.2);
    }

    .theme-toggle svg {
      width: 1.25rem; /* 20px */
      height: 1.25rem;
    }

    /* Select estilo Apple */
    select {
      appearance: none;
      -webkit-appearance: none;
      padding: 0.75rem 2.25rem 0.75rem 1rem; /* More padding */
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
      background: var(--card-bg) url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='14' height='8' fill='none'%3E%3Cpath fill='%238A8A8E' d='M7 8 .938 2 0 1.063 7 0l7 1.063L13.062 2 7 8Z'/%3E%3C/svg%3E") no-repeat;
      background-position: right 0.875rem center;
      color: var(--text);
      font-family: var(--font-sans);
      font-size: 0.9375rem;
      font-weight: 500;
      cursor: pointer;
      transition: var(--transition);
      min-width: 150px; /* Minimum width */
    }
    [data-theme="dark"] select {
       background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='14' height='8' fill='none'%3E%3Cpath fill='%238E8E93' d='M7 8 .938 2 0 1.063 7 0l7 1.063L13.062 2 7 8Z'/%3E%3C/svg%3E");
    }


    select:hover {
      border-color: rgba(60, 60, 67, 0.4);
    }
    select:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.15);
    }

    select option {
      background-color: var(--card-bg);
      color: var(--text);
    }


    /* Modal */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.6); /* Darker backdrop */
      backdrop-filter: blur(5px);
      display: none; /* Hidden by default, JS controls display */
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    .modal.active {
      display: flex; /* Show when active */
      opacity: 1;
      pointer-events: all;
    }

    .modal-content {
      background: var(--card-bg);
      border-radius: var(--radius-lg); /* Larger radius */
      box-shadow: 0 10px 40px rgba(0,0,0,0.2);
      width: 90%;
      max-width: 550px; /* Default max width */
      max-height: 90vh;
      overflow: hidden; /* Prevent content overflow before scroll */
      display: flex;
      flex-direction: column;
      transform: scale(0.95) translateY(10px);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease;
      opacity: 0;
    }
    .modal.active .modal-content {
        opacity: 1;
        transform: scale(1) translateY(0);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1.25rem 1.75rem;
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
    }

    .modal-title {
      font-size: 1.25rem; /* 20px */
      font-weight: 600;
      margin: 0;
    }

    .modal-close {
      background: var(--input-bg);
      border: none;
      width: 2.25rem; /* 36px */
      height: 2.25rem;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: var(--text-secondary);
      transition: var(--transition);
      flex-shrink: 0;
    }

    .modal-close:hover {
      background-color: rgba(142, 142, 147, 0.3);
      color: var(--text);
    }
    .modal-close svg { width: 1rem; height: 1rem; }

    .modal-body {
      padding: 1.75rem;
      overflow-y: auto; /* Enable scroll only for body */
      flex-grow: 1;
    }

    .modal-footer {
      padding: 1.25rem 1.75rem;
      display: flex;
      justify-content: flex-end;
      gap: 0.75rem;
      border-top: 1px solid var(--border);
      background-color: var(--bg); /* Subtle background */
      flex-shrink: 0;
    }

    /* Formulários dentro do Modal */
    .form-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 1rem;
      margin-bottom: 1rem;
    }
    .form-grid.single-col {
        grid-template-columns: 1fr;
    }


    .form-group {
      margin-bottom: 1rem;
    }

    .form-group label {
      display: block;
      margin-bottom: 0.5rem;
      font-size: 0.875rem; /* 14px */
      font-weight: 500;
      color: var(--text-secondary);
    }

    .form-control {
      width: 100%;
      padding: 0.875rem 1rem; /* Larger padding */
      font-size: 0.9375rem;
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
      background-color: var(--input-bg);
      color: var(--text);
      transition: var(--transition);
      font-family: var(--font-sans); /* Ensure consistent font */
    }

    .form-control:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.15);
      background-color: var(--card-bg); /* Change bg on focus */
    }
    textarea.form-control {
        line-height: 1.4;
        min-height: 80px;
    }

    /* Transaction Modal Specifics */
    #transaction-modal .modal-content { max-width: 500px; } /* Smaller modal */

    .input-group {
        display: flex;
        align-items: center;
    }
    .input-group .form-control {
        border-top-right-radius: 0;
        border-bottom-right-radius: 0;
        border-right: none; /* Remove border between */
    }
    .input-group-append {
        border: 1px solid var(--border);
        border-left: none;
        background-color: var(--input-bg);
        padding: 0 0.75rem;
        height: calc(1.5em + 1.75rem + 2px); /* Match input height */
        display: flex;
        align-items: center;
        border-top-right-radius: var(--radius-sm);
        border-bottom-right-radius: var(--radius-sm);
    }
     .input-group-append button {
        margin-left: 0.5rem;
     }

     #advanced-fields {
        margin-top: 1.5rem;
        padding-top: 1.5rem;
        border-top: 1px dashed var(--border);
        display: none; /* Hidden by default */
        animation: slideDown 0.3s ease-out;
     }
     #advanced-fields.visible {
        display: block;
     }

     @keyframes slideDown {
        from { opacity: 0; transform: translateY(-10px); max-height: 0; }
        to { opacity: 1; transform: translateY(0); max-height: 500px; /* Adjust as needed */ }
     }

    .btn-link {
        background: none;
        border: none;
        color: var(--primary);
        cursor: pointer;
        padding: 0;
        font-size: 0.875rem;
        font-weight: 500;
        text-align: left;
    }
    .btn-link:hover {
        text-decoration: underline;
    }

    /* Importance Radio Buttons */
    .importance-group {
        display: flex;
        gap: 0.5rem;
        margin-top: 0.5rem;
    }
    .importance-group input[type="radio"] {
        opacity: 0;
        position: fixed;
        width: 0;
    }
    .importance-group label {
        display: inline-block;
        padding: 0.5rem 1rem;
        border: 1px solid var(--border);
        border-radius: var(--radius-sm);
        cursor: pointer;
        transition: var(--transition);
        font-size: 0.875rem;
        font-weight: 500;
    }
    .importance-group input[type="radio"]:checked + label {
        background-color: var(--primary);
        color: #fff;
        border-color: var(--primary);
    }
    .importance-group input[type="radio"]:focus + label {
         box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.15);
    }
     /* Color hints for importance */
    .importance-group label[for="importance-extrema"] { border-left: 4px solid var(--importance-extrema); padding-left: calc(1rem - 4px); }
    .importance-group label[for="importance-urgente"] { border-left: 4px solid var(--importance-urgente); padding-left: calc(1rem - 4px); }
    .importance-group label[for="importance-importante"] { border-left: 4px solid var(--importance-importante); padding-left: calc(1rem - 4px); }

    .importance-group input[type="radio"]:checked + label[for="importance-extrema"] { background-color: var(--importance-extrema); border-color: var(--importance-extrema); }
    .importance-group input[type="radio"]:checked + label[for="importance-urgente"] { background-color: var(--importance-urgente); border-color: var(--importance-urgente); color: #fff;}
    .importance-group input[type="radio"]:checked + label[for="importance-importante"] { background-color: var(--importance-importante); border-color: var(--importance-importante); color: var(--text); } /* Yellow needs dark text */


    /* Category Modal Specifics */
    #category-modal .modal-content { max-width: 400px; }

    /* Confirm Modal Specifics */
    #confirm-modal .modal-content { max-width: 400px; }
    #confirm-modal-message { margin-bottom: 1rem; line-height: 1.4; }


    /* Loading Estado */
    .loading-indicator {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(3px);
      display: none; /* Hidden by default */
      align-items: center;
      justify-content: center;
      z-index: 9999;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    .loading-indicator.active {
      display: flex; /* Show when active */
      opacity: 1;
      pointer-events: all;
    }

    .spinner {
      width: 2.5rem; /* 40px */
      height: 2.5rem;
      border: 4px solid rgba(255, 255, 255, 0.2);
      border-radius: 50%;
      border-top-color: #fff;
      animation: spin 0.8s ease-in-out infinite;
    }
    [data-theme="dark"] .spinner {
        border-color: rgba(0, 0, 0, 0.2); /* Corrigido para tema escuro */
        border-top-color: #fff; /* Mantido branco para contraste no fundo escuro */
    }


    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Alertas / Toast Notifications */
    .toast-container {
        position: fixed;
        bottom: 1.5rem;
        right: 1.5rem;
        z-index: 1050;
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 0.75rem;
    }

    .toast {
        background-color: var(--card-bg);
        color: var(--text);
        padding: 0.875rem 1.25rem;
        border-radius: var(--radius-sm);
        box-shadow: var(--shadow-dropdown);
        display: flex;
        align-items: center;
        gap: 0.75rem;
        min-width: 250px;
        max-width: 400px;
        opacity: 0;
        transform: translateX(100%);
        transition: all 0.4s cubic-bezier(0.215, 0.610, 0.355, 1.000); /* EaseOutBack */
        border-left: 4px solid var(--primary); /* Default */
        pointer-events: none; /* Prevent interaction while hidden */
    }

    .toast.show {
        opacity: 1;
        transform: translateX(0);
        pointer-events: all; /* Allow interaction when shown */
    }

    .toast-icon {
        font-size: 1.25rem;
        flex-shrink: 0;
    }

    .toast.success { border-left-color: var(--success); }
    .toast.warning { border-left-color: var(--warning); }
    .toast.danger { border-left-color: var(--danger); }
    .toast.info { border-left-color: var(--primary); }


    /* Responsividade */
    @media (max-width: 1200px) {
        .analysis-content {
            grid-template-columns: 1fr; /* Stack sidebar below */
        }
        .analysis-sidebar {
            grid-row: 2; /* Move sidebar down */
        }
    }

    @media (max-width: 992px) {
      .container { padding: 1.5rem; }
      .header { flex-direction: column; align-items: flex-start; }
      .header-right { width: 100%; justify-content: space-between; }
      .charts-grid { grid-template-columns: 1fr; } /* Single column charts */
      .chart-container { height: 260px; }
      .full-width .chart-container { height: 300px; }
    }

    @media (max-width: 768px) {
      h1 { font-size: 1.625rem; } /* 26px */
      .kpis { grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); }
      .analysis-indicators { grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); }
      .btn { padding: 0.625rem 1.25rem; font-size: 0.875rem; }
      select { padding: 0.625rem 2rem 0.625rem 0.875rem; font-size: 0.875rem; }
      .form-grid { grid-template-columns: 1fr; } /* Stack form fields */
      .transaction-item { flex-direction: column; align-items: flex-start; gap: 0.25rem; }
      .transaction-item-left { width: 100%; }
      .transaction-item-right { text-align: left; margin-top: 0.25rem; width: 100%; display: flex; justify-content: space-between; }
      .modal-content { width: 95%; }
      .modal-body, .modal-header, .modal-footer { padding: 1.25rem; }
      .tabs { margin-bottom: 1.5rem; }
      .tab { padding: 0.75rem 1rem; font-size: 0.875rem; }
      .analysis-content { grid-template-columns: 1fr; } /* Ensure sidebar stacks */
      .analysis-main, .analysis-sidebar { grid-column: 1 / -1; } /* Span full width */
    }

    @media (max-width: 576px) {
        .container { padding: 1rem; }
        h1 { font-size: 1.5rem; } /* 24px */
        .kpis { grid-template-columns: 1fr; }
        .analysis-indicators { grid-template-columns: 1fr; }
        .header-right { flex-direction: column; align-items: stretch; gap: 0.75rem; }
        .filters { flex-direction: column; align-items: stretch; }
        .header-right .btn { width: 100%; }
        .theme-toggle { align-self: flex-end; }
        .importance-group { flex-wrap: wrap; } /* Allow wrapping */
        .toast-container { right: 1rem; bottom: 1rem; left: 1rem; align-items: stretch; }
        .toast { width: 100%; max-width: 100%; }
        .analysis-header { flex-direction: column; align-items: stretch; } /* Stack filters */
    }

    /* Print styles */
    @media print {
        body { background-color: #fff; color: #000; }
        .header, .tabs, .theme-toggle, .btn, .modal, .loading-indicator, .toast-container, .analysis-sidebar, .analysis-header .filters button { display: none !important; } /* Esconde filtros interativos */
        .container { max-width: 100%; padding: 0; }
        .card, .kpi-card, .indicator-card, .transaction-list-container, .insights-feed, .analysis-header {
            box-shadow: none;
            border: 1px solid #ddd;
            border-radius: 0;
            padding: 1rem;
            page-break-inside: avoid;
            background-color: #fff !important;
        }
        .analysis-header { border-bottom: 1px solid #ddd; } /* Manter divisor */
        .kpis, .charts-grid, .analysis-indicators, .analysis-content, .analysis-main { grid-template-columns: 1fr !important; gap: 1rem; }
        .analysis-content { display: block; } /* Remove grid layout for print */
        .analysis-main { margin-bottom: 1rem; }
        canvas { max-width: 100%; }
        select { border: none; appearance: none; -webkit-appearance: none; padding-right: 1rem; background: none; font-weight: bold; } /* Mostrar seleção atual */
        .transaction-item { border-bottom: 1px solid #eee; }
        .transaction-item:hover { background-color: transparent; margin: 0; padding: 1rem 0; border-radius: 0; }
        :root { /* Override colors for print */
            --text: #000;
            --text-secondary: #555;
            --success: #008000;
            --danger: #D00000;
            --primary: #0000FF;
            --warning: #FFA500;
        }
        .indicator-value.positive, .kpi-trend.up, .transaction-amount.income { color: var(--success) !important; }
        .indicator-value.negative, .kpi-trend.down, .transaction-amount.expense { color: var(--danger) !important; }
        .progress-bar { background-color: #ccc !important; } /* Simple progress bar */
    }

  </style>
</head>
<body>
  <div class="container">
    <!-- Header -->
    <div class="header">
      <div class="header-title">
        <h1>Calculadora Financeira</h1>
      </div>
      <div class="header-right">
        <button class="btn btn-primary" id="btn-new-transaction">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                <path d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"/>
              </svg>
          Nova Transação
        </button>
        <button class="theme-toggle" id="theme-toggle" aria-label="Alternar Tema">
            <svg id="theme-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
                <path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"/>
            </svg>
        </button>
      </div>
    </div>

    <!-- Tabs de Navegação -->
    <div class="tabs">
      <div class="tab active" data-tab="overview">Visão Geral</div>
      <div class="tab" data-tab="analysis">Análise Mensal</div>
    </div>

    <!-- Conteúdo das Tabs -->
    <div id="tab-contents">
        <!-- Aba Visão Geral -->
        <div class="tab-content active" id="tab-overview">
            <!-- KPIs -->
            <div class="kpis">
                <div class="card kpi-card">
                    <div class="kpi-header">
                        <div class="kpi-title">Saldo Atual</div>
                        <svg class="kpi-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
                            <path d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zM1 8a7 7 0 1 1 14 0A7 7 0 0 1 1 8z"/>
                            <path d="M8 4a.5.5 0 0 1 .5.5v3.793l2.146 2.147a.5.5 0 0 1-.708.708l-2.5-2.5A.5.5 0 0 1 7.5 8V4.5A.5.5 0 0 1 8 4z"/>
                        </svg>
                    </div>
                    <div class="kpi-value" id="kpi-balance">R$ 0,00</div>
                    <div class="kpi-footer">
                        <div class="kpi-trend neutral" id="balance-trend-indicator">
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
                                <path fill-rule="evenodd" d="M1 8a.5.5 0 0 1 .5-.5h13a.5.5 0 0 1 0 1h-13A.5.5 0 0 1 1 8z"/>
                            </svg>
                            <span id="balance-trend">--%</span>
                        </div>
                        <span>vs. mês anterior</span>
                    </div>
                </div>

                <div class="card kpi-card">
                    <div class="kpi-header">
                        <div class="kpi-title">Receitas (Mês)</div>
                         <svg class="kpi-icon" style="color: var(--success);" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
                            <path fill-rule="evenodd" d="M8 15a.5.5 0 0 0 .5-.5V2.707l3.146 3.147a.5.5 0 0 0 .708-.708l-4-4a.5.5 0 0 0-.708 0l-4 4a.5.5 0 1 0 .708.708L7.5 2.707V14.5a.5.5 0 0 0 .5.5z"/>
                        </svg>
                    </div>
                    <div class="kpi-value" style="color: var(--success);" id="kpi-income">R$ 0,00</div>
                    <div class="kpi-footer">
                        <div class="kpi-trend neutral" id="income-trend-indicator">
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
                                <path fill-rule="evenodd" d="M1 8a.5.5 0 0 1 .5-.5h13a.5.5 0 0 1 0 1h-13A.5.5 0 0 1 1 8z"/>
                             </svg>
                            <span id="income-trend">--%</span>
                        </div>
                        <span>vs. mês anterior</span>
                    </div>
                </div>

                <div class="card kpi-card">
                    <div class="kpi-header">
                        <div class="kpi-title">Despesas (Mês)</div>
                         <svg class="kpi-icon" style="color: var(--danger);" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
                            <path fill-rule="evenodd" d="M8 1a.5.5 0 0 1 .5.5v11.793l3.146-3.147a.5.5 0 0 1 .708.708l-4 4a.5.5 0 0 1-.708 0l-4-4a.5.5 0 0 1 .708-.708L7.5 13.293V1.5A.5.5 0 0 1 8 1z"/>
                        </svg>
                    </div>
                    <div class="kpi-value" style="color: var(--danger);" id="kpi-expenses">R$ 0,00</div>
                    <div class="kpi-footer">
                        <div class="kpi-trend neutral" id="expenses-trend-indicator">
                             <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
                                <path fill-rule="evenodd" d="M1 8a.5.5 0 0 1 .5-.5h13a.5.5 0 0 1 0 1h-13A.5.5 0 0 1 1 8z"/>
                             </svg>
                            <span id="expenses-trend">--%</span>
                        </div>
                        <span>vs. mês anterior</span>
                    </div>
                </div>

                <div class="card kpi-card">
                    <div class="kpi-header">
                        <div class="kpi-title">Economia do Mês</div>
                        <svg class="kpi-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
                            <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zm-7.5 3.5a.5.5 0 0 0 1 0V5.707l2.146 2.147a.5.5 0 0 0 .708-.708l-3-3a.5.5 0 0 0-.708 0l-3 3a.5.5 0 1 0 .708.708L7.5 5.707V11.5z"/>
                        </svg>
                    </div>
                    <div class="kpi-value" id="kpi-savings">R$ 0,00</div>
                    <div class="kpi-footer">
                        <span id="savings-status">Calculando...</span>
                    </div>
                     <div class="progress-container">
                        <div class="progress-bar" id="savings-progress" style="width: 0%"></div>
                    </div>
                </div>

                <div class="card kpi-card">
                    <div class="kpi-header">
                        <div class="kpi-title">Projeção de Gastos (Mês)</div>
                         <svg class="kpi-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
                            <path d="M3.5 0a.5.5 0 0 1 .5.5V1h8V.5a.5.5 0 0 1 1 0V1h1a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h1V.5a.5.5 0 0 1 .5-.5zM1 4v10a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V4H1z"/>
                        </svg>
                    </div>
                    <div class="kpi-value" id="kpi-projection">R$ 0,00</div>
                    <div class="kpi-footer">
                         <span id="projection-status">--</span>
                    </div>
                </div>
            </div>

            <!-- Gráficos de Visão Geral -->
            <div class="charts-grid">
                <div class="card">
                    <div class="chart-title">
                        <span>Receitas vs Despesas (Últimos 12 Meses)</span>
                    </div>
                    <div class="chart-container">
                        <canvas id="overview-income-expense-chart"></canvas>
                    </div>
                </div>

                <div class="card">
                    <div class="chart-title">
                        <span>Despesas por Categoria (Últimos 30 dias)</span>
                    </div>
                    <div class="chart-container">
                        <canvas id="overview-category-chart"></canvas>
                    </div>
                </div>

                <div class="card full-width">
                    <div class="chart-title">
                        <span>Fluxo de Caixa Mensal (Ano Atual)</span>
                    </div>
                    <div class="chart-container">
                        <canvas id="overview-cashflow-chart"></canvas>
                    </div>
                </div>

                 <div class="card">
                    <div class="chart-title">
                        <span>Fixas vs Variáveis (Mês Atual)</span>
                    </div>
                    <div class="chart-container">
                        <canvas id="overview-fixed-variable-chart"></canvas>
                    </div>
                </div>

                <div class="card">
                    <div class="chart-title">
                        <span>Tendência Geral de Gastos (Últimos 6 Meses)</span>
                    </div>
                    <div class="chart-container">
                        <canvas id="overview-trend-chart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- Aba Análise Mensal -->
        <div class="tab-content" id="tab-analysis">
            <!-- Filtros Inteligentes -->
            <div class="analysis-header">
                 <div class="filters">
                    <div class="form-group" style="margin-bottom: 0;">
                        <label for="analysis-month-year" style="margin-bottom: 0.25rem;">Mês de Análise</label>
                        <select id="analysis-month-year"></select>
                    </div>
                    <div class="form-group" style="margin-bottom: 0;">
                         <label for="analysis-category" style="margin-bottom: 0.25rem;">Filtrar Categoria</label>
                         <div class="category-filter-group">
                            <select id="analysis-category">
                                <option value="all">Todas as Categorias</option>
                                <!-- Categorias carregadas via JS -->
                            </select>
                            <button class="btn-icon-small" id="btn-add-category" title="Nova Categoria">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                    <path d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"/>
                                </svg>
                            </button>
                            <button class="btn-icon-small btn-delete-category" id="btn-delete-category" title="Excluir Categoria Selecionada" style="display: none;">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                    <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/>
                                    <path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Indicadores e Inteligência Mensal -->
            <div class="analysis-indicators">
                <div class="indicator-card">
                    <div class="indicator-title">Receitas Totais</div>
                    <div class="indicator-value positive" id="analysis-total-income">R$ 0,00</div>
                    <div class="indicator-comparison" id="analysis-income-comparison">-- vs mês anterior</div>
                </div>
                 <div class="indicator-card">
                    <div class="indicator-title">Despesas Totais</div>
                    <div class="indicator-value negative" id="analysis-total-expenses">R$ 0,00</div>
                    <div class="indicator-comparison" id="analysis-expense-comparison">-- vs mês anterior</div>
                </div>
                <div class="indicator-card">
                    <div class="indicator-title">Saldo Final</div>
                    <div class="indicator-value neutral" id="analysis-final-balance">R$ 0,00</div>
                     <div class="indicator-comparison" id="analysis-balance-comparison">-- vs mês anterior</div>
                </div>
                <div class="indicator-card">
                    <div class="indicator-title">Status do Mês</div>
                    <div class="indicator-value neutral" id="analysis-month-status">--</div>
                    <div class="indicator-comparison" id="analysis-days-left">-- dias restantes</div>
                </div>
                 <div class="indicator-card">
                    <div class="indicator-title">Maior Gasto</div>
                    <div class="indicator-value neutral" id="analysis-top-category">--</div>
                    <div class="indicator-comparison" id="analysis-top-category-value">R$ 0,00</div>
                </div>
            </div>

             <!-- Conteúdo Principal e Sidebar -->
            <div class="analysis-content">
                <!-- Conteúdo Principal (Gráficos e Lista) -->
                <div class="analysis-main">
                     <!-- Gráficos da Análise Mensal -->
                    <div class="charts-grid">
                        <div class="card">
                            <div class="chart-title">Distribuição de Despesas</div>
                            <div class="chart-container">
                                <canvas id="analysis-category-pie-chart"></canvas>
                            </div>
                        </div>
                        <div class="card">
                            <div class="chart-title">Evolução do Saldo no Mês</div>
                            <div class="chart-container">
                                <canvas id="analysis-balance-line-chart"></canvas>
                            </div>
                        </div>
                    </div>
                    <!-- Lista Simples de Transações -->
                    <div class="transaction-list-container">
                        <div class="transaction-list-title">Transações do Mês</div>
                        <div id="analysis-transaction-list" class="transaction-list">
                            <!-- Transações carregadas via JS -->
                            <div style="text-align: center; padding: 2rem 0; color: var(--text-secondary); display: none;" id="analysis-no-transactions">
                                Nenhuma transação encontrada para este período/categoria.
                            </div>
                        </div>
                    </div>
                </div>
                <!-- Sidebar (Insights) -->
                <aside class="analysis-sidebar">
                    <div class="insights-feed card">
                        <div class="insights-title">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
                                <path d="M16 8a8 8 0 1 1-16 0 8 8 0 0 1 16 0zM8 4.002a.5.5 0 0 0-.495.57l.5 4a.5.5 0 0 0 .99 0l.5-4A.5.5 0 0 0 8 4.002zm-.002 7a.5.5 0 1 0 0 1 .5.5 0 0 0 0-1z"/>
                              </svg>
                            Insights Rápidos
                        </div>
                        <div class="insights-list" id="analysis-insights-list">
                            <!-- Insights carregados via JS -->
                            <div style="text-align: center; padding: 2rem 0; color: var(--text-secondary);" id="analysis-no-insights">
                                Analisando seus dados...
                            </div>
                        </div>
                    </div>
                </aside>
            </div>
        </div>
    </div> <!-- Fim #tab-contents -->
  </div> <!-- Fim .container -->

  <!-- Modal de Nova Transação (Ultra Otimizado) -->
  <div class="modal" id="transaction-modal">
    <div class="modal-content">
        <form id="transaction-form">
            <input type="hidden" id="transaction-id">
            <input type="hidden" id="transaction-recurring-base-id"> <!-- Para saber se é edição de recorrente -->
            <div class="modal-header">
                <h3 class="modal-title" id="transaction-modal-title">Nova Transação</h3>
                <button type="button" class="modal-close" id="transaction-modal-close" data-dismiss="modal"> <!-- Adicionado data-dismiss -->
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z"/>
                    </svg>
                </button>
            </div>
            <div class="modal-body">
                <!-- Campos Essenciais -->
                <div class="form-group">
                    <label for="transaction-amount">Valor (R$)</label>
                    <input type="number" step="0.01" min="0.01" class="form-control" id="transaction-amount" placeholder="0,00" required>
                </div>

                <div class="form-group">
                     <label for="transaction-category">Categoria</label>
                     <div class="input-group">
                        <select class="form-control" id="transaction-category" required>
                            <!-- Categorias carregadas via JS -->
                        </select>
                        <div class="input-group-append">
                            <button type="button" class="btn-icon-small" id="btn-add-category-modal" title="Nova Categoria">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                    <path d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"/>
                                </svg>
                            </button>
                         </div>
                    </div>
                </div>

                <div class="form-grid">
                    <div class="form-group">
                        <label for="transaction-date">Data</label>
                        <input type="date" class="form-control" id="transaction-date" required>
                    </div>
                     <div class="form-group">
                        <label for="transaction-type">Tipo</label>
                        <select class="form-control" id="transaction-type" required>
                            <option value="expense" selected>Despesa</option>
                            <option value="income">Receita</option>
                        </select>
                    </div>
                </div>

                <div class="form-group">
                    <label>Importância</label>
                    <div class="importance-group">
                        <input type="radio" id="importance-extrema" name="transaction-importance" value="extrema">
                        <label for="importance-extrema">Extrema</label>

                        <input type="radio" id="importance-urgente" name="transaction-importance" value="urgente">
                        <label for="importance-urgente">Urgente</label>

                        <input type="radio" id="importance-importante" name="transaction-importance" value="importante">
                        <label for="importance-importante">Importante</label>
                    </div>
                </div>

                 <button type="button" class="btn-link" id="btn-toggle-advanced" style="margin-top: 1rem;">
                    Mostrar opções avançadas
                    <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" viewBox="0 0 16 16" style="vertical-align: middle; margin-left: 4px;">
                        <path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
                      </svg>
                 </button>

                <!-- Campos Avançados (Ocultos por padrão) -->
                <div id="advanced-fields">
                    <div class="form-group">
                        <label for="transaction-description">Descrição <small>(Opcional)</small></label>
                        <input type="text" class="form-control" id="transaction-description" placeholder="Ex: Supermercado da semana, Salário...">
                    </div>

                    <div class="form-grid">
                        <div class="form-group">
                            <label for="transaction-status">Status</label>
                            <select class="form-control" id="transaction-status" required>
                                <option value="paid" selected>Pago</option>
                                <option value="pending">Pendente</option>
                                <option value="scheduled">Agendado</option>
                            </select>
                        </div>
                         <div class="form-group">
                            <label for="transaction-payment-method">Forma de Pagamento</label>
                            <select class="form-control" id="transaction-payment-method">
                                <option value="">Nenhuma</option>
                                <option value="cash">Dinheiro</option>
                                <option value="credit_card">Cartão de Crédito</option>
                                <option value="debit_card">Cartão de Débito</option>
                                <option value="bank_transfer">Transferência</option>
                                <option value="pix">PIX</option>
                                <option value="boleto">Boleto</option>
                                <option value="other">Outro</option>
                            </select>
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="transaction-notes">Observações</label>
                        <textarea class="form-control" id="transaction-notes" rows="3" placeholder="Ex: Parcela 2/12, Referente ao projeto X..."></textarea>
                    </div>

                    <!-- Recorrência -->
                    <div id="recurring-transaction-container">
                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 1rem;">
                          <input type="checkbox" id="transaction-recurring" style="width: auto; height: auto; transform: scale(1.2);">
                          <label for="transaction-recurring" style="margin-bottom: 0; font-weight: 500;">É uma transação recorrente? (Ex: Aluguel, Parcela)</label>
                        </div>

                        <div id="recurring-options" style="display: none;">
                          <div class="form-grid">
                            <div class="form-group">
                              <label for="transaction-frequency">Frequência</label>
                              <select class="form-control" id="transaction-frequency">
                                <option value="daily">Diária</option>
                                <option value="weekly">Semanal</option>
                                <option value="biweekly">Quinzenal</option>
                                <option value="monthly" selected>Mensal</option>
                                <option value="bimonthly">Bimestral</option>
                                <option value="quarterly">Trimestral</option>
                                <option value="semiannual">Semestral</option>
                                <option value="annual">Anual</option>
                              </select>
                            </div>
                            <div class="form-group">
                              <label for="transaction-installments">Número de Parcelas</label>
                              <input type="number" min="2" step="1" class="form-control" id="transaction-installments" placeholder="Ex: 12">
                              <small style="color: var(--text-secondary); font-size: 0.75rem;">Deixe em branco se for contínuo (sem fim).</small>
                            </div>
                          </div>
                           <div id="edit-recurring-options" style="margin-top:1rem; padding: 1rem; background-color: var(--input-bg); border-radius: var(--radius-sm); display: none;">
                                <p style="font-weight: 500; margin-bottom: 0.5rem;">Editando transação recorrente:</p>
                                <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                                    <label style="font-size: 0.875rem;">
                                        <input type="radio" name="edit-recurring-scope" value="this" checked> Aplicar somente a esta ocorrência
                                    </label>
                                    <label style="font-size: 0.875rem;">
                                        <input type="radio" name="edit-recurring-scope" value="future"> Aplicar a esta e futuras ocorrências
                                    </label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div> <!-- Fim #advanced-fields -->
            </div> <!-- Fim .modal-body -->

            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" id="transaction-modal-cancel" data-dismiss="modal">Cancelar</button> <!-- Adicionado data-dismiss -->
                <button type="submit" class="btn btn-primary" id="transaction-modal-save">Salvar Transação</button>
            </div>
        </form>
    </div>
</div>


  <!-- Modal de Nova Categoria -->
  <div class="modal" id="category-modal">
    <div class="modal-content">
         <form id="category-form">
            <div class="modal-header">
                <h3 class="modal-title" id="category-modal-title">Nova Categoria</h3>
                <button type="button" class="modal-close" data-dismiss="modal">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z"/>
                    </svg>
                </button>
            </div>
            <div class="modal-body">
                 <div class="form-group">
                    <label for="category-name">Nome da Nova Categoria</label>
                    <input type="text" class="form-control" id="category-name" placeholder="Ex: Assinaturas, Educação Filhos" required>
                </div>
                <div class="form-group">
                    <label for="category-type">Tipo de Categoria</label>
                    <select class="form-control" id="category-type" required>
                        <option value="expense" selected>Despesa</option>
                        <option value="income">Receita</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="category-icon">Ícone (Emoji)</label>
                    <input type="text" class="form-control" id="category-icon" placeholder="Ex: 🎓,  assinatura  assinatura" maxlength="2">
                </div>
                 <div class="form-group">
                    <label for="category-color">Cor</label>
                    <input type="color" class="form-control" id="category-color" value="#8A8A8E"> <!-- Default Grey -->
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Cancelar</button>
                <button type="submit" class="btn btn-primary" id="category-modal-save">Salvar Categoria</button>
            </div>
        </form>
    </div>
  </div>

  <!-- Modal de Confirmação -->
  <div class="modal" id="confirm-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3 class="modal-title" id="confirm-modal-title">Confirmação</h3>
         <button type="button" class="modal-close" data-dismiss="modal">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                <path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z"/>
            </svg>
        </button>
      </div>
      <div class="modal-body">
        <p id="confirm-modal-message">Tem certeza que deseja realizar esta ação?</p>
        <div id="confirm-modal-extra-info" style="margin-top: 1rem; font-size: 0.875rem; color: var(--text-secondary);"></div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-dismiss="modal">Cancelar</button>
        <button type="button" class="btn btn-danger" id="confirm-modal-confirm">Confirmar</button>
      </div>
    </div>
  </div>

  <!-- Loading Indicator -->
  <div class="loading-indicator" id="loading">
    <div class="spinner"></div>
  </div>

  <!-- Toast Notification Container -->
  <div class="toast-container" id="toast-container"></div>

  <script>
    // ===== Configurações Globais e Firebase =====
    const root = document.documentElement;
    const loading = document.getElementById('loading');
    moment.locale('pt-br'); // Definir Moment.js para português

    // Configuração Firebase (Substitua pelos seus dados reais se necessário, mas estes são os que você forneceu)
    const firebaseConfig = {
        apiKey: "AIzaSyDvL_nYWhy_8rPouejiWbDZtDCKHYOQyEY", // Use aspas aqui
        authDomain: "calculadora-da-familia.firebaseapp.com",
        projectId: "calculadora-da-familia",
        storageBucket: "calculadora-da-familia.appspot.com",
        messagingSenderId: "69721783786",
        appId: "1:69721783786:web:c4703b5c182e3681e8c693",
        measurementId: "G-YM5TR661S6"
    };

    // Inicializar Firebase
    let app;
    let db;
    try {
        // Verifica se o Firebase já foi inicializado para evitar erros de recarregamento (hot reload)
        if (!firebase.apps.length) {
            app = firebase.initializeApp(firebaseConfig);
        } else {
            app = firebase.app(); // Pega a instância existente
        }
        db = firebase.firestore();
        console.log("Firebase inicializado com sucesso!");
    } catch (error) {
        console.error("Erro ao inicializar Firebase:", error);
        showToast("Erro crítico ao conectar com o banco de dados. A aplicação pode não funcionar corretamente.", "danger", 10000);
        // É importante não tentar usar 'db' se a inicialização falhar
        db = null; // Define db como null para que outras partes do código possam verificar
    }

    // Coleções Firestore (Verifica se 'db' foi inicializado)
    const transactionsCollection = db ? db.collection('transactions') : null;
    const categoriesCollection = db ? db.collection('categories') : null;

    // ===== Estados da Aplicação =====
    let transactions = []; // Array local para manipulação e exibição, sincronizado com Firestore
    let categories = [];   // Array local para manipulação e exibição, sincronizado com Firestore
    let currentTab = 'overview';
    let currentAnalysisMonthYear = moment().format('YYYY-MM'); // Mês atual por padrão
    let currentAnalysisCategory = 'all';
    let unsubscribeTransactions = null; // Para desligar o listener do Firestore
    let unsubscribeCategories = null;   // Para desligar o listener do Firestore
    let overviewCharts = {}; // Armazena instâncias dos gráficos de Overview
    let analysisCharts = {}; // Armazena instâncias dos gráficos de Análise

    // ===== Constantes e Mapas =====
    const TRANSACTION_TYPES = {
      income: { name: 'Receita', icon: '💰', colorClass: 'positive' },
      expense: { name: 'Despesa', icon: '💸', colorClass: 'negative' }
    };

    const PAYMENT_METHODS = {
      'cash': 'Dinheiro', 'credit_card': 'Cartão de Crédito', 'debit_card': 'Cartão de Débito',
      'bank_transfer': 'Transferência', 'pix': 'PIX', 'boleto': 'Boleto', 'other': 'Outro'
    };

    const TRANSACTION_STATUS = {
      'paid': { name: 'Pago', class: 'status-paid' },
      'pending': { name: 'Pendente', class: 'status-pending' },
      'scheduled': { name: 'Agendado', class: 'status-scheduled' }
    };

     const RECURRENCE_FREQUENCY = {
        'daily': { name: 'Diária', momentUnit: 'days', momentStep: 1 },
        'weekly': { name: 'Semanal', momentUnit: 'weeks', momentStep: 1 },
        'biweekly': { name: 'Quinzenal', momentUnit: 'weeks', momentStep: 2 },
        'monthly': { name: 'Mensal', momentUnit: 'months', momentStep: 1 },
        'bimonthly': { name: 'Bimestral', momentUnit: 'months', momentStep: 2 },
        'quarterly': { name: 'Trimestral', momentUnit: 'months', momentStep: 3 },
        'semiannual': { name: 'Semestral', momentUnit: 'months', momentStep: 6 },
        'annual': { name: 'Anual', momentUnit: 'years', momentStep: 1 }
    };

    const DEFAULT_EXPENSE_CATEGORIES = [
      { id: 'moradia', name: 'Moradia', type: 'expense', color: '#FF9500', icon: '🏠', isDefault: true },
      { id: 'alimentacao', name: 'Alimentação', type: 'expense', color: '#34C759', icon: '🍔', isDefault: true },
      { id: 'transporte', name: 'Transporte', type: 'expense', color: '#007AFF', icon: '🚗', isDefault: true },
      { id: 'contas', name: 'Contas Fixas', type: 'expense', color: '#5AC8FA', icon: '💡', isDefault: true },
      { id: 'lazer', name: 'Lazer', type: 'expense', color: '#AF52DE', icon: '🎮', isDefault: true },
      { id: 'saude', name: 'Saúde', type: 'expense', color: '#FF3B30', icon: '🏥', isDefault: true },
      { id: 'compras', name: 'Compras', type: 'expense', color: '#FFCC00', icon: '🛍️', isDefault: true },
      { id: 'educacao', name: 'Educação', type: 'expense', color: '#5856D6', icon: '📚', isDefault: true },
      { id: 'outros_despesas', name: 'Outras Despesas', type: 'expense', color: '#8E8E93', icon: '📋', isDefault: true }
    ];

    const DEFAULT_INCOME_CATEGORIES = [
      { id: 'salario', name: 'Salário', type: 'income', color: '#34C759', icon: '💰', isDefault: true },
      { id: 'freelance', name: 'Freelance/Extra', type: 'income', color: '#007AFF', icon: '💼', isDefault: true },
      { id: 'investimentos', name: 'Investimentos', type: 'income', color: '#AF52DE', icon: '📈', isDefault: true },
      { id: 'outros_receitas', name: 'Outras Receitas', type: 'income', color: '#8E8E93', icon: '💸', isDefault: true }
    ];

    // ===== Utilitários =====

    // Formatar moeda
    const formatCurrency = (value) => {
        if (typeof value !== 'number' || isNaN(value)) {
            return 'R$ 0,00'; // Retorna valor padrão se inválido
        }
        return value.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' });
    }

    // Formatar data (DD/MM/YYYY)
    const formatDate = (dateString) => dateString ? moment(dateString).format('DD/MM/YYYY') : '--';

    // Formatar data para input (YYYY-MM-DD)
    const formatDateForInput = (date = new Date()) => moment(date).format('YYYY-MM-DD');

    // Mostrar/Esconder Loading
    const showLoading = () => loading.classList.add('active');
    const hideLoading = () => loading.classList.remove('active');

    // Mostrar Toast Notification
    function showToast(message, type = 'info', duration = 3000) {
        const toastContainer = document.getElementById('toast-container');
        if (!toastContainer) return;

        const toastId = `toast-${Date.now()}`;
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.id = toastId;

        let icon = 'ℹ️';
        if (type === 'success') icon = '✅';
        if (type === 'warning') icon = '⚠️';
        if (type === 'danger') icon = '❌';

        toast.innerHTML = `
            <span class="toast-icon">${icon}</span>
            <span class="toast-message">${message}</span>
        `;

        toastContainer.appendChild(toast);

        // Trigger animation
        setTimeout(() => {
            toast.classList.add('show');
        }, 10); // Small delay to allow CSS transition

        // Remove toast after duration
        const timeoutId = setTimeout(() => {
            toast.classList.remove('show');
            // Remove element after transition ends
            const removeElement = () => {
                 if(toast.parentNode) {
                     toast.removeEventListener('transitionend', removeElement);
                     toast.parentNode.removeChild(toast);
                 }
                 // Clear failsafe timeout if transitionend fired
                 clearTimeout(failsafeTimeoutId);
            };
             const failsafeTimeoutId = setTimeout(removeElement, 500); // Failsafe (match transition duration)
            toast.addEventListener('transitionend', removeElement);
        }, duration);
    }

    // Atualizar ícone do tema
    function updateThemeIcon(theme) {
        const themeIcon = document.getElementById('theme-icon');
        if (!themeIcon) return; // Verifica se o elemento existe
        if (theme === 'dark') {
            // Sun icon
             themeIcon.innerHTML = `<path d="M8 11a3 3 0 1 1 0-6 3 3 0 0 1 0 6zm0 1a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.708l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707z"/>`;
        } else {
            // Moon icon
             themeIcon.innerHTML = `<path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"/>`;
        }
    }

    // Configurar tema inicial
    function setupTheme() {
      const savedTheme = localStorage.getItem('theme');
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      const theme = savedTheme || (prefersDark ? 'dark' : 'light');
      root.setAttribute('data-theme', theme);
      updateThemeIcon(theme);
    }

    // Alternar tema
    function toggleTheme() {
        const currentTheme = root.getAttribute('data-theme');
        const newTheme = currentTheme === 'light' ? 'dark' : 'light';
        root.setAttribute('data-theme', newTheme);
        localStorage.setItem('theme', newTheme);
        updateThemeIcon(newTheme);
        updateAllChartsTheme(); // Atualiza cores dos gráficos
    }

    // ===== Gerenciamento de Dados (Firestore) =====

    // Carregar categorias do Firestore e garantir padrões
    async function loadCategories() {
        if (!categoriesCollection) {
             console.error("Coleção de Categorias não inicializada.");
             showToast("Erro: Não foi possível conectar à base de dados de categorias.", "danger");
             // Usar padrões locais como fallback
             categories = [...DEFAULT_INCOME_CATEGORIES, ...DEFAULT_EXPENSE_CATEGORIES].sort((a, b) => a.name.localeCompare(b.name));
             populateCategoryFilters();
             return;
        }

        return new Promise(async (resolve, reject) => {
            try {
                const snapshot = await categoriesCollection.get();
                let loadedCategories = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                // Se vazio, adiciona categorias padrão
                if (loadedCategories.length === 0 && db) { // Verifica db para poder usar batch
                    console.log("Nenhuma categoria encontrada, adicionando padrões...");
                    const batch = db.batch();
                    const defaultCategories = [...DEFAULT_INCOME_CATEGORIES, ...DEFAULT_EXPENSE_CATEGORIES];
                    defaultCategories.forEach(cat => {
                        const docRef = categoriesCollection.doc(cat.id); // Use ID padrão como doc ID
                        batch.set(docRef, cat);
                    });
                    await batch.commit();
                    console.log("Categorias padrão adicionadas.");
                    loadedCategories = defaultCategories; // Usa as padrões agora
                }

                categories = loadedCategories.sort((a, b) => a.name.localeCompare(b.name));
                populateCategoryFilters();
                resolve();

            } catch (error) {
                console.error("Erro ao carregar/garantir categorias:", error);
                showToast("Erro ao carregar categorias.", "danger");
                // Tenta usar as padrões locais como fallback extremo
                categories = [...DEFAULT_INCOME_CATEGORIES, ...DEFAULT_EXPENSE_CATEGORIES].sort((a, b) => a.name.localeCompare(b.name));
                populateCategoryFilters();
                reject(error);
            }
        });
    }


    // Adicionar nova categoria
    async function addCategory(name, type, icon, color) {
        if (!categoriesCollection) {
             showToast("Erro: Não é possível adicionar categoria (sem conexão).", "danger");
             return false;
        }
        showLoading();
        try {
            const newCategory = {
                name: name.trim(),
                type: type,
                icon: icon || (type === 'income' ? '💰' : '💸'), // Default icons
                color: color || '#8E8E93', // Default color
                isDefault: false // Marcar como não padrão
            };
            // Gera um ID automático se não quiser usar nome como ID
            const docRef = await categoriesCollection.add(newCategory);
            console.log("Categoria adicionada com ID: ", docRef.id);
            showToast("Categoria adicionada com sucesso!", "success");
            // O listener onSnapshot atualizará a UI (se ativo)
            return true;
        } catch (error) {
            console.error("Erro ao adicionar categoria: ", error);
            showToast("Erro ao salvar categoria. Tente novamente.", "danger");
            return false;
        } finally {
            hideLoading();
        }
    }

    // Excluir categoria (com verificação de transações)
    async function deleteCategory(categoryId) {
         if (!categoriesCollection || !transactionsCollection) {
             showToast("Erro: Não é possível excluir categoria (sem conexão).", "danger");
             return false;
         }
        showLoading();
        try {
             // 1. Verificar se a categoria é padrão (não permitir exclusão)
            const categoryToDelete = categories.find(c => c.id === categoryId);
            if (categoryToDelete?.isDefault) {
                showToast("Não é possível excluir categorias padrão.", "warning");
                hideLoading();
                return false;
            }

            // 2. Verificar se existem transações usando esta categoria
            const querySnapshot = await transactionsCollection.where('category', '==', categoryId).limit(1).get();

            if (!querySnapshot.empty) {
                 showToast("Não é possível excluir. Existem transações associadas a esta categoria.", "warning", 5000);
                 hideLoading();
                 return false;
            }

            // 3. Se não houver transações, excluir a categoria
            await categoriesCollection.doc(categoryId).delete();
            console.log("Categoria excluída: ", categoryId);
            showToast("Categoria excluída com sucesso!", "success");
             // O listener onSnapshot atualizará a UI (se ativo)
            return true;

        } catch (error) {
            console.error("Erro ao excluir categoria: ", error);
            showToast("Erro ao excluir categoria. Tente novamente.", "danger");
            return false;
        } finally {
            hideLoading();
        }
    }


    // Carregar transações (chamado pelo listener)
    function processTransactionSnapshot(snapshot) {
        transactions = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        // Adiciona validação para garantir que date existe antes de ordenar
        transactions.sort((a, b) => {
            const dateA = a.date ? moment(a.date) : moment(0); // Data mínima se ausente
            const dateB = b.date ? moment(b.date) : moment(0);
            return dateB.diff(dateA); // Mais recentes primeiro
        });
        console.log(`Transações atualizadas: ${transactions.length} encontradas.`);
        updateDashboard(); // Atualiza toda a UI que depende das transações
    }

     // Carregar categorias (chamado pelo listener)
    function processCategorySnapshot(snapshot) {
        let loadedCategories = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        categories = loadedCategories.sort((a, b) => a.name.localeCompare(b.name));
        console.log(`Categorias atualizadas: ${categories.length} encontradas.`);
        populateCategoryFilters();
         // Se a aba de análise estiver ativa, atualiza-a, pois as categorias podem ter mudado
         if (currentTab === 'analysis') {
            updateMonthlyAnalysis();
         }
         // Atualiza também o overview caso algum gráfico dependa diretamente da lista de categorias
         updateOverviewCharts();
    }

    // Configurar listeners do Firestore
    function setupFirestoreListeners() {
        // Limpa listeners antigos antes de criar novos
        if (unsubscribeTransactions) {
            unsubscribeTransactions();
            unsubscribeTransactions = null;
        }
        if (unsubscribeCategories) {
            unsubscribeCategories();
            unsubscribeCategories = null;
        }


        // Listener para transações (Somente se a coleção foi inicializada)
        if (transactionsCollection) {
            unsubscribeTransactions = transactionsCollection.onSnapshot(
                processTransactionSnapshot,
                (error) => {
                    console.error("Erro no listener de transações:", error);
                    showToast("Erro ao sincronizar transações.", "danger");
                    transactions = []; // Limpa dados locais em caso de erro persistente
                    updateDashboard(); // Atualiza UI para estado vazio/erro
                }
            );
        } else {
             console.warn("Listener de Transações não iniciado - coleção não disponível.");
             // Poderia carregar dados de exemplo ou mostrar mensagem
        }

        // Listener para categorias (Somente se a coleção foi inicializada)
         if (categoriesCollection) {
             unsubscribeCategories = categoriesCollection.onSnapshot(
                processCategorySnapshot,
                (error) => {
                    console.error("Erro no listener de categorias:", error);
                    showToast("Erro ao sincronizar categorias.", "danger");
                     // Usa padrões como fallback se o listener falhar após carregamento inicial
                    if(categories.length === 0) {
                         categories = [...DEFAULT_INCOME_CATEGORIES, ...DEFAULT_EXPENSE_CATEGORIES].sort((a, b) => a.name.localeCompare(b.name));
                         populateCategoryFilters();
                    }
                }
            );
         } else {
              console.warn("Listener de Categorias não iniciado - coleção não disponível.");
         }
    }

    // Parar listeners do Firestore (Ex: ao sair da página)
    function stopFirestoreListeners() {
        if (unsubscribeTransactions) unsubscribeTransactions();
        if (unsubscribeCategories) unsubscribeCategories();
        unsubscribeTransactions = null; // Reset variable
        unsubscribeCategories = null; // Reset variable
        console.log("Listeners do Firestore desligados.");
    }

    // ===== Lógica de Transações =====

    // Abrir modal de transação (Nova ou Edição)
    function openTransactionModal(transaction = null) {
        const modalElement = document.getElementById('transaction-modal');
        const form = document.getElementById('transaction-form');
        if (!modalElement || !form) return; // Verifica se elementos existem
        form.reset(); // Limpa o formulário

        const modalTitle = document.getElementById('transaction-modal-title');
        const transactionIdInput = document.getElementById('transaction-id');
        const advancedFields = document.getElementById('advanced-fields');
        const toggleAdvancedButton = document.getElementById('btn-toggle-advanced');
        const recurringOptions = document.getElementById('recurring-options');
        const editRecurringOptions = document.getElementById('edit-recurring-options');
        const recurringBaseIdInput = document.getElementById('transaction-recurring-base-id');

        // Reset avançado e recorrência
        advancedFields.classList.remove('visible');
        toggleAdvancedButton.innerHTML = `Mostrar opções avançadas <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" viewBox="0 0 16 16" style="vertical-align: middle; margin-left: 4px;"><path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/></svg>`;
        recurringOptions.style.display = 'none';
        document.getElementById('transaction-recurring').checked = false;
        document.getElementById('transaction-installments').value = '';
        recurringBaseIdInput.value = '';
        editRecurringOptions.style.display = 'none'; // Esconde opções de edição de recorrência

        // Define valores padrão
        document.getElementById('transaction-date').value = formatDateForInput(); // Data de hoje
        document.getElementById('transaction-type').value = 'expense'; // Default despesa
        document.getElementById('transaction-status').value = 'paid'; // Default pago
        populateCategorySelect('expense'); // Popula categorias de despesa

        // Remove seleção de importância
        const importanceRadios = document.querySelectorAll('input[name="transaction-importance"]');
        importanceRadios.forEach(radio => radio.checked = false);


        if (transaction) {
            // --- MODO EDIÇÃO ---
            modalTitle.textContent = 'Editar Transação';
            transactionIdInput.value = transaction.id;
            document.getElementById('transaction-amount').value = transaction.amount;
            document.getElementById('transaction-date').value = transaction.date; // Assume YYYY-MM-DD
            document.getElementById('transaction-type').value = transaction.type;
            populateCategorySelect(transaction.type); // Atualiza categorias para o tipo correto
            document.getElementById('transaction-category').value = transaction.category; // Seleciona a categoria

            // Seleciona importância
            if (transaction.importance) {
                 const importanceRadio = document.getElementById(`importance-${transaction.importance}`);
                 if(importanceRadio) importanceRadio.checked = true;
            }

            // Revela campos avançados se houver dados neles
            let showAdvanced = false;
            const descriptionInput = document.getElementById('transaction-description');
            if (transaction.description) {
                descriptionInput.value = transaction.description;
                showAdvanced = true;
            } else {
                descriptionInput.value = ''; // Garante campo vazio
            }

            const statusSelect = document.getElementById('transaction-status');
            if (transaction.status && transaction.status !== 'paid') { // Se não for o default 'pago'
                statusSelect.value = transaction.status;
                showAdvanced = true;
            } else {
                 statusSelect.value = 'paid'; // Garante default
            }

             const paymentMethodSelect = document.getElementById('transaction-payment-method');
            if (transaction.paymentMethod) {
                paymentMethodSelect.value = transaction.paymentMethod;
                showAdvanced = true;
            } else {
                paymentMethodSelect.value = ''; // Garante default (Nenhuma)
            }

            const notesTextarea = document.getElementById('transaction-notes');
            if (transaction.notes) {
                notesTextarea.value = transaction.notes;
                showAdvanced = true;
            } else {
                notesTextarea.value = ''; // Garante campo vazio
            }

             // Recorrência
             const recurringCheckbox = document.getElementById('transaction-recurring');
             const frequencySelect = document.getElementById('transaction-frequency');
             const installmentsInput = document.getElementById('transaction-installments');

             if (transaction.recurringInfo && transaction.recurringInfo.baseId) {
                 recurringBaseIdInput.value = transaction.recurringInfo.baseId; // Guarda o ID base
                 recurringCheckbox.checked = true;
                 recurringOptions.style.display = 'block';
                 frequencySelect.value = transaction.recurringInfo.frequency || 'monthly'; // Default se ausente
                 installmentsInput.value = transaction.recurringInfo.totalInstallments || ''; // Mostra total se houver
                 showAdvanced = true;

                 // Mostra opções de edição para ocorrências recorrentes
                 editRecurringOptions.style.display = 'block';
                 // Marca 'somente esta' por padrão
                 const editScopeThis = document.querySelector('input[name="edit-recurring-scope"][value="this"]');
                 if(editScopeThis) editScopeThis.checked = true;

             } else {
                 recurringBaseIdInput.value = '';
                 recurringCheckbox.checked = false;
                 recurringOptions.style.display = 'none';
                 frequencySelect.value = 'monthly'; // Reset
                 installmentsInput.value = ''; // Reset
                 editRecurringOptions.style.display = 'none';
             }


            if (showAdvanced) {
                advancedFields.classList.add('visible');
                 toggleAdvancedButton.innerHTML = `Ocultar opções avançadas <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" viewBox="0 0 16 16" style="vertical-align: middle; margin-left: 4px;"><path fill-rule="evenodd" d="M7.646 4.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1-.708.708L8 5.707l-5.646 5.647a.5.5 0 0 1-.708-.708l6-6z"/></svg>`;
            }

        } else {
            // --- MODO NOVA TRANSAÇÃO ---
            modalTitle.textContent = 'Nova Transação';
            transactionIdInput.value = ''; // Garante que está vazio
            recurringBaseIdInput.value = '';
            editRecurringOptions.style.display = 'none';
             // Garante que campos avançados e recorrentes estão resetados
             document.getElementById('transaction-description').value = '';
             document.getElementById('transaction-status').value = 'paid';
             document.getElementById('transaction-payment-method').value = '';
             document.getElementById('transaction-notes').value = '';
             document.getElementById('transaction-recurring').checked = false;
             document.getElementById('recurring-options').style.display = 'none';
             document.getElementById('transaction-frequency').value = 'monthly';
             document.getElementById('transaction-installments').value = '';
        }

        openModal(modalElement);
        // Foco no campo de valor ao abrir
        setTimeout(() => {
            const amountInput = document.getElementById('transaction-amount');
            if (amountInput) amountInput.focus();
        }, 100);
    }


    // Salvar Transação (Nova ou Edição)
    async function saveTransaction(event) {
        event.preventDefault(); // Impede o envio padrão do formulário
         if (!transactionsCollection || !db) { // Verifica db também para batch e FieldValue
             showToast("Erro: Não é possível salvar transação (sem conexão).", "danger");
             return;
         }
        showLoading();

        const transactionId = document.getElementById('transaction-id').value;
        const amountInput = document.getElementById('transaction-amount');
        const amount = parseFloat(amountInput.value);
        const category = document.getElementById('transaction-category').value;
        const date = document.getElementById('transaction-date').value;
        const type = document.getElementById('transaction-type').value;
        const importanceRadio = document.querySelector('input[name="transaction-importance"]:checked');
        const importance = importanceRadio ? importanceRadio.value : null;

        // Campos avançados
        const description = document.getElementById('transaction-description').value.trim();
        const status = document.getElementById('transaction-status').value;
        const paymentMethod = document.getElementById('transaction-payment-method').value || null; // null se vazio
        const notes = document.getElementById('transaction-notes').value.trim();

        // Recorrência
        const isRecurring = document.getElementById('transaction-recurring').checked;
        const frequency = document.getElementById('transaction-frequency').value;
        const installmentsInput = document.getElementById('transaction-installments').value;
        const totalInstallments = installmentsInput ? parseInt(installmentsInput) : null; // null se infinito

        // Validação básica
        if (isNaN(amount) || amount <= 0) {
             showToast("Valor inválido. Insira um número positivo.", "warning");
             amountInput.focus(); // Foca no campo com erro
             hideLoading();
             return;
        }
         if (!category) {
             showToast("Selecione uma Categoria.", "warning");
             document.getElementById('transaction-category').focus();
             hideLoading();
             return;
         }
         if (!date) {
             showToast("Selecione uma Data.", "warning");
             document.getElementById('transaction-date').focus();
             hideLoading();
             return;
         }
        if(isRecurring && !frequency) {
            showToast("Selecione a frequência da recorrência.", "warning");
            document.getElementById('transaction-frequency').focus();
            hideLoading();
            return;
        }
        if(isRecurring && totalInstallments !== null && totalInstallments < 2) {
            showToast("O número de parcelas deve ser 2 ou maior.", "warning");
            document.getElementById('transaction-installments').focus();
            hideLoading();
            return;
        }
         // Validação UUID (verifica se a biblioteca carregou)
         if (isRecurring && typeof uuid === 'undefined') {
             showToast("Erro: Biblioteca UUID não carregada. Recorrência não pode ser salva.", "danger");
             hideLoading();
             return;
         }

        const baseTransactionData = {
            amount, category, date, type, importance,
            description: description || null, // Armazena null se vazio
            status, paymentMethod, notes: notes || null,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp() // Sempre atualiza o updatedAt
        };

         // --- Lógica de Edição vs. Nova ---
        const isEditing = !!transactionId;
        const recurringBaseId = document.getElementById('transaction-recurring-base-id').value;
        const isEditingRecurring = isEditing && !!recurringBaseId;

        try {
            if (isEditingRecurring) {
                // --- Editando uma Ocorrência Recorrente ---
                const editScopeRadio = document.querySelector('input[name="edit-recurring-scope"]:checked');
                const editScope = editScopeRadio ? editScopeRadio.value : 'this'; // Default to 'this' if not found

                if (editScope === 'this') {
                    // Edita APENAS esta ocorrência
                    console.log(`Editando apenas a ocorrência ${transactionId}`);
                    const transactionRef = transactionsCollection.doc(transactionId);
                    // Remove a informação de recorrência desta instância específica
                    // mas mantém outros dados. Garante que updatedAt é atualizado.
                    const updateData = {
                        ...baseTransactionData, // Inclui amount, category, date, type, importance, description, status, paymentMethod, notes, updatedAt
                        recurringInfo: firebase.firestore.FieldValue.delete(), // Remove o campo
                        // createdAt não deve ser alterado aqui
                    };
                    await transactionRef.update(updateData);
                    showToast("Ocorrência atualizada com sucesso.", "success");

                } else { // editScope === 'future'
                    // Edita esta e as futuras
                     console.log(`Editando ocorrência ${transactionId} e futuras com baseId ${recurringBaseId}`);
                    const originalTransaction = transactions.find(t => t.id === transactionId);
                    if (!originalTransaction || !originalTransaction.recurringInfo) {
                         throw new Error("Transação recorrente original ou suas informações não encontradas para edição futura.");
                    }

                    const batch = db.batch();
                    const currentInstallmentNumber = originalTransaction.recurringInfo.currentInstallment;

                    // 1. Atualiza a ocorrência atual (dados base + recurringInfo atualizado se isRecurring ainda for true)
                    const currentRef = transactionsCollection.doc(transactionId);
                    let currentUpdateData = { ...baseTransactionData }; // Inclui todos os campos base atualizados
                     if (isRecurring) { // Se AINDA é recorrente após a edição
                        currentUpdateData.recurringInfo = {
                             baseId: recurringBaseId, // Mantém o mesmo baseId
                             frequency: frequency, // Usa a nova frequência
                             currentInstallment: currentInstallmentNumber, // Mantém a parcela atual
                             totalInstallments: totalInstallments // Usa o novo total
                         };
                     } else { // Se deixou de ser recorrente
                         currentUpdateData.recurringInfo = firebase.firestore.FieldValue.delete();
                     }
                    batch.update(currentRef, currentUpdateData);

                    // 2. Busca e atualiza futuras ocorrências com o mesmo baseId
                    console.log(`Buscando futuras transações com baseId ${recurringBaseId} e parcela > ${currentInstallmentNumber}`);
                    const futureQuery = transactionsCollection
                        .where('recurringInfo.baseId', '==', recurringBaseId)
                        .where('recurringInfo.currentInstallment', '>', currentInstallmentNumber) // Apenas futuras parcelas
                        .orderBy('recurringInfo.currentInstallment', 'asc');

                    const futureSnapshot = await futureQuery.get();
                     console.log(`${futureSnapshot.docs.length} transações futuras encontradas.`);
                    futureSnapshot.docs.forEach(doc => {
                        const futureDocRef = doc.ref;
                        const futureInstallmentNum = doc.data().recurringInfo?.currentInstallment;

                        // Cria os dados base para as futuras (NÃO copia data, status ou installmentNumber)
                        const futureUpdateData = {
                            amount: baseTransactionData.amount,
                            category: baseTransactionData.category,
                            type: baseTransactionData.type,
                            importance: baseTransactionData.importance,
                            description: baseTransactionData.description ? `${baseTransactionData.description} ${totalInstallments ? `(${futureInstallmentNum}/${totalInstallments})` : ''}`.trim() : null, // Atualiza descrição com nova parcela se necessário
                            paymentMethod: baseTransactionData.paymentMethod,
                            notes: baseTransactionData.notes,
                            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                            // NÃO atualiza: date, status, createdAt
                        };

                         // Atualiza o recurringInfo se necessário (ex: mudou frequência, parcelas)
                         if (isRecurring) { // Se continua recorrente
                             futureUpdateData.recurringInfo = {
                                 baseId: recurringBaseId,
                                 frequency: frequency,
                                 currentInstallment: futureInstallmentNum, // Mantém a parcela da futura
                                 totalInstallments: totalInstallments
                             };
                         } else { // Se deixou de ser recorrente, remove info das futuras também
                              futureUpdateData.recurringInfo = firebase.firestore.FieldValue.delete();
                         }

                        console.log(`Atualizando futura transação ${doc.id} (Parcela ${futureInstallmentNum})`);
                        batch.update(futureDocRef, futureUpdateData);
                    });

                    await batch.commit();
                    showToast("Esta e as futuras ocorrências foram atualizadas.", "success");
                    // NOTA: Esta lógica assume que as datas das futuras não precisam ser recalculadas.
                    // Se a frequência mudou, as datas futuras existentes podem ficar "incorretas"
                    // em relação à nova frequência. Recalcular e recriar seria mais complexo.
                }

            } else if (isEditing && !isRecurring) {
                 // --- Editando uma Transação ÚNICA (que não era ou deixou de ser recorrente) ---
                 console.log(`Editando transação única ${transactionId}`);
                 // Garante que não tem info recorrente ao salvar
                const updateData = {
                    ...baseTransactionData,
                    recurringInfo: firebase.firestore.FieldValue.delete(),
                    // createdAt não deve ser alterado
                 };
                 // Remove createdAt se ele foi adicionado indevidamente em baseTransactionData para edição
                 delete updateData.createdAt;

                 await transactionsCollection.doc(transactionId).update(updateData);
                 showToast("Transação atualizada com sucesso!", "success");

            } else if (isEditing && isRecurring) {
                 // --- Editando uma Transação ÚNICA e TORNANDO-A Recorrente ---
                 console.log(`Tornando a transação ${transactionId} recorrente.`);
                 const baseId = uuid.v4(); // Novo ID base para a recorrência
                 const firstInstallmentData = {
                     ...baseTransactionData,
                     recurringInfo: {
                         baseId: baseId,
                         frequency: frequency,
                         currentInstallment: 1,
                         totalInstallments: totalInstallments
                     },
                     // createdAt não deve ser alterado aqui
                 };
                 delete firstInstallmentData.createdAt; // Remove createdAt se presente

                 const batch = db.batch();
                 // Atualiza a transação existente como a primeira parcela
                 batch.update(transactionsCollection.doc(transactionId), firstInstallmentData);
                 // Gera as parcelas futuras a partir da data da transação original
                 await generateFutureInstallments(batch, baseTransactionData, baseId, frequency, totalInstallments, date, 1);
                 await batch.commit();
                 showToast("Transação atualizada e recorrência criada!", "success");


            } else if (!isEditing && isRecurring) {
                // --- Criando uma NOVA Transação Recorrente ---
                 console.log(`Criando nova transação recorrente`);
                 const baseId = uuid.v4(); // ID único para agrupar as recorrências
                 const firstInstallmentData = {
                    ...baseTransactionData, // Contém todos os dados base + updatedAt
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(), // Adiciona createdAt aqui
                    recurringInfo: {
                        baseId: baseId,
                        frequency: frequency,
                        currentInstallment: 1,
                        totalInstallments: totalInstallments
                    }
                 };

                const batch = db.batch();
                // Adiciona a primeira transação (a da data selecionada)
                const firstDocRef = transactionsCollection.doc(); // Gera ID para a primeira parcela
                batch.set(firstDocRef, firstInstallmentData);

                 // Gera as parcelas futuras (passa dados base SEM timestamps)
                 const dataForFuture = {...baseTransactionData};
                 delete dataForFuture.updatedAt;
                 delete dataForFuture.createdAt; // Timestamps serão definidos em generateFutureInstallments

                await generateFutureInstallments(batch, dataForFuture, baseId, frequency, totalInstallments, date, 1);

                await batch.commit();
                showToast(`Transação ${totalInstallments ? 'parcelada' : 'recorrente'} criada com sucesso!`, "success");

            } else { // !isEditing && !isRecurring
                // --- Criando uma NOVA Transação ÚNICA ---
                 console.log(`Criando nova transação única`);
                await transactionsCollection.add({
                    ...baseTransactionData,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp() // Adiciona createdAt
                 });
                showToast("Transação adicionada com sucesso!", "success");
            }

            closeModal(document.getElementById('transaction-modal'));

        } catch (error) {
            console.error("Erro ao salvar transação: ", error);
            showToast(`Erro ao salvar transação: ${error.message || 'Erro desconhecido'}`, "danger", 5000);
        } finally {
            hideLoading();
        }
    }

   // Função auxiliar para gerar parcelas futuras
    async function generateFutureInstallments(batch, baseData, baseId, frequency, totalInstallments, startDate, startInstallmentNum) {
         if (!transactionsCollection || !db) return; // Verifica dependências

        const freqInfo = RECURRENCE_FREQUENCY[frequency];
        if (!freqInfo) {
            console.error(`Frequência inválida: ${frequency}`);
            return;
        }

         // Define limite máximo de parcelas a gerar para evitar loops/sobrecarga
        const limit = totalInstallments ? totalInstallments : (startInstallmentNum + 24); // Gera até 24 parcelas se infinito
        const absoluteMax = startInstallmentNum + 60; // Limite duro de 5 anos
        const finalLimit = Math.min(limit, absoluteMax);

        console.log(`Gerando futuras parcelas a partir de ${startInstallmentNum + 1} até ${finalLimit}`);

        let currentDate = moment(startDate);
        for (let i = startInstallmentNum + 1; i <= finalLimit; i++) {
            currentDate = currentDate.add(freqInfo.momentStep, freqInfo.momentUnit);

            // Cria a descrição para a parcela futura
            const futureDescription = baseData.description
              ? `${baseData.description} ${totalInstallments ? `(${i}/${totalInstallments})` : ''}`.trim()
              : `Parcela ${i}${totalInstallments ? ` de ${totalInstallments}` : ''}`;


            const futureInstallmentData = {
                ...baseData, // Copia valor, categoria, tipo, importance, paymentMethod, notes
                date: currentDate.format('YYYY-MM-DD'), // Data da parcela futura
                status: 'scheduled', // Futuras são agendadas por padrão
                description: futureDescription,
                recurringInfo: {
                    baseId: baseId,
                    frequency: frequency,
                    currentInstallment: i,
                    totalInstallments: totalInstallments
                },
                 // Define timestamps para cada nova parcela criada
                 createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                 updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            };
            // Não copiar ID da transação original (não deve estar em baseData aqui)
            delete futureInstallmentData.id;

            const futureDocRef = transactionsCollection.doc(); // Gera novo ID para cada parcela
            console.log(`Agendando batch.set para parcela ${i} (ID: ${futureDocRef.id}) em ${futureInstallmentData.date}`);
            batch.set(futureDocRef, futureInstallmentData);
        }
        console.log(`Geração de futuras parcelas concluída no batch.`);
    }


    // Excluir Transação
    async function deleteTransaction(transactionId, recurringBaseId = null, deleteScope = 'this') {
         if (!transactionsCollection || !db) { // Verifica db para batch
             showToast("Erro: Não é possível excluir transação (sem conexão).", "danger");
             return;
         }
        showLoading();
        try {
             if (recurringBaseId && deleteScope !== 'this') {
                 // --- Excluir Esta e Futuras Recorrências ---
                 console.log(`Excluindo ocorrência ${transactionId} e futuras com baseId ${recurringBaseId}`);
                const batch = db.batch();
                const originalTransaction = transactions.find(t => t.id === transactionId);
                // Encontra o número da parcela atual para buscar as futuras
                 const currentInstallmentNum = originalTransaction?.recurringInfo?.currentInstallment;

                 if (!originalTransaction || typeof currentInstallmentNum !== 'number') {
                     // Se não achar a transação ou a info da parcela, tenta excluir pelo menos a selecionada
                     console.warn("Não foi possível obter info da parcela recorrente original. Excluindo apenas a selecionada.");
                      await transactionsCollection.doc(transactionId).delete();
                      showToast("Transação selecionada excluída. Não foi possível excluir futuras.", "warning");
                      hideLoading();
                      closeModalIfNeeded(document.getElementById('confirm-modal'));
                      return;
                 }


                // 1. Exclui a ocorrência atual (marcada para exclusão)
                batch.delete(transactionsCollection.doc(transactionId));
                console.log(`Agendada exclusão de ${transactionId}`);

                // 2. Busca e exclui futuras ocorrências com o mesmo baseId e parcela >= atual
                // Usamos >= currentInstallment para garantir que pegamos a atual E as futuras
                 console.log(`Buscando futuras transações com baseId ${recurringBaseId} e parcela >= ${currentInstallmentNum}`);
                const futureQuery = transactionsCollection
                    .where('recurringInfo.baseId', '==', recurringBaseId)
                    .where('recurringInfo.currentInstallment', '>=', currentInstallmentNum);

                const futureSnapshot = await futureQuery.get();
                 console.log(`${futureSnapshot.docs.length} transações (incluindo a atual) encontradas para exclusão.`);
                futureSnapshot.docs.forEach(doc => {
                    // A transação atual já está no batch.delete(transactionId)
                    // Mas se houver outras com a *mesma* installment number (improvável), deleta também.
                    // O importante é deletar as com installmentNumber > currentInstallmentNum
                    // e a própria atual. A query >= cobre isso.
                    if (doc.id !== transactionId) { // Evita adicionar a mesma exclusão duas vezes
                        console.log(`Agendada exclusão de futura transação ${doc.id}`);
                        batch.delete(doc.ref);
                    }
                });

                 await batch.commit();
                 showToast("Esta e as futuras ocorrências foram excluídas.", "success");

             } else {
                 // --- Excluir Apenas Esta Ocorrência (ou uma transação única) ---
                  console.log(`Excluindo transação única ${transactionId}`);
                 await transactionsCollection.doc(transactionId).delete();
                 showToast("Transação excluída com sucesso!", "success");
             }

        } catch (error) {
            console.error("Erro ao excluir transação: ", error);
            showToast(`Erro ao excluir transação: ${error.message || 'Erro desconhecido'}`, "danger", 5000);
        } finally {
            hideLoading();
             // Fecha modal de confirmação se estiver aberta
             closeModalIfNeeded(document.getElementById('confirm-modal'));
        }
    }


    // ===== Interface e Interação =====

    // Abrir/Fechar Modais
    function openModal(modalElement) {
      if (modalElement) {
          modalElement.classList.add('active');
      }
    }
    function closeModal(modalElement) {
      if (modalElement) {
          modalElement.classList.remove('active');
      }
    }
    // Helper para fechar modal se ele existir e estiver ativo
    function closeModalIfNeeded(modalElement) {
        if (modalElement && modalElement.classList.contains('active')) {
            closeModal(modalElement);
        }
    }

    // Inicializar Navegação por Tabs
    function initTabs() {
        const tabLinks = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');

        tabLinks.forEach(tab => {
            tab.addEventListener('click', () => {
                const targetTabId = tab.dataset.tab;
                if (!targetTabId) return; // Sai se não houver data-tab

                // Remove 'active' de todas as tabs e conteúdos
                tabLinks.forEach(t => t.classList.remove('active'));
                tabContents.forEach(c => c.classList.remove('active'));

                // Adiciona 'active' à tab clicada e ao conteúdo correspondente
                tab.classList.add('active');
                const targetContent = document.getElementById(`tab-${targetTabId}`);
                if (targetContent) {
                    targetContent.classList.add('active');
                }

                currentTab = targetTabId;
                console.log(`Tab alterada para: ${currentTab}`);

                // Atualiza o conteúdo da tab selecionada
                if (targetTabId === 'analysis') {
                    // Garante que os filtros estejam populados antes de atualizar
                     if(categories.length === 0) {
                         console.warn("Tentando atualizar análise sem categorias carregadas.");
                         // Tenta carregar categorias se ainda não foram
                         loadCategories().then(updateMonthlyAnalysis).catch(console.error);
                     } else {
                        updateMonthlyAnalysis(); // Atualiza ou inicializa a análise mensal
                     }
                } else if (targetTabId === 'overview') {
                     updateOverviewCharts(); // Atualiza gráficos da visão geral
                     updateKPIs(); // Atualiza KPIs
                }
            });
        });
    }

    // Popular selects de categoria
    function populateCategoryFilters() {
        const analysisCategorySelect = document.getElementById('analysis-category');
        const transactionCategorySelect = document.getElementById('transaction-category');

        // Verifica se os selects existem
        if (!analysisCategorySelect || !transactionCategorySelect) {
            console.warn("Selects de categoria não encontrados no DOM.");
            return;
        }

        // Guarda o valor selecionado para restaurar depois (se existir)
        const selectedAnalysisCategory = analysisCategorySelect ? analysisCategorySelect.value : 'all';

        // Limpa selects (mantendo a opção "Todas" na análise)
        analysisCategorySelect.innerHTML = '<option value="all">Todas as Categorias</option>';
        transactionCategorySelect.innerHTML = ''; // Limpa completamente

        // Popula Análise Mensal
        categories.forEach(cat => {
            const option = document.createElement('option');
            option.value = cat.id;
            // Usa textContent para evitar problemas com HTML injection
            option.textContent = `${cat.icon || ''} ${cat.name || 'Categoria sem nome'}`;
            analysisCategorySelect.appendChild(option);
        });

        // Popula Modal de Transação (filtrado pelo tipo selecionado no modal)
        const currentTransactionType = document.getElementById('transaction-type')?.value || 'expense';
        populateCategorySelect(currentTransactionType);


        // Restaura seleção anterior no filtro de análise, se possível
        if (analysisCategorySelect.querySelector(`option[value="${selectedAnalysisCategory}"]`)) {
            analysisCategorySelect.value = selectedAnalysisCategory;
        } else {
            analysisCategorySelect.value = 'all'; // Volta para 'Todas' se a anterior sumiu
        }

         // Habilita/desabilita botão de excluir categoria na Análise Mensal
         toggleDeleteCategoryButton();
    }

    // Popular select de categoria no Modal de Transação (filtrado por tipo)
    function populateCategorySelect(type = 'expense') {
        const select = document.getElementById('transaction-category');
        if (!select) return; // Sai se o select não existe
        select.innerHTML = ''; // Limpa antes de popular

        const filteredCategories = categories.filter(cat => cat.type === type);

        if (filteredCategories.length === 0) {
             const option = document.createElement('option');
             option.value = "";
             option.textContent = `Nenhuma categoria de ${type === 'income' ? 'receita' : 'despesa'} encontrada`;
             option.disabled = true;
             select.appendChild(option);
        } else {
            filteredCategories.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat.id;
                option.textContent = `${cat.icon || ''} ${cat.name || 'Categoria sem nome'}`;
                select.appendChild(option);
            });
        }
    }

    // Habilita/desabilita botão de excluir categoria
    function toggleDeleteCategoryButton() {
        const select = document.getElementById('analysis-category');
        const deleteButton = document.getElementById('btn-delete-category');
        if (!select || !deleteButton) return; // Verifica elementos

        if (select.value !== 'all') {
             const category = categories.find(c => c.id === select.value);
             // Só mostra se a categoria selecionada NÃO for padrão
             if (category && !category.isDefault) {
                deleteButton.style.display = 'inline-flex';
             } else {
                 deleteButton.style.display = 'none';
             }
        } else {
            deleteButton.style.display = 'none';
        }
    }

     // Popular select de Mês/Ano para Análise
    function populateMonthYearFilter() {
        const select = document.getElementById('analysis-month-year');
        if (!select) return; // Verifica elemento
        select.innerHTML = ''; // Limpa

        // Gera opções para os últimos 12 meses + próximos 6 meses
        const startMonth = moment().subtract(12, 'months');
        const endMonth = moment().add(6, 'months');

        let current = startMonth.clone();
        while (current.isSameOrBefore(endMonth, 'month')) {
            const value = current.format('YYYY-MM');
            const text = current.format('MMMM YYYY');
            const option = document.createElement('option');
            option.value = value;
            // Capitaliza a primeira letra do mês
            option.textContent = text.charAt(0).toUpperCase() + text.slice(1);
            select.appendChild(option);
            current.add(1, 'month');
        }

        // Define o mês atual como padrão
        const currentMonthValue = moment().format('YYYY-MM');
        // Verifica se a opção do mês atual existe antes de definir
        if (select.querySelector(`option[value="${currentMonthValue}"]`)) {
           select.value = currentMonthValue;
        } else if (select.options.length > 0) {
            // Se não existir (caso raro), seleciona a última opção (mais recente)
            select.value = select.options[select.options.length - 1].value;
        }
        currentAnalysisMonthYear = select.value;
    }

     // Setup dos Event Listeners
    function setupEventListeners() {
        // Botão Nova Transação
        const btnNew = document.getElementById('btn-new-transaction');
        if (btnNew) btnNew.addEventListener('click', () => openTransactionModal());

        // Toggle Tema
        const btnTheme = document.getElementById('theme-toggle');
        if (btnTheme) btnTheme.addEventListener('click', toggleTheme);

        // --- Modal de Transação ---
        const transactionModal = document.getElementById('transaction-modal');
        if (transactionModal) {
            const btnClose = transactionModal.querySelector('#transaction-modal-close');
            const btnCancel = transactionModal.querySelector('#transaction-modal-cancel');
            const form = transactionModal.querySelector('#transaction-form');
            const typeSelect = transactionModal.querySelector('#transaction-type');
            const btnToggleAdvanced = transactionModal.querySelector('#btn-toggle-advanced');
            const recurringCheckbox = transactionModal.querySelector('#transaction-recurring');
             const btnAddCategoryModal = transactionModal.querySelector('#btn-add-category-modal');


            if (btnClose) btnClose.addEventListener('click', () => closeModal(transactionModal));
            if (btnCancel) btnCancel.addEventListener('click', () => closeModal(transactionModal));
            if (form) form.addEventListener('submit', saveTransaction);
            if (typeSelect) typeSelect.addEventListener('change', (e) => populateCategorySelect(e.target.value));
            if (btnToggleAdvanced) btnToggleAdvanced.addEventListener('click', toggleAdvancedFields);
            if (recurringCheckbox) {
                recurringCheckbox.addEventListener('change', (e) => {
                    const recurringOptionsDiv = document.getElementById('recurring-options');
                    if(recurringOptionsDiv) recurringOptionsDiv.style.display = e.target.checked ? 'block' : 'none';
                });
            }
             if (btnAddCategoryModal) btnAddCategoryModal.addEventListener('click', () => openCategoryModal());
        }

        // --- Filtros Análise Mensal ---
        const monthYearSelect = document.getElementById('analysis-month-year');
        const categorySelect = document.getElementById('analysis-category');

        if (monthYearSelect) {
            monthYearSelect.addEventListener('change', (e) => {
                currentAnalysisMonthYear = e.target.value;
                updateMonthlyAnalysis();
            });
        }
        if (categorySelect) {
            categorySelect.addEventListener('change', (e) => {
                currentAnalysisCategory = e.target.value;
                toggleDeleteCategoryButton();
                updateMonthlyAnalysis();
            });
        }

         // --- Gerenciamento de Categorias ---
         const btnAddCategoryGlobal = document.getElementById('btn-add-category');
         const btnDeleteCategoryGlobal = document.getElementById('btn-delete-category');
         const categoryModal = document.getElementById('category-modal');


         if (btnAddCategoryGlobal) btnAddCategoryGlobal.addEventListener('click', () => openCategoryModal());
         if (btnDeleteCategoryGlobal) {
             btnDeleteCategoryGlobal.addEventListener('click', () => {
                const selectedCategoryId = document.getElementById('analysis-category')?.value;
                if (selectedCategoryId && selectedCategoryId !== 'all') {
                    confirmDeleteCategory(selectedCategoryId);
                }
            });
         }

         if (categoryModal) {
             const categoryForm = categoryModal.querySelector('#category-form');
             if (categoryForm) categoryForm.addEventListener('submit', handleSaveCategory);
             // Botões de fechar/cancelar dentro do modal de categoria
             categoryModal.querySelectorAll('[data-dismiss="modal"]').forEach(btn => {
                 btn.addEventListener('click', () => closeModal(categoryModal));
             });
         }


         // --- Modal de Confirmação ---
          const confirmModal = document.getElementById('confirm-modal');
          if (confirmModal) {
              const confirmButton = confirmModal.querySelector('#confirm-modal-confirm');
              if (confirmButton) {
                  confirmButton.addEventListener('click', () => {
                     // A ação específica é definida dinamicamente antes de abrir o modal
                     // usando uma propriedade customizada no botão
                     const action = confirmButton._action; // Acessa a propriedade customizada
                     if (action && typeof action === 'function') {
                         action(); // Executa a ação (ex: deleteTransaction, deleteCategory)
                     } else {
                         console.warn("Nenhuma ação definida para confirmação.");
                         closeModal(confirmModal);
                     }
                 });
              }
               // Botões de fechar/cancelar dentro do modal de confirmação
             confirmModal.querySelectorAll('[data-dismiss="modal"]').forEach(btn => {
                 btn.addEventListener('click', () => closeModal(confirmModal));
             });
          }

         // Event listener genérico para fechar modais clicando fora (no backdrop)
         document.querySelectorAll('.modal').forEach(modal => {
             modal.addEventListener('click', (event) => {
                // Fecha APENAS se o clique for diretamente no elemento .modal (o backdrop)
                if (event.target === modal) {
                    closeModal(modal);
                }
             });
         });

        console.log("Listeners de eventos configurados.");
    }

    // Mostrar/Ocultar campos avançados no modal de transação
    function toggleAdvancedFields() {
        const advancedFields = document.getElementById('advanced-fields');
        const button = document.getElementById('btn-toggle-advanced');
        if (!advancedFields || !button) return; // Verifica elementos

        const isVisible = advancedFields.classList.toggle('visible');

        if (isVisible) {
             button.innerHTML = `Ocultar opções avançadas <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" viewBox="0 0 16 16" style="vertical-align: middle; margin-left: 4px;"><path fill-rule="evenodd" d="M7.646 4.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1-.708.708L8 5.707l-5.646 5.647a.5.5 0 0 1-.708-.708l6-6z"/></svg>`;
        } else {
             button.innerHTML = `Mostrar opções avançadas <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" viewBox="0 0 16 16" style="vertical-align: middle; margin-left: 4px;"><path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/></svg>`;
        }
    }

    // Abrir Modal Nova Categoria
    function openCategoryModal() {
        const modalElement = document.getElementById('category-modal');
        const form = document.getElementById('category-form');
        if (!modalElement || !form) return;

        form.reset();
        document.getElementById('category-modal-title').textContent = "Nova Categoria";
        // Tenta definir cor padrão, verificando se elemento existe
        const colorInput = document.getElementById('category-color');
        if (colorInput) colorInput.value = '#8A8A8E';

        openModal(modalElement);
        setTimeout(() => {
            const nameInput = document.getElementById('category-name');
            if(nameInput) nameInput.focus();
        }, 100);
    }

    // Salvar Categoria (Handler do form)
    async function handleSaveCategory(event) {
        event.preventDefault();
        const nameInput = document.getElementById('category-name');
        const typeSelect = document.getElementById('category-type');
        const iconInput = document.getElementById('category-icon');
        const colorInput = document.getElementById('category-color');

        const name = nameInput ? nameInput.value : '';
        const type = typeSelect ? typeSelect.value : '';
        const icon = iconInput ? iconInput.value : '';
        const color = colorInput ? colorInput.value : '#8A8A8E';

        if (!name || !type) {
            showToast("Nome e Tipo da Categoria são obrigatórios.", "warning");
            return;
        }

        const success = await addCategory(name, type, icon, color);
        if (success) {
            closeModal(document.getElementById('category-modal'));
        }
    }

    // Confirmar Exclusão de Categoria
    function confirmDeleteCategory(categoryId) {
        const category = categories.find(c => c.id === categoryId);
        if (!category) {
            showToast("Categoria não encontrada.", "danger");
            return;
        }
         if (category.isDefault) {
            showToast("Categorias padrão não podem ser excluídas.", "warning");
            return;
        }

        const confirmModalElement = document.getElementById('confirm-modal');
        if (!confirmModalElement) return;

        const title = confirmModalElement.querySelector('#confirm-modal-title');
        const message = confirmModalElement.querySelector('#confirm-modal-message');
        const extraInfo = confirmModalElement.querySelector('#confirm-modal-extra-info');
        const confirmButton = confirmModalElement.querySelector('#confirm-modal-confirm');

        if(title) title.textContent = "Excluir Categoria";
        if(message) message.textContent = `Tem certeza que deseja excluir a categoria "${category.name || categoryId}"?`;
        if(extraInfo) extraInfo.textContent = "Atenção: Esta ação não pode ser desfeita. Transações associadas (se houver) ficarão sem categoria.";
        if(confirmButton) {
             confirmButton.textContent = "Excluir";
             confirmButton.className = 'btn btn-danger'; // Botão vermelho
             // Define a ação do botão confirmar usando propriedade customizada
             confirmButton._action = () => deleteCategory(categoryId);
        }

        openModal(confirmModalElement);
    }

     // Confirmar Exclusão de Transação
    function confirmDeleteTransaction(transactionId) {
        const transaction = transactions.find(t => t.id === transactionId);
        if (!transaction) {
            showToast("Transação não encontrada.", "danger");
            return;
        }

        const confirmModalElement = document.getElementById('confirm-modal');
         if (!confirmModalElement) return;

        const title = confirmModalElement.querySelector('#confirm-modal-title');
        const message = confirmModalElement.querySelector('#confirm-modal-message');
        const extraInfo = confirmModalElement.querySelector('#confirm-modal-extra-info');
        const confirmButton = confirmModalElement.querySelector('#confirm-modal-confirm');


        if (title) title.textContent = "Excluir Transação";
        const description = transaction.description || `Transação de ${formatCurrency(transaction.amount)}`;
        let baseMessage = `Tem certeza que deseja excluir a transação "${description}" de ${formatDate(transaction.date)}?`;
        let extraInfoHTML = "Esta ação não pode ser desfeita.";
        let deleteScope = 'this'; // Padrão: excluir apenas esta
        let confirmButtonAction = () => deleteTransaction(transactionId, null, 'this'); // Ação padrão

         // Lógica para recorrência
         const recurringBaseId = transaction.recurringInfo?.baseId;
         if(recurringBaseId) {
            baseMessage = `Esta é uma transação recorrente (${transaction.recurringInfo?.currentInstallment || '?'}/${transaction.recurringInfo?.totalInstallments || '∞'}). O que você deseja excluir?`;
            extraInfoHTML = `
                <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                    <label>
                        <input type="radio" name="delete-scope" value="this" checked> Somente esta ocorrência (${formatDate(transaction.date)})
                    </label>
                    <label>
                        <input type="radio" name="delete-scope" value="future"> Esta e todas as futuras ocorrências
                    </label>
                </div>
            `;

            // Atualiza a ação do botão dinamicamente quando o radio muda
            confirmModalElement.querySelectorAll('input[name="delete-scope"]').forEach(radio => {
                 radio.onchange = (e) => {
                    deleteScope = e.target.value;
                    confirmButtonAction = () => deleteTransaction(transactionId, recurringBaseId, deleteScope);
                    // Reatribui a ação ao botão confirmar
                    if (confirmButton) confirmButton._action = confirmButtonAction;
                 };
             });
             // Define a ação inicial para o botão
             confirmButtonAction = () => deleteTransaction(transactionId, recurringBaseId, 'this'); // Inicia com 'this'
         }

        if(message) message.textContent = baseMessage;
        if(extraInfo) extraInfo.innerHTML = extraInfoHTML; // Usa innerHTML para renderizar os radios
        if(confirmButton) {
             confirmButton.textContent = "Excluir";
             confirmButton.className = 'btn btn-danger';
             confirmButton._action = confirmButtonAction; // Atribui a ação (inicial ou recorrente)
         }

        // Garante que o radio 'this' esteja marcado ao abrir (para recorrentes)
        const radioThis = confirmModalElement.querySelector('input[name="delete-scope"][value="this"]');
        if (radioThis) radioThis.checked = true;

        openModal(confirmModalElement);
    }


    // ===== Atualização da UI =====

    // Atualizar Dashboard Completo
    function updateDashboard() {
        // Verifica se as coleções estão disponíveis antes de atualizar
        if (!transactionsCollection || !categoriesCollection) {
            console.warn("Atualização do Dashboard interrompida - coleções não disponíveis.");
            // Pode ser útil resetar a UI para um estado vazio/erro
            // resetUI(); // (Função a ser criada se necessário)
            return;
        }
        console.log("Atualizando dashboard...");
        updateKPIs();
        // Atualiza gráficos dependendo da aba ativa
        if (currentTab === 'overview') {
            updateOverviewCharts();
        } else if (currentTab === 'analysis') {
            updateMonthlyAnalysis(); // Garante que a análise está atualizada
        }
    }

    // Atualizar KPIs da Visão Geral
    function updateKPIs() {
        // Seleciona elementos da UI
        const balanceEl = document.getElementById('kpi-balance');
        const incomeEl = document.getElementById('kpi-income');
        const expensesEl = document.getElementById('kpi-expenses');
        const savingsEl = document.getElementById('kpi-savings');
        const projectionEl = document.getElementById('kpi-projection');
        const balanceTrendEl = document.getElementById('balance-trend');
        const incomeTrendEl = document.getElementById('income-trend');
        const expensesTrendEl = document.getElementById('expenses-trend');
        const balanceTrendIndicator = document.getElementById('balance-trend-indicator');
        const incomeTrendIndicator = document.getElementById('income-trend-indicator');
        const expensesTrendIndicator = document.getElementById('expenses-trend-indicator');
        const savingsStatusEl = document.getElementById('savings-status');
        const savingsProgress = document.getElementById('savings-progress');
        const projectionStatusEl = document.getElementById('projection-status');

        // Verifica se todos os elementos existem antes de prosseguir
        if (!balanceEl || !incomeEl || !expensesEl || !savingsEl || !projectionEl ||
            !balanceTrendEl || !incomeTrendEl || !expensesTrendEl ||
            !balanceTrendIndicator || !incomeTrendIndicator || !expensesTrendIndicator ||
            !savingsStatusEl || !savingsProgress || !projectionStatusEl) {
            console.warn("Um ou mais elementos de KPI não encontrados no DOM. Abortando atualização de KPIs.");
            return;
        }

        // 1. Saldo Atual (Considerando todas as transações pagas)
        const totalIncome = transactions
            .filter(t => t.type === 'income' && t.status === 'paid' && typeof t.amount === 'number')
            .reduce((sum, t) => sum + t.amount, 0);
        const totalExpenses = transactions
            .filter(t => t.type === 'expense' && t.status === 'paid' && typeof t.amount === 'number')
            .reduce((sum, t) => sum + t.amount, 0);
        const currentBalance = totalIncome - totalExpenses;
        balanceEl.textContent = formatCurrency(currentBalance);

        // 2. Receitas e Despesas do Mês Atual
        const currentMonthStart = moment().startOf('month');
        const currentMonthEnd = moment().endOf('month');

        const currentMonthIncome = transactions
            .filter(t => t.type === 'income' && typeof t.amount === 'number' && moment(t.date).isBetween(currentMonthStart, currentMonthEnd, 'day', '[]'))
            .reduce((sum, t) => sum + t.amount, 0);
        const currentMonthExpenses = transactions
            .filter(t => t.type === 'expense' && typeof t.amount === 'number' && moment(t.date).isBetween(currentMonthStart, currentMonthEnd, 'day', '[]'))
            .reduce((sum, t) => sum + t.amount, 0);

        incomeEl.textContent = formatCurrency(currentMonthIncome);
        expensesEl.textContent = formatCurrency(currentMonthExpenses);

        // 3. Economia do Mês
        const currentMonthSavings = currentMonthIncome - currentMonthExpenses;
        savingsEl.textContent = formatCurrency(currentMonthSavings);
        savingsEl.style.color = currentMonthSavings >= 0 ? 'var(--success)' : 'var(--danger)';

        // Barra de progresso e status da economia
        let savingsPercentage = 0;
        if (currentMonthIncome > 0) {
            savingsPercentage = Math.max(0, (currentMonthSavings / currentMonthIncome) * 100); // % da receita economizado
            savingsProgress.style.width = `${Math.min(100, savingsPercentage)}%`; // Limita a 100%
            savingsProgress.className = `progress-bar ${currentMonthSavings >= 0 ? 'success' : 'danger'}`;
            savingsStatusEl.textContent = `${currentMonthSavings >= 0 ? 'Positiva' : 'Negativa'} (${savingsPercentage.toFixed(0)}% da receita)`;
        } else {
             savingsProgress.style.width = '0%';
             savingsProgress.className = 'progress-bar'; // Reset class
             savingsStatusEl.textContent = currentMonthExpenses > 0 ? 'Apenas despesas' : 'Sem movimentação';
        }


        // 4. Projeção de Gastos do Mês
        // (Gastos realizados no mês + gastos agendados/pendentes futuros no mês)
        const scheduledExpensesInMonth = transactions
             .filter(t => t.type === 'expense' && typeof t.amount === 'number' && t.status !== 'paid' && moment(t.date).isBetween(currentMonthStart, currentMonthEnd, 'day', '[]'))
             .reduce((sum, t) => sum + t.amount, 0);
        const expensesPaidInMonth = transactions
             .filter(t => t.type === 'expense' && typeof t.amount === 'number' && t.status === 'paid' && moment(t.date).isBetween(currentMonthStart, currentMonthEnd, 'day', '[]'))
             .reduce((sum, t) => sum + t.amount, 0);

        const projectedExpenses = expensesPaidInMonth + scheduledExpensesInMonth;
        projectionEl.textContent = formatCurrency(projectedExpenses);
        projectionStatusEl.textContent = `Realizado: ${formatCurrency(expensesPaidInMonth)} | Previsto: ${formatCurrency(scheduledExpensesInMonth)}`;


        // 5. Tendências vs Mês Anterior
        const lastMonthStart = moment().subtract(1, 'month').startOf('month');
        const lastMonthEnd = moment().subtract(1, 'month').endOf('month');

        const lastMonthIncome = transactions
            .filter(t => t.type === 'income' && typeof t.amount === 'number' && moment(t.date).isBetween(lastMonthStart, lastMonthEnd, 'day', '[]'))
            .reduce((sum, t) => sum + t.amount, 0);
        const lastMonthExpenses = transactions
            .filter(t => t.type === 'expense' && typeof t.amount === 'number' && moment(t.date).isBetween(lastMonthStart, lastMonthEnd, 'day', '[]'))
            .reduce((sum, t) => sum + t.amount, 0);
        const lastMonthBalance = lastMonthIncome - lastMonthExpenses; // Saldo PAGO do mês anterior

         // Calcula saldo PAGO do mês atual para comparação
        const currentMonthPaidBalance = transactions
            .filter(t => t.status === 'paid' && typeof t.amount === 'number' && moment(t.date).isBetween(currentMonthStart, currentMonthEnd, 'day', '[]'))
            .reduce((sum, t) => sum + (t.type === 'income' ? t.amount : -t.amount), 0);


        // Função para calcular e formatar tendência
        const updateTrend = (current, previous, trendValueElement, trendIndicatorElement) => {
            let percentage = 0;
            let trendClass = 'neutral';
             let iconPath = `<path fill-rule="evenodd" d="M1 8a.5.5 0 0 1 .5-.5h13a.5.5 0 0 1 0 1h-13A.5.5 0 0 1 1 8z"/>`; // Traço padrão

             // Calcula percentual apenas se previous for diferente de zero para evitar divisão por zero
            if (previous !== 0) {
                percentage = ((current - previous) / Math.abs(previous)) * 100;
            } else if (current !== 0) {
                 // Se anterior era zero e atual não é, considera 100% de aumento/diminuição
                percentage = 100 * Math.sign(current);
            }
             // Se ambos são zero, percentual é 0

             // Determina classe e ícone (precisão de 1% para definir direção)
            const isExpenseTrend = trendIndicatorElement.id.includes('expenses');
             if (percentage > 1) { // Aumento > 1%
                 trendClass = isExpenseTrend ? 'down' : 'up'; // Aumento de despesa é "down" (ruim), aumento de receita/saldo é "up" (bom)
                 iconPath = `<path fill-rule="evenodd" d="M8 15a.5.5 0 0 0 .5-.5V2.707l3.146 3.147a.5.5 0 0 0 .708-.708l-4-4a.5.5 0 0 0-.708 0l-4 4a.5.5 0 1 0 .708.708L7.5 2.707V14.5a.5.5 0 0 0 .5.5z"/>`; // Seta para cima
             } else if (percentage < -1) { // Diminuição > 1%
                 trendClass = isExpenseTrend ? 'up' : 'down'; // Diminuição de despesa é "up" (bom), diminuição de receita/saldo é "down" (ruim)
                  iconPath = `<path fill-rule="evenodd" d="M8 1a.5.5 0 0 1 .5.5v11.793l3.146-3.147a.5.5 0 0 1 .708.708l-4 4a.5.5 0 0 1-.708 0l-4-4a.5.5 0 0 1 .708-.708L7.5 13.293V1.5A.5.5 0 0 1 8 1z"/>`; // Seta para baixo
             }

            trendValueElement.textContent = `${Math.abs(percentage).toFixed(0)}%`;
            trendIndicatorElement.className = `kpi-trend ${trendClass}`;
            const svgElement = trendIndicatorElement.querySelector('svg');
            if(svgElement) svgElement.innerHTML = iconPath;
        };

        // Atualiza as tendências usando os elementos verificados
        updateTrend(currentMonthPaidBalance, lastMonthBalance, balanceTrendEl, balanceTrendIndicator);
        updateTrend(currentMonthIncome, lastMonthIncome, incomeTrendEl, incomeTrendIndicator);
        updateTrend(currentMonthExpenses, lastMonthExpenses, expensesTrendEl, expensesTrendIndicator); // Lógica invertida na função
    }


    // ===== Lógica da Análise Mensal =====

    function updateMonthlyAnalysis() {
        // Verifica se elementos essenciais existem
        const monthYearSelect = document.getElementById('analysis-month-year');
        const categorySelect = document.getElementById('analysis-category');
        if (!monthYearSelect || !categorySelect) {
             console.error("Filtros de Análise Mensal não encontrados. Abortando.");
             return;
        }
        showLoading();
        console.log(`Atualizando análise para ${currentAnalysisMonthYear}, Categoria: ${currentAnalysisCategory}`);

        const selectedMonthYear = currentAnalysisMonthYear; // Usa o valor do estado global
        const selectedCategory = currentAnalysisCategory; // Usa o valor do estado global

        const startOfMonth = moment(selectedMonthYear).startOf('month');
        const endOfMonth = moment(selectedMonthYear).endOf('month');

        // Filtrar transações para o mês e categoria selecionados
        const monthlyTransactions = transactions.filter(t => {
            // Validação básica da transação
            if (!t.date || typeof t.amount !== 'number' || !t.type) {
                console.warn(`Transação inválida encontrada: ${t.id}`, t);
                return false;
            }
            const transactionMoment = moment(t.date);
            const isSameMonth = transactionMoment.isBetween(startOfMonth, endOfMonth, 'day', '[]');
            const isSameCategory = (selectedCategory === 'all' || t.category === selectedCategory);
            return isSameMonth && isSameCategory;
        });
        console.log(`${monthlyTransactions.length} transações encontradas para a análise.`);

        try {
            // Calcular Indicadores
            calculateMonthlyIndicators(monthlyTransactions, selectedMonthYear);

            // Renderizar Lista de Transações
            renderMonthlyTransactionList(monthlyTransactions);

            // Gerar e Renderizar Insights
            generateAndRenderInsights(monthlyTransactions, selectedMonthYear);

            // Atualizar Gráficos da Análise Mensal
            updateAnalysisCharts(monthlyTransactions);
        } catch (error) {
             console.error("Erro durante a atualização da análise mensal:", error);
             showToast("Ocorreu um erro ao atualizar a análise.", "danger");
             // Limpa a UI de análise para indicar o erro
             // clearAnalysisUI(); // (Função a ser criada se necessário)
        } finally {
            hideLoading();
        }
    }

    function calculateMonthlyIndicators(monthlyTransactions, selectedMonthYear) {
         // Seleciona elementos e verifica existência
        const totalIncomeEl = document.getElementById('analysis-total-income');
        const totalExpensesEl = document.getElementById('analysis-total-expenses');
        const finalBalanceEl = document.getElementById('analysis-final-balance');
        const monthStatusEl = document.getElementById('analysis-month-status');
        const daysLeftEl = document.getElementById('analysis-days-left');
        const incomeCompEl = document.getElementById('analysis-income-comparison');
        const expenseCompEl = document.getElementById('analysis-expense-comparison');
        const balanceCompEl = document.getElementById('analysis-balance-comparison');
        const topCategoryEl = document.getElementById('analysis-top-category');
        const topCategoryValueEl = document.getElementById('analysis-top-category-value');

        if (!totalIncomeEl || !totalExpensesEl || !finalBalanceEl || !monthStatusEl || !daysLeftEl ||
            !incomeCompEl || !expenseCompEl || !balanceCompEl || !topCategoryEl || !topCategoryValueEl) {
            console.warn("Elementos de indicadores da Análise Mensal não encontrados.");
            return;
        }


        const income = monthlyTransactions.filter(t => t.type === 'income').reduce((sum, t) => sum + t.amount, 0);
        const expenses = monthlyTransactions.filter(t => t.type === 'expense').reduce((sum, t) => sum + t.amount, 0);
        const balance = income - expenses;

        totalIncomeEl.textContent = formatCurrency(income);
        totalExpensesEl.textContent = formatCurrency(expenses);
        finalBalanceEl.textContent = formatCurrency(balance);
        finalBalanceEl.className = `indicator-value ${balance >= 0 ? 'positive' : 'negative'}`;

        // Status do Mês e Dias Restantes
        const today = moment();
        const startOfMonthMoment = moment(selectedMonthYear); // Cache moment object
        const endOfMonth = startOfMonthMoment.endOf('month');
        const daysLeft = endOfMonth.diff(today, 'days');

        if (startOfMonthMoment.isSame(today, 'month')) {
            monthStatusEl.textContent = 'Em Andamento';
            daysLeftEl.textContent = `${Math.max(0, daysLeft)} dias restantes`;
        } else if (startOfMonthMoment.isBefore(today, 'month')) {
            monthStatusEl.textContent = 'Fechado';
            daysLeftEl.textContent = 'Mês encerrado';
        } else {
            monthStatusEl.textContent = 'Futuro';
            daysLeftEl.textContent = 'Mês futuro';
        }

         // Comparativos com Mês Anterior
        const lastMonthStr = startOfMonthMoment.subtract(1, 'month').format('YYYY-MM'); // Reusa o moment object
        const lastMonthStart = moment(lastMonthStr).startOf('month');
        const lastMonthEnd = moment(lastMonthStr).endOf('month');
        const lastMonthTransactions = transactions.filter(t => {
             // Validação básica
            if (!t.date || typeof t.amount !== 'number' || !t.type) return false;
             const transactionMoment = moment(t.date);
             const isSameMonth = transactionMoment.isBetween(lastMonthStart, lastMonthEnd, 'day', '[]');
             // Considera a mesma categoria selecionada para comparação justa
             const isSameCategory = (currentAnalysisCategory === 'all' || t.category === currentAnalysisCategory);
             return isSameMonth && isSameCategory;
         });

        const lastMonthIncome = lastMonthTransactions.filter(t => t.type === 'income').reduce((sum, t) => sum + t.amount, 0);
        const lastMonthExpenses = lastMonthTransactions.filter(t => t.type === 'expense').reduce((sum, t) => sum + t.amount, 0);
        const lastMonthBalance = lastMonthIncome - lastMonthExpenses;

        const formatComparison = (current, previous) => {
             if (previous === 0 && current === 0) return "--";
             if (previous === 0) return `${current > 0 ? '+' : ''}100% vs mês anterior`; // Evita divisão por zero
             const diff = current - previous;
             const percentage = ((diff / Math.abs(previous)) * 100); // Usa Math.abs para evitar negativo no denominador
             return `${percentage >= 0 ? '+' : ''}${percentage.toFixed(0)}% vs mês anterior`;
         };

        incomeCompEl.textContent = formatComparison(income, lastMonthIncome);
        expenseCompEl.textContent = formatComparison(expenses, lastMonthExpenses);
        balanceCompEl.textContent = formatComparison(balance, lastMonthBalance);


        // Top Categoria de Gasto
        const expensesByCategory = monthlyTransactions
            .filter(t => t.type === 'expense')
            .reduce((acc, t) => {
                const catId = t.category || 'unknown'; // Trata categoria ausente
                acc[catId] = (acc[catId] || 0) + t.amount;
                return acc;
            }, {});

        const topCategoryEntry = Object.entries(expensesByCategory).sort(([, a], [, b]) => b - a)[0];

        if (topCategoryEntry) {
            const [categoryId, amount] = topCategoryEntry;
            const category = categories.find(c => c.id === categoryId);
            topCategoryEl.textContent = category ? `${category.icon || ''} ${category.name}` : 'Desconhecida';
            topCategoryValueEl.textContent = formatCurrency(amount);
        } else {
            topCategoryEl.textContent = '--';
            topCategoryValueEl.textContent = formatCurrency(0);
        }
    }

    function renderMonthlyTransactionList(monthlyTransactions) {
        const listContainer = document.getElementById('analysis-transaction-list');
        const noTransactionsMessage = document.getElementById('analysis-no-transactions');
        if (!listContainer || !noTransactionsMessage) return; // Verifica elementos

        listContainer.innerHTML = ''; // Limpa a lista

        if (monthlyTransactions.length === 0) {
            noTransactionsMessage.style.display = 'block'; // Mostra mensagem se vazio
            return;
        }
         noTransactionsMessage.style.display = 'none'; // Esconde mensagem

        monthlyTransactions.forEach(t => {
            const category = categories.find(c => c.id === t.category) || { name: 'Desconhecida', icon: '❓', color: '#8E8E93' };
            const item = document.createElement('div');
            item.className = 'transaction-item';
            item.style.cursor = 'pointer'; // Indica clicável
            item.setAttribute('role', 'button'); // Semântica
            item.setAttribute('tabindex', '0'); // Permite foco
            item.addEventListener('click', () => openTransactionModal(t)); // Abre edição ao clicar
            item.addEventListener('keydown', (e) => { // Permite ativar com Enter/Espaço
                if (e.key === 'Enter' || e.key === ' ') {
                    openTransactionModal(t);
                }
            });

            const amountPrefix = t.type === 'income' ? '+' : '-';
            const importanceClass = t.importance ? `transaction-importance ${t.importance}` : '';
            const importanceTitle = t.importance ? `Importância: ${t.importance.charAt(0).toUpperCase() + t.importance.slice(1)}` : '';


            item.innerHTML = `
                <div class="transaction-item-left">
                    <div class="transaction-icon" style="background-color: ${category.color || '#8E8E93'};">
                        ${category.icon || '?'}
                    </div>
                    <div class="transaction-info">
                        <div class="transaction-description">${t.description || category.name || 'Transação sem descrição'}</div>
                        <div class="transaction-category">${category.name || 'Desconhecida'}</div>
                    </div>
                </div>
                <div class="transaction-item-right">
                    <div class="transaction-amount ${t.type === 'income' ? 'income' : 'expense'}">
                        ${amountPrefix} ${formatCurrency(t.amount)}
                         ${importanceClass ? `<span class="${importanceClass}" title="${importanceTitle}"></span>` : ''}
                    </div>
                    <div class="transaction-date">${formatDate(t.date)}</div>
                </div>
                 <!-- Botão Excluir (Opcional, pode poluir a lista) -->
                 <!--
                 <button type="button" class="btn-icon-small btn-delete-transaction" style="margin-left: 1rem; color: var(--danger);" title="Excluir Transação">
                     <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                         <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/>
                         <path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/>
                     </svg>
                 </button>
                 -->
            `;
             // Adiciona listener para o botão de excluir SE ele for adicionado ao HTML acima
             /*
             const deleteBtn = item.querySelector('.btn-delete-transaction');
             if (deleteBtn) {
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Impede que o clique no botão abra o modal de edição
                    confirmDeleteTransaction(t.id);
                });
             }
             */
            listContainer.appendChild(item);
        });
    }

     function generateAndRenderInsights(monthlyTransactions, selectedMonthYear) {
        const insightsList = document.getElementById('analysis-insights-list');
        const noInsightsMessage = document.getElementById('analysis-no-insights');
        if (!insightsList || !noInsightsMessage) return; // Verifica elementos

        insightsList.innerHTML = ''; // Limpa a lista
        const insights = [];

        // Calcula totais do mês atual
        const income = monthlyTransactions.filter(t => t.type === 'income').reduce((sum, t) => sum + t.amount, 0);
        const expenses = monthlyTransactions.filter(t => t.type === 'expense').reduce((sum, t) => sum + t.amount, 0);
        const balance = income - expenses;

         // --- Comparação com Mês Anterior (dados globais) ---
         const lastMonthStr = moment(selectedMonthYear).subtract(1, 'month').format('YYYY-MM');
         const lastMonthStart = moment(lastMonthStr).startOf('month');
         const lastMonthEnd = moment(lastMonthStr).endOf('month');
         const lastMonthTransactions = transactions.filter(t => {
             if (!t.date || typeof t.amount !== 'number' || !t.type) return false;
             return moment(t.date).isBetween(lastMonthStart, lastMonthEnd, 'day', '[]');
             // Nota: Comparação geral, não filtra por categoria selecionada aqui para insights mais amplos
         });

         const lastMonthIncome = lastMonthTransactions.filter(t => t.type === 'income').reduce((sum, t) => sum + t.amount, 0);
         const lastMonthExpenses = lastMonthTransactions.filter(t => t.type === 'expense').reduce((sum, t) => sum + t.amount, 0);

         // Insight: Variação Despesas Gerais
         if (lastMonthExpenses > 0) {
             const expenseChange = ((expenses - lastMonthExpenses) / lastMonthExpenses) * 100;
             if (expenseChange > 15) {
                 insights.push({ type: 'warning', text: `🚨 Atenção: Suas despesas totais (${formatCurrency(expenses)}) aumentaram ${expenseChange.toFixed(0)}% em relação ao mês anterior.` });
             } else if (expenseChange < -10) {
                 insights.push({ type: 'success', text: `✅ Ótimo! Suas despesas totais (${formatCurrency(expenses)}) diminuíram ${Math.abs(expenseChange).toFixed(0)}% este mês.` });
             }
         } else if (expenses > 0) {
             insights.push({ type: 'info', text: `ℹ️ Este foi o primeiro mês com registro de despesas (${formatCurrency(expenses)}).` });
         }

         // Insight: Economia / Saldo do Mês
         if (balance > 50) { // Limiar > 0 para ser mais significativo
             insights.push({ type: 'success', text: `👍 Parabéns! Você fechou o mês com saldo positivo de ${formatCurrency(balance)}.` });
         } else if (balance < -50) { // Limiar < 0
              insights.push({ type: 'alert', text: `📉 Cuidado! Você fechou o mês com saldo negativo de ${formatCurrency(Math.abs(balance))}.` });
         } else if (income > 0 || expenses > 0) { // Se houve movimento mas saldo perto de zero
             insights.push({ type: 'neutral', text: `⚖️ Seu saldo final do mês (${formatCurrency(balance)}) ficou próximo de zero.` });
         }


        // --- Análise de Categorias (do mês atual filtrado) ---
        const expensesByCategory = monthlyTransactions
            .filter(t => t.type === 'expense')
            .reduce((acc, t) => {
                const catId = t.category || 'unknown';
                acc[catId] = (acc[catId] || 0) + t.amount;
                return acc;
            }, {});

         // Calcula despesas do mês anterior POR CATEGORIA (filtrado como na análise)
          const lastMonthFilteredTransactions = transactions.filter(t => {
             if (!t.date || typeof t.amount !== 'number' || !t.type) return false;
             const transactionMoment = moment(t.date);
             const isSameMonth = transactionMoment.isBetween(lastMonthStart, lastMonthEnd, 'day', '[]');
             const isSameCategory = (currentAnalysisCategory === 'all' || t.category === currentAnalysisCategory);
             return isSameMonth && isSameCategory;
         });
         const lastMonthExpensesByCategory = lastMonthFilteredTransactions
            .filter(t => t.type === 'expense')
            .reduce((acc, t) => {
                 const catId = t.category || 'unknown';
                 acc[catId] = (acc[catId] || 0) + t.amount;
                return acc;
            }, {});

         const sortedCategories = Object.entries(expensesByCategory).sort(([, a], [, b]) => b - a);

         // Insight: Maior Categoria de Gasto (do período filtrado)
         if (sortedCategories.length > 0) {
             const [topCategoryId, topAmount] = sortedCategories[0];
             const topCategory = categories.find(c => c.id === topCategoryId);
             const categoryName = topCategory?.name || 'Desconhecida';
             // Mostra insight apenas se houver mais de uma categoria ou se o valor for significativo
             if (sortedCategories.length > 1 || topAmount > 50) {
                insights.push({ type: 'info', text: `🔍 Sua maior despesa ${currentAnalysisCategory !== 'all' ? 'nesta categoria' : 'neste mês'} foi em ${categoryName} (${formatCurrency(topAmount)}).` });
             }
         }

         // Insight: Variação em Categorias Relevantes (comparando com mês anterior, filtrado igual)
         sortedCategories.slice(0, 5).forEach(([categoryId, currentAmount]) => { // Analisa top 5
             const lastAmount = lastMonthExpensesByCategory[categoryId] || 0;
             const category = categories.find(c => c.id === categoryId);
             const categoryName = category?.name || 'Desconhecida';

             if (lastAmount > 0 && currentAmount > 0) { // Compara apenas se houve gasto em ambos os meses
                 const change = ((currentAmount - lastAmount) / lastAmount) * 100;
                 if (change > 25) { // Aumento significativo > 25%
                    insights.push({ type: 'warning', text: `📈 Gastos com ${categoryName} subiram ${change.toFixed(0)}% (${formatCurrency(currentAmount)} vs ${formatCurrency(lastAmount)}).` });
                 } else if (change < -20) { // Redução significativa > 20%
                     insights.push({ type: 'success', text: `📉 Boa! Gastos com ${categoryName} diminuíram ${Math.abs(change).toFixed(0)}% (${formatCurrency(currentAmount)} vs ${formatCurrency(lastAmount)}).` });
                 }
             } else if (lastAmount == 0 && currentAmount > 20) { // Gasto novo significativo (> R$20)
                 insights.push({ type: 'info', text: `🆕 Novo gasto significativo em ${categoryName} este mês: ${formatCurrency(currentAmount)}.` });
             }
         });

         // --- Padrões de Comportamento (Exemplo simples) ---
         if (monthlyTransactions.length > 10) { // Só analisa se houver um número razoável de transações
             const expensesByDayOfWeek = monthlyTransactions
                .filter(t => t.type === 'expense')
                .reduce((acc, t) => {
                    const day = moment(t.date).day(); // 0 = Domingo, 6 = Sábado
                    acc[day] = (acc[day] || 0) + 1; // Conta transações por dia
                    return acc;
                }, {0:0, 1:0, 2:0, 3:0, 4:0, 5:0, 6:0}); // Inicializa todos os dias

             const busiestDayEntry = Object.entries(expensesByDayOfWeek).sort(([, a], [, b]) => b - a)[0];
             if (busiestDayEntry && busiestDayEntry[1] > 0) { // Se houve algum gasto
                 const dayIndex = parseInt(busiestDayEntry[0]);
                 const dayName = moment().day(dayIndex).format('dddd'); // Nome do dia
                 // Se o dia mais movimentado teve mais que o dobro da média diária de transações de despesa
                  const avgTransactionsPerDay = monthlyTransactions.filter(t=>t.type === 'expense').length / moment(selectedMonthYear).daysInMonth();
                  if (busiestDayEntry[1] > avgTransactionsPerDay * 2 && avgTransactionsPerDay > 0) {
                      insights.push({ type: 'neutral', text: `🔄 Padrão notado: ${dayName} parece ser seu dia de maior volume de gastos neste período.` });
                  }
             }
         }


        // Renderiza insights ou mensagem padrão
        if (insights.length > 0) {
             noInsightsMessage.style.display = 'none';
             insights.forEach(insight => {
                const item = document.createElement('div');
                item.className = `insight-item ${insight.type}`;
                // Define ícone com base no tipo
                let icon = '💬'; // Default
                if(insight.type === 'alert') icon = '🚨';
                else if(insight.type === 'warning') icon = '⚠️';
                else if(insight.type === 'success') icon = '✅';
                else if(insight.type === 'info') icon = 'ℹ️';
                else if(insight.type === 'neutral') icon = '🔍';

                item.innerHTML = `
                    <span class="insight-icon">${icon}</span>
                    <span class="insight-text">${insight.text}</span>
                `;
                insightsList.appendChild(item);
            });
        } else {
            noInsightsMessage.textContent = "Nenhum insight relevante encontrado para este período.";
            noInsightsMessage.style.display = 'block';
        }
    }


    // ===== Gráficos =====
    // (Variáveis overviewCharts e analysisCharts movidas para o topo do script)

    // Configurações comuns para gráficos
    function getChartCommonOptions(isDarkMode) {
        const textColor = isDarkMode ? 'rgba(235, 235, 245, 0.8)' : '#3C3C43'; // Cores mais próximas do iOS
        const gridColor = isDarkMode ? 'rgba(84, 84, 88, 0.4)' : 'rgba(60, 60, 67, 0.15)'; // Separator colors
        const tooltipBg = isDarkMode ? 'rgba(44, 44, 46, 0.9)' : 'rgba(249, 249, 249, 0.9)'; // Fundos translúcidos
        const tooltipText = isDarkMode ? '#FFFFFF' : '#1C1C1E';

        return {
            responsive: true,
            maintainAspectRatio: false,
            color: textColor, // Cor padrão do texto (eixos, legendas)
            plugins: {
                legend: {
                    position: 'bottom',
                    align: 'center',
                    labels: {
                        color: textColor,
                        boxWidth: 12,
                        padding: 20,
                        font: { size: 13, family: 'var(--font-sans)' }
                    }
                },
                tooltip: {
                    enabled: true,
                    backgroundColor: tooltipBg,
                    titleColor: tooltipText,
                    bodyColor: tooltipText,
                    borderColor: gridColor,
                    borderWidth: 0.5,
                    padding: 10, // Reduzido
                    cornerRadius: 8,
                    usePointStyle: true,
                    boxPadding: 4,
                     titleFont: { weight: '600', family: 'var(--font-sans)' },
                     bodyFont: { family: 'var(--font-sans)' },
                     footerFont: { family: 'var(--font-sans)', size: 11 },
                    callbacks: {
                        label: function(context) {
                            let label = context.dataset.label || context.label || '';
                            if (label) { label += ': '; }
                            // Funciona para bar, line, pie, doughnut
                            let value = context.parsed.y ?? context.parsed.x ?? context.parsed;
                            if (value !== null && typeof value === 'number') {
                                label += formatCurrency(value);
                            } else if (context.formattedValue){ // Fallback para valores já formatados
                                label += context.formattedValue;
                            }
                            return label;
                        },
                         // Adiciona % em gráficos de pizza/rosca
                         footer: function(tooltipItems) {
                             // Verifica se é Pie ou Doughnut antes de calcular porcentagem
                             if (tooltipItems.length > 0 && tooltipItems[0].chart.config.type.match(/pie|doughnut/)) {
                                 const chart = tooltipItems[0].chart;
                                 const datasetIndex = tooltipItems[0].datasetIndex;
                                 const dataIndex = tooltipItems[0].dataIndex;
                                 const dataset = chart.data.datasets[datasetIndex];
                                 // Garante que dataset.data é um array
                                 const sum = Array.isArray(dataset.data) ? dataset.data.reduce((a, b) => a + (typeof b === 'number' ? b : 0), 0) : 0;
                                 const value = tooltipItems[0].parsed;

                                 if (sum > 0 && typeof value === 'number') {
                                     const percentage = ((value / sum) * 100).toFixed(1) + '%';
                                     return `Percentual: ${percentage}`;
                                 }
                             }
                             return '';
                         }
                    }
                }
            },
            // Configurações de eixos (aplicáveis a bar/line)
            scales: {
                x: {
                    grid: {
                        color: gridColor,
                        drawBorder: false,
                        // Evita linha do grid no eixo y=0
                        // drawOnChartArea: false
                     },
                    ticks: {
                         color: textColor,
                         font: { size: 12, family: 'var(--font-sans)' },
                         maxRotation: 0, // Evita rotação de labels
                         autoSkipPadding: 10 // Mais espaço para pular labels
                    }
                },
                y: {
                    grid: { color: gridColor, drawBorder: false },
                    ticks: {
                         color: textColor,
                         font: { size: 12, family: 'var(--font-sans)' },
                         // Formata como moeda, mas pode simplificar se ficar muito longo
                         callback: function(value) {
                             if (Math.abs(value) >= 1000000) return formatCurrency(value / 1000000) + 'M';
                             if (Math.abs(value) >= 1000) return formatCurrency(value / 1000) + 'k';
                             return formatCurrency(value);
                         }
                    },
                    beginAtZero: true
                }
            },
             // Remove escalas para gráficos sem eixos como Pie/Doughnut
             // (Será sobrescrito na inicialização específica desses gráficos se necessário)
             layout: {
                 padding: { top: 10, bottom: 0, left: 0, right: 10 } // Adiciona padding
             }
        };
    }


    // Inicializar todos os gráficos
    function initCharts() {
         console.log("Inicializando gráficos...");
        const isDark = root.getAttribute('data-theme') === 'dark';
        const commonOptions = getChartCommonOptions(isDark);

        // Destruir gráficos antigos se existirem para evitar duplicação ou memory leaks
        Object.values(overviewCharts).forEach(chart => chart?.destroy());
        Object.values(analysisCharts).forEach(chart => chart?.destroy());
        overviewCharts = {};
        analysisCharts = {};


        // --- Gráficos da Visão Geral ---
        try {
            const ovIncomeExpenseCtx = document.getElementById('overview-income-expense-chart')?.getContext('2d');
            if(ovIncomeExpenseCtx) {
                 console.log("Inicializando overview-income-expense-chart");
                overviewCharts.incomeExpense = new Chart(ovIncomeExpenseCtx, {
                    type: 'bar', data: { labels: [], datasets: [] }, options: { ...commonOptions } // Usa cópia das opções comuns
                });
            } else { console.warn("Canvas 'overview-income-expense-chart' não encontrado."); }

            const ovCategoryCtx = document.getElementById('overview-category-chart')?.getContext('2d');
            if(ovCategoryCtx) {
                 console.log("Inicializando overview-category-chart");
                 // Remove escalas X/Y para doughnut/pie
                 const doughnutOptions = { ...commonOptions };
                 delete doughnutOptions.scales;
                 doughnutOptions.cutout = '65%'; // Opção específica do Doughnut
                overviewCharts.category = new Chart(ovCategoryCtx, {
                    type: 'doughnut', data: { labels: [], datasets: [] }, options: doughnutOptions
                });
            } else { console.warn("Canvas 'overview-category-chart' não encontrado."); }

            const ovCashflowCtx = document.getElementById('overview-cashflow-chart')?.getContext('2d');
             if(ovCashflowCtx) {
                 console.log("Inicializando overview-cashflow-chart");
                overviewCharts.cashflow = new Chart(ovCashflowCtx, {
                    type: 'bar', data: { labels: [], datasets: [] }, options: { ...commonOptions }
                });
            } else { console.warn("Canvas 'overview-cashflow-chart' não encontrado."); }

            const ovFixedVariableCtx = document.getElementById('overview-fixed-variable-chart')?.getContext('2d');
             if(ovFixedVariableCtx) {
                  console.log("Inicializando overview-fixed-variable-chart");
                 const pieOptions = { ...commonOptions };
                 delete pieOptions.scales; // Remove escalas X/Y
                 overviewCharts.fixedVariable = new Chart(ovFixedVariableCtx, {
                    type: 'pie', data: { labels: [], datasets: [] }, options: pieOptions
                });
             } else { console.warn("Canvas 'overview-fixed-variable-chart' não encontrado."); }

             const ovTrendCtx = document.getElementById('overview-trend-chart')?.getContext('2d');
             if(ovTrendCtx) {
                 console.log("Inicializando overview-trend-chart");
                 const lineOptions = { ...commonOptions }; // Usa opções comuns (com escalas)
                 lineOptions.tension = 0.3; // Opções específicas do Line
                 lineOptions.pointRadius = 3;
                 lineOptions.pointHoverRadius = 5;
                 overviewCharts.trend = new Chart(ovTrendCtx, {
                    type: 'line', data: { labels: [], datasets: [] }, options: lineOptions
                });
             } else { console.warn("Canvas 'overview-trend-chart' não encontrado."); }

        } catch(e) { console.error("Erro inicializando gráficos Overview:", e); }


        // --- Gráficos da Análise Mensal ---
         try {
             const anCategoryPieCtx = document.getElementById('analysis-category-pie-chart')?.getContext('2d');
             if(anCategoryPieCtx) {
                 console.log("Inicializando analysis-category-pie-chart");
                  const pieOptions = { ...commonOptions };
                  delete pieOptions.scales; // Remove escalas X/Y
                analysisCharts.categoryPie = new Chart(anCategoryPieCtx, {
                    type: 'pie', data: { labels: [], datasets: [] }, options: pieOptions
                });
             } else { console.warn("Canvas 'analysis-category-pie-chart' não encontrado."); }

             const anBalanceLineCtx = document.getElementById('analysis-balance-line-chart')?.getContext('2d');
             if(anBalanceLineCtx) {
                  console.log("Inicializando analysis-balance-line-chart");
                  const lineOptions = { ...commonOptions }; // Usa opções comuns (com escalas)
                  lineOptions.tension = 0.1; // Linha mais reta para saldo
                  lineOptions.pointRadius = 3;
                  lineOptions.pointHoverRadius = 5;
                  // Personaliza tooltip do eixo Y para este gráfico específico se necessário
                  // lineOptions.scales.y.ticks.callback = function(value) { return 'R$ ' + value; };
                 analysisCharts.balanceLine = new Chart(anBalanceLineCtx, {
                    type: 'line', data: { labels: [], datasets: [] }, options: lineOptions
                });
             } else { console.warn("Canvas 'analysis-balance-line-chart' não encontrado."); }

        } catch(e) { console.error("Erro inicializando gráficos Analysis:", e); }

        console.log("Gráficos inicializados.");
    }


    // Atualizar TODOS os gráficos para o novo tema
    function updateAllChartsTheme() {
        const isDark = root.getAttribute('data-theme') === 'dark';
        const newOptionsBase = getChartCommonOptions(isDark);
        console.log("Atualizando tema dos gráficos para:", isDark ? "Dark" : "Light");

        const updateChartOptions = (chart, specificOptions = {}) => {
             if (chart && chart.options && chart.config) {
                // Merge inteligente: começa com novas opções base,
                // depois aplica opções específicas do tipo de gráfico (se houver),
                // e finalmente aplica opções que não devem mudar com o tema (como 'tension').
                 const optionsToKeep = {
                     tension: chart.options.tension,
                     cutout: chart.options.cutout,
                     // Adicione outras opções que não devem mudar com o tema
                 };

                // Define se o gráfico tem eixos
                 const hasScales = chart.config.type === 'bar' || chart.config.type === 'line';

                 // Cria novas opções
                 let newOptions = { ...newOptionsBase };
                 if (!hasScales) {
                    delete newOptions.scales; // Remove escalas para pie/doughnut
                 }

                 // Merge final
                 chart.options = { ...newOptions, ...specificOptions, ...optionsToKeep };


                // Força atualização completa
                try {
                    chart.update();
                } catch (e) {
                    console.error("Erro ao atualizar gráfico:", chart.canvas?.id, e);
                }
            }
        };

        // Atualiza gráficos individuais, passando opções específicas se necessário
        if (overviewCharts.incomeExpense) updateChartOptions(overviewCharts.incomeExpense);
        if (overviewCharts.category) updateChartOptions(overviewCharts.category, {cutout: '65%'});
        if (overviewCharts.cashflow) updateChartOptions(overviewCharts.cashflow);
        if (overviewCharts.fixedVariable) updateChartOptions(overviewCharts.fixedVariable);
        if (overviewCharts.trend) updateChartOptions(overviewCharts.trend, { tension: 0.3 });

        if (analysisCharts.categoryPie) updateChartOptions(analysisCharts.categoryPie);
        if (analysisCharts.balanceLine) updateChartOptions(analysisCharts.balanceLine, { tension: 0.1 });


        console.log("Temas dos gráficos atualizados.");
    }


    // Atualizar Gráficos da Visão Geral
    function updateOverviewCharts() {
         // Verifica se os gráficos existem antes de tentar atualizar
         if (!overviewCharts || Object.keys(overviewCharts).length === 0) {
             console.warn("Gráficos de Overview não inicializados. Abortando atualização.");
             return;
         }
         console.log("Atualizando gráficos de Overview...");
         const isDark = root.getAttribute('data-theme') === 'dark';

        // --- Receitas vs Despesas (Últimos 12 meses) ---
        if(overviewCharts.incomeExpense) {
            const labels = [];
            const incomeData = [];
            const expenseData = [];
            for (let i = 11; i >= 0; i--) {
                const month = moment().subtract(i, 'months');
                labels.push(month.format('MMM/YY'));
                const start = month.startOf('month');
                const end = month.endOf('month');
                 // Filtra transações PAGAS para o gráfico de histórico financeiro
                const monthIncome = transactions.filter(t => t.type === 'income' && t.status === 'paid' && typeof t.amount === 'number' && moment(t.date).isBetween(start, end, 'day', '[]')).reduce((sum, t) => sum + t.amount, 0);
                const monthExpenses = transactions.filter(t => t.type === 'expense' && t.status === 'paid' && typeof t.amount === 'number' && moment(t.date).isBetween(start, end, 'day', '[]')).reduce((sum, t) => sum + t.amount, 0);
                incomeData.push(monthIncome);
                expenseData.push(monthExpenses);
            }
            overviewCharts.incomeExpense.data = {
                labels,
                datasets: [
                    { label: 'Receitas', data: incomeData, backgroundColor: isDark ? '#30D158' : '#34C759', borderRadius: 4 },
                    { label: 'Despesas', data: expenseData, backgroundColor: isDark ? '#FF453A' : '#FF3B30', borderRadius: 4 }
                ]
            };
             overviewCharts.incomeExpense.update();
        }

        // --- Despesas por Categoria (Últimos 30 dias) ---
        if(overviewCharts.category) {
            const last30DaysStart = moment().subtract(30, 'days').startOf('day'); // Inclui o dia inicial
            const expensesLast30Days = transactions.filter(t =>
                t.type === 'expense' &&
                typeof t.amount === 'number' &&
                t.date && // Garante que a data existe
                moment(t.date).isSameOrAfter(last30DaysStart) // Usa SameOrAfter
                // Poderia filtrar por status 'paid' se quisesse apenas gastos efetivados
                // && t.status === 'paid'
            );

            const expensesByCategory = expensesLast30Days.reduce((acc, t) => {
                 const catId = t.category || 'unknown';
                const category = categories.find(c => c.id === catId) || { id: 'unknown', name: 'Desconhecida', color: '#8E8E93', icon: '❓' };
                acc[category.id] = (acc[category.id] || { name: `${category.icon} ${category.name}`, value: 0, color: category.color });
                acc[category.id].value += t.amount;
                return acc;
            }, {});

             const sortedCategories = Object.values(expensesByCategory).sort((a, b) => b.value - a.value);
             overviewCharts.category.data = {
                labels: sortedCategories.map(c => c.name),
                datasets: [{
                    data: sortedCategories.map(c => c.value),
                    backgroundColor: sortedCategories.map(c => c.color),
                    borderColor: isDark ? '#000000' : '#FFFFFF', // Usa bg do tema
                    borderWidth: 2
                }]
             };
             overviewCharts.category.update();
        }

         // --- Fluxo de Caixa Mensal (Ano Atual) ---
        if (overviewCharts.cashflow) {
            const currentYear = moment().year();
            const labels = [];
            const balanceData = [];
            for (let i = 0; i < 12; i++) {
                const month = moment().year(currentYear).month(i);
                labels.push(month.format('MMM'));
                const start = month.startOf('month');
                const end = month.endOf('month');
                 // Fluxo considera apenas transações PAGAS
                const monthIncome = transactions.filter(t => t.type === 'income' && t.status === 'paid' && typeof t.amount === 'number' && moment(t.date).isBetween(start, end, 'day', '[]')).reduce((sum, t) => sum + t.amount, 0);
                const monthExpenses = transactions.filter(t => t.type === 'expense' && t.status === 'paid' && typeof t.amount === 'number' && moment(t.date).isBetween(start, end, 'day', '[]')).reduce((sum, t) => sum + t.amount, 0);
                balanceData.push(monthIncome - monthExpenses);
            }
            overviewCharts.cashflow.data = {
                labels,
                datasets: [{
                    label: 'Saldo Mensal (Pago)',
                    data: balanceData,
                    backgroundColor: balanceData.map(b => b >= 0 ? (isDark ? '#30D158' : '#34C759') : (isDark ? '#FF453A' : '#FF3B30')),
                    borderRadius: 4
                }]
            };
            overviewCharts.cashflow.update();
        }

        // --- Fixas vs Variáveis (Mês Atual) ---
        // Considera despesas do mês atual, independente do status, para refletir o *comprometido*
        if(overviewCharts.fixedVariable) {
             const currentMonthStart = moment().startOf('month');
             const currentMonthEnd = moment().endOf('month');
             const monthExpenses = transactions.filter(t =>
                 t.type === 'expense' &&
                 typeof t.amount === 'number' &&
                 t.date &&
                 moment(t.date).isBetween(currentMonthStart, currentMonthEnd, 'day', '[]')
             );

             // Considera "Fixa" se tiver recurringInfo.baseId
             const fixed = monthExpenses.filter(t => t.recurringInfo?.baseId).reduce((sum, t) => sum + t.amount, 0);
             const variable = monthExpenses.filter(t => !t.recurringInfo?.baseId).reduce((sum, t) => sum + t.amount, 0);

             overviewCharts.fixedVariable.data = {
                 labels: ['Fixas (Recorrentes)', 'Variáveis'],
                 datasets: [{
                    data: [fixed, variable],
                    backgroundColor: [isDark ? '#0A84FF' : '#007AFF', isDark ? '#BF5AF2' : '#AF52DE'], // Blue, Purple
                     borderColor: isDark ? '#000000' : '#FFFFFF',
                    borderWidth: 2
                 }]
             };
             overviewCharts.fixedVariable.update();
        }

         // --- Tendência Geral de Gastos (Últimos 6 Meses) ---
         // Baseado em despesas PAGAS para refletir o gasto real histórico
         if(overviewCharts.trend) {
             const labels = [];
             const data = [];
             for (let i = 5; i >= 0; i--) {
                 const month = moment().subtract(i, 'months');
                 labels.push(month.format('MMM/YY'));
                 const start = month.startOf('month');
                 const end = month.endOf('month');
                 const monthExpenses = transactions.filter(t => t.type === 'expense' && t.status === 'paid' && typeof t.amount === 'number' && t.date && moment(t.date).isBetween(start, end, 'day', '[]')).reduce((sum, t) => sum + t.amount, 0);
                 data.push(monthExpenses);
             }
             overviewCharts.trend.data = {
                labels,
                datasets: [{
                    label: 'Despesas Pagas',
                    data: data,
                    borderColor: isDark ? '#FF9F0A' : '#FF9500', // Orange
                    backgroundColor: isDark ? 'rgba(255, 159, 10, 0.15)' : 'rgba(255, 149, 0, 0.1)',
                    fill: true
                    // tension já definido na inicialização
                }]
             };
             overviewCharts.trend.update();
         }
         console.log("Gráficos de Overview atualizados.");
    }


     // Atualizar Gráficos da Análise Mensal
    function updateAnalysisCharts(monthlyTransactions) {
         if (!analysisCharts || Object.keys(analysisCharts).length === 0) {
             console.warn("Gráficos de Análise não inicializados. Abortando atualização.");
             return;
         }
         console.log("Atualizando gráficos de Análise Mensal...");
        const isDark = root.getAttribute('data-theme') === 'dark';

        // --- Distribuição de Despesas (Pizza) ---
        // Baseado em TODAS as despesas do mês/categoria filtrado (inclui não pagas)
        if (analysisCharts.categoryPie) {
            const expensesByCategory = monthlyTransactions
                .filter(t => t.type === 'expense')
                .reduce((acc, t) => {
                     const catId = t.category || 'unknown';
                    const category = categories.find(c => c.id === catId) || { id: 'unknown', name: 'Desconhecida', color: '#8E8E93', icon: '❓' };
                    // Agrupa por ID, mas usa nome+ícone no label
                    acc[category.id] = (acc[category.id] || { name: `${category.icon} ${category.name}`, value: 0, color: category.color });
                    acc[category.id].value += t.amount;
                    return acc;
                }, {});

            const sortedCategories = Object.values(expensesByCategory).sort((a, b) => b.value - a.value);

             // Limitar a N categorias + "Outros" para não poluir
            const maxCategories = 7;
            let displayLabels = sortedCategories.slice(0, maxCategories).map(c => c.name);
            let displayData = sortedCategories.slice(0, maxCategories).map(c => c.value);
            let displayColors = sortedCategories.slice(0, maxCategories).map(c => c.color);

            if (sortedCategories.length > maxCategories) {
                const otherValue = sortedCategories.slice(maxCategories).reduce((sum, c) => sum + c.value, 0);
                 if (otherValue > 0) { // Só adiciona "Outros" se tiver valor
                     displayLabels.push("Outros");
                     displayData.push(otherValue);
                     displayColors.push(isDark ? '#48484A' : '#C7C7CC'); // System Gray 2
                 }
            }

            analysisCharts.categoryPie.data = {
                labels: displayLabels,
                datasets: [{
                    data: displayData,
                    backgroundColor: displayColors,
                    borderColor: isDark ? '#000000' : '#FFFFFF',
                    borderWidth: 2
                }]
            };
            analysisCharts.categoryPie.update();
        }

        // --- Evolução do Saldo no Mês (Linha) ---
        // Baseado em transações PAGAS para refletir o saldo real diário
        if (analysisCharts.balanceLine) {
             const selectedMonth = moment(currentAnalysisMonthYear);
            const daysInMonth = selectedMonth.daysInMonth();
            const labels = Array.from({ length: daysInMonth }, (_, i) => (i + 1).toString()); // Dias 1 a N
            const dailyBalances = [];
            let cumulativeBalance = 0;

            // Calcular saldo inicial do mês (saldo total PAGO até o dia anterior ao início do mês)
             const startOfMonth = selectedMonth.startOf('month');
             const initialBalance = transactions
                 .filter(t => t.status === 'paid' && typeof t.amount === 'number' && t.date && moment(t.date).isBefore(startOfMonth, 'day'))
                 .reduce((sum, t) => sum + (t.type === 'income' ? t.amount : -t.amount), 0);
             cumulativeBalance = initialBalance;


            for (let day = 1; day <= daysInMonth; day++) {
                 const currentDayMoment = moment(currentAnalysisMonthYear).date(day);
                 // Filtra transações PAGAS ocorridas ATÉ este dia no mês atual
                 const balanceChangeToday = monthlyTransactions // Usa transações já filtradas por mês/categoria
                     .filter(t => t.status === 'paid' && moment(t.date).isSame(currentDayMoment, 'day'))
                     .reduce((sum, t) => sum + (t.type === 'income' ? t.amount : -t.amount), 0);

                cumulativeBalance += balanceChangeToday;
                dailyBalances.push(cumulativeBalance);
            }

            analysisCharts.balanceLine.data = {
                labels,
                datasets: [{
                    label: 'Saldo Acumulado (Pago)',
                    data: dailyBalances,
                    borderColor: isDark ? '#0A84FF' : '#007AFF', // Blue
                    backgroundColor: isDark ? 'rgba(10, 132, 255, 0.15)' : 'rgba(0, 122, 255, 0.1)',
                    fill: true
                    // tension já definido na inicialização
                }]
            };
            analysisCharts.balanceLine.update();
        }
         console.log("Gráficos de Análise Mensal atualizados.");
    }

    // ===== Inicialização da Aplicação =====

    async function init() {
        showLoading();
        console.log("Iniciando aplicação...");

        try {
            // 1. Configurar Tema (síncrono)
            setupTheme();

            // 2. Carregar Categorias (Garantindo Padrões se necessário)
            // Precisa esperar antes de popular filtros e iniciar listeners
             // Verifica se 'db' está disponível antes de tentar carregar
             if(db) {
                await loadCategories();
             } else {
                 console.error("Banco de dados não inicializado. Carregando categorias padrão localmente.");
                 // Carrega padrões locais se DB falhou
                 categories = [...DEFAULT_INCOME_CATEGORIES, ...DEFAULT_EXPENSE_CATEGORIES].sort((a, b) => a.name.localeCompare(b.name));
                 populateCategoryFilters(); // Popula filtros com os padrões
             }


            // 3. Inicializar Componentes da UI (Filtros, Modais, Tabs)
            initTabs();
            populateMonthYearFilter(); // Popula filtro de Mês/Ano (não depende de dados async)
            // populateCategoryFilters() já foi chamado dentro de loadCategories ou no fallback
            initCharts(); // Inicializa a estrutura dos gráficos (antes de receber dados)

            // 4. Configurar Listeners de Eventos da UI (síncrono)
            setupEventListeners(); // Configura todos os listeners de botões, selects etc.

            // 5. Configurar Listeners do Firestore (assíncrono)
            // Só inicia listeners se DB estiver ok
            if(db) {
                setupFirestoreListeners();
            } else {
                 console.error("Listeners do Firestore não iniciados - DB indisponível.");
                 // Talvez carregar dados de exemplo ou localStorage aqui
                 // Por enquanto, a aplicação ficará sem dados reais.
                 updateDashboard(); // Chama para mostrar estado vazio/inicial
            }


            // 6. Atualização inicial (os listeners podem demorar um pouco para trazer os primeiros dados)
             // updateDashboard(); // É chamado dentro de processTransactionSnapshot, então não precisa aqui
             console.log("Estrutura da aplicação inicializada. Aguardando dados do Firestore...");


        } catch (error) {
            console.error("Erro fatal durante a inicialização:", error);
            showToast("Erro grave ao iniciar. Verifique o console (F12) e recarregue a página.", "danger", 10000);
             // Tenta garantir que a UI básica esteja funcional mesmo em erro
             try {
                initTabs();
                setupEventListeners();
             } catch (uiError) {
                 console.error("Erro ao configurar UI de fallback:", uiError);
             }
        } finally {
             // Garante que o loading seja escondido mesmo se houver erro parcial
             // Um pequeno delay pode ajudar a UI a renderizar antes de esconder
             setTimeout(hideLoading, 500); // Aumenta um pouco o delay
        }
    }

    // --- Ponto de Entrada ---
    // Espera o DOM carregar completamente
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        // DOM já carregado, executa imediatamente
        init();
    }


     // --- Limpeza ao Sair ---
     // Garante que os listeners são removidos para evitar memory leaks em SPAs (embora aqui seja página única)
     window.addEventListener('beforeunload', stopFirestoreListeners);


  </script>
</body>
</html>
